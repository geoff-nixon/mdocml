head	1.300;
access;
symbols
	VERSION_1_13_3:1.283
	VERSION_1_13_2:1.263
	VERSION_1_12_4:1.245
	VERSION_1_13_1:1.243
	VERSION_1_14:1.237.0.2
	VERSION_1_12_3:1.198
	VERSION_1_12_2:1.193
	VERSION_1_12:1.245.0.2
	VERSION_1_12_1:1.182
	VERSION_1_12_0:1.176
	VERSION_1_11_7:1.176
	VERSION_1_11_6:1.174
	VERSION_1_11_5:1.171
	VERSION_1_11_4:1.169
	VERSION_1_11_3:1.169
	VERSION_1_11_2:1.169
	VERSION_1_11_1:1.166
	VERSION_1_10_10:1.163
	VERSION_1_10_9:1.151
	VERSION_1_10_8:1.147
	VERSION_1_10_7:1.138
	VERSION_1_10_6:1.118
	VERSION_1_10_5:1.114
	VERSION_1_10_5_PREPDF:1.113
	VERSION_1_10_4:1.109
	VERSION_1_10_3:1.102
	VERSION_1_10_2:1.99
	VERSION_1_10_1:1.91
	VERSION_1_9_24:1.70
	VERSION_1_9_25:1.72
	VERSION_1_9_23:1.67
	VERSION_1_9_22:1.59
	VERSION_1_9_21:1.58
	VERSION_1_9_20:1.58
	VERSION_1_9_19:1.58
	VERSION_1_9_18:1.58
	VERSION_1_9_17:1.58
	VERSION_1_9_16:1.58
	VERSION_1_9_15:1.58
	VERSION_1_9_15-pre2:1.56
	VERSION_1_9_15-pre1:1.55
	VERSION_1_9_14:1.54
	VERSION_1_9_13:1.54
	VERSION_1_9_12:1.52
	VERSION_1_9_11:1.51
	VERSION_1_9_10:1.51
	VERSION_1_9_9:1.48
	VERSION_1_9_8:1.44
	VERSION_1_9_7:1.44
	VERSION_1_9_6:1.44
	VERSION_1_9_5:1.42
	VERSION_1_9_2:1.42
	VERSION_1_9_1:1.42
	VERSION_1_9_0:1.41
	VERSION_1_8_5:1.41
	VERSION_1_8_4:1.41
	VERSION_1_8_3:1.39
	VERSION_1_8_2:1.38
	VERSION_1_8_1:1.37
	VERSION_1_8_0:1.32
	VERSION_1_7_24:1.26
	VERSION_1_7_23:1.24
	VERSION_1_7_22:1.19
	VERSION_1_7_21:1.19
	VERSION_1_7_20:1.16
	VERSION_1_7_19:1.15
	VERSION_1_7_17:1.9
	VERSION_1_7_16:1.9
	VERSION_1_7_15:1.9
	VERSION_1_7_14:1.8
	VERSION_1_7_13:1.6
	VERSION_1_7_12:1.3
	OPENBSD_CHECKIN:1.3
	VERSION_1_7_10:1.3
	VERSION_1_7_5:1.1;
locks; strict;
comment	@ * @;


1.300
date	2015.10.30.19.04.16;	author schwarze;	state Exp;
branches;
next	1.299;

1.299
date	2015.10.21.23.51.11;	author schwarze;	state Exp;
branches;
next	1.298;

1.298
date	2015.10.20.02.01.32;	author schwarze;	state Exp;
branches;
next	1.297;

1.297
date	2015.10.19.20.04.10;	author schwarze;	state Exp;
branches;
next	1.296;

1.296
date	2015.10.12.21.26.02;	author schwarze;	state Exp;
branches;
next	1.295;

1.295
date	2015.10.12.00.08.16;	author schwarze;	state Exp;
branches;
next	1.294;

1.294
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.293;

1.293
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.292;

1.292
date	2015.09.14.15.36.14;	author schwarze;	state Exp;
branches;
next	1.291;

1.291
date	2015.04.23.16.17.44;	author schwarze;	state Exp;
branches;
next	1.290;

1.290
date	2015.04.20.09.48.53;	author schwarze;	state Exp;
branches;
next	1.289;

1.289
date	2015.04.19.14.25.41;	author schwarze;	state Exp;
branches;
next	1.288;

1.288
date	2015.04.19.14.00.20;	author schwarze;	state Exp;
branches;
next	1.287;

1.287
date	2015.04.19.13.50.26;	author schwarze;	state Exp;
branches;
next	1.286;

1.286
date	2015.04.18.16.06.41;	author schwarze;	state Exp;
branches;
next	1.285;

1.285
date	2015.04.02.22.48.17;	author schwarze;	state Exp;
branches;
next	1.284;

1.284
date	2015.04.02.21.36.50;	author schwarze;	state Exp;
branches;
next	1.283;

1.283
date	2015.02.23.13.55.55;	author schwarze;	state Exp;
branches;
next	1.282;

1.282
date	2015.02.23.13.31.04;	author schwarze;	state Exp;
branches;
next	1.281;

1.281
date	2015.02.17.20.37.17;	author schwarze;	state Exp;
branches;
next	1.280;

1.280
date	2015.02.16.19.02.48;	author schwarze;	state Exp;
branches;
next	1.279;

1.279
date	2015.02.14.13.23.57;	author schwarze;	state Exp;
branches;
next	1.278;

1.278
date	2015.02.12.12.24.33;	author schwarze;	state Exp;
branches;
next	1.277;

1.277
date	2015.02.10.08.05.30;	author schwarze;	state Exp;
branches;
next	1.276;

1.276
date	2015.02.06.16.06.25;	author schwarze;	state Exp;
branches;
next	1.275;

1.275
date	2015.02.06.07.13.14;	author schwarze;	state Exp;
branches;
next	1.274;

1.274
date	2015.02.06.03.38.45;	author schwarze;	state Exp;
branches;
next	1.273;

1.273
date	2015.02.06.02.04.54;	author schwarze;	state Exp;
branches;
next	1.272;

1.272
date	2015.02.06.01.07.22;	author schwarze;	state Exp;
branches;
next	1.271;

1.271
date	2015.02.05.01.46.56;	author schwarze;	state Exp;
branches;
next	1.270;

1.270
date	2015.02.04.22.30.10;	author schwarze;	state Exp;
branches;
next	1.269;

1.269
date	2015.02.04.19.20.12;	author schwarze;	state Exp;
branches;
next	1.268;

1.268
date	2015.02.04.18.03.47;	author schwarze;	state Exp;
branches;
next	1.267;

1.267
date	2015.02.04.16.38.56;	author schwarze;	state Exp;
branches;
next	1.266;

1.266
date	2015.02.03.00.48.47;	author schwarze;	state Exp;
branches;
next	1.265;

1.265
date	2014.12.18.20.15.56;	author schwarze;	state Exp;
branches;
next	1.264;

1.264
date	2014.12.18.19.23.41;	author schwarze;	state Exp;
branches;
next	1.263;

1.263
date	2014.11.30.05.29.00;	author schwarze;	state Exp;
branches;
next	1.262;

1.262
date	2014.11.28.18.36.35;	author schwarze;	state Exp;
branches;
next	1.261;

1.261
date	2014.11.28.18.09.01;	author schwarze;	state Exp;
branches;
next	1.260;

1.260
date	2014.11.28.17.24.41;	author schwarze;	state Exp;
branches;
next	1.259;

1.259
date	2014.11.28.01.05.43;	author schwarze;	state Exp;
branches;
next	1.258;

1.258
date	2014.11.27.23.40.19;	author schwarze;	state Exp;
branches;
next	1.257;

1.257
date	2014.11.27.16.20.31;	author schwarze;	state Exp;
branches;
next	1.256;

1.256
date	2014.11.26.19.24.03;	author schwarze;	state Exp;
branches;
next	1.255;

1.255
date	2014.11.17.06.44.58;	author schwarze;	state Exp;
branches;
next	1.254;

1.254
date	2014.10.30.20.10.02;	author schwarze;	state Exp;
branches;
next	1.253;

1.253
date	2014.10.13.14.05.32;	author schwarze;	state Exp;
branches;
next	1.252;

1.252
date	2014.10.13.14.01.21;	author schwarze;	state Exp;
branches;
next	1.251;

1.251
date	2014.10.11.21.34.04;	author schwarze;	state Exp;
branches;
next	1.250;

1.250
date	2014.10.11.21.14.16;	author schwarze;	state Exp;
branches;
next	1.249;

1.249
date	2014.09.12.00.54.10;	author schwarze;	state Exp;
branches;
next	1.248;

1.248
date	2014.09.11.23.53.30;	author schwarze;	state Exp;
branches;
next	1.247;

1.247
date	2014.09.07.23.25.01;	author schwarze;	state Exp;
branches;
next	1.246;

1.246
date	2014.09.07.00.05.28;	author schwarze;	state Exp;
branches;
next	1.245;

1.245
date	2014.08.19.17.31.55;	author schwarze;	state Exp;
branches;
next	1.244;

1.244
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.243;

1.243
date	2014.08.06.15.09.05;	author schwarze;	state Exp;
branches;
next	1.242;

1.242
date	2014.08.02.00.02.42;	author schwarze;	state Exp;
branches;
next	1.241;

1.241
date	2014.08.01.22.22.11;	author schwarze;	state Exp;
branches;
next	1.240;

1.240
date	2014.08.01.17.40.34;	author schwarze;	state Exp;
branches;
next	1.239;

1.239
date	2014.08.01.17.27.44;	author schwarze;	state Exp;
branches;
next	1.238;

1.238
date	2014.07.31.09.22.21;	author schwarze;	state Exp;
branches;
next	1.237;

1.237
date	2014.07.31.00.41.10;	author schwarze;	state Exp;
branches;
next	1.236;

1.236
date	2014.07.30.23.38.52;	author schwarze;	state Exp;
branches;
next	1.235;

1.235
date	2014.07.30.17.06.26;	author schwarze;	state Exp;
branches;
next	1.234;

1.234
date	2014.07.30.14.50.08;	author schwarze;	state Exp;
branches;
next	1.233;

1.233
date	2014.07.30.12.58.21;	author schwarze;	state Exp;
branches;
next	1.232;

1.232
date	2014.07.30.00.19.16;	author schwarze;	state Exp;
branches;
next	1.231;

1.231
date	2014.07.29.13.58.18;	author schwarze;	state Exp;
branches;
next	1.230;

1.230
date	2014.07.07.16.12.20;	author schwarze;	state Exp;
branches;
next	1.229;

1.229
date	2014.07.06.19.09.00;	author schwarze;	state Exp;
branches;
next	1.228;

1.228
date	2014.07.05.12.34.17;	author schwarze;	state Exp;
branches;
next	1.227;

1.227
date	2014.07.05.01.12.20;	author schwarze;	state Exp;
branches;
next	1.226;

1.226
date	2014.07.04.16.12.08;	author schwarze;	state Exp;
branches;
next	1.225;

1.225
date	2014.07.04.01.50.07;	author schwarze;	state Exp;
branches;
next	1.224;

1.224
date	2014.07.03.23.24.56;	author schwarze;	state Exp;
branches;
next	1.223;

1.223
date	2014.07.02.20.19.11;	author schwarze;	state Exp;
branches;
next	1.222;

1.222
date	2014.07.02.19.55.10;	author schwarze;	state Exp;
branches;
next	1.221;

1.221
date	2014.07.02.13.10.45;	author schwarze;	state Exp;
branches;
next	1.220;

1.220
date	2014.07.02.11.43.20;	author schwarze;	state Exp;
branches;
next	1.219;

1.219
date	2014.07.02.05.52.25;	author schwarze;	state Exp;
branches;
next	1.218;

1.218
date	2014.07.02.03.48.07;	author schwarze;	state Exp;
branches;
next	1.217;

1.217
date	2014.07.01.22.37.15;	author schwarze;	state Exp;
branches;
next	1.216;

1.216
date	2014.06.20.23.02.31;	author schwarze;	state Exp;
branches;
next	1.215;

1.215
date	2014.06.20.17.24.00;	author schwarze;	state Exp;
branches;
next	1.214;

1.214
date	2014.04.23.21.06.41;	author schwarze;	state Exp;
branches;
next	1.213;

1.213
date	2014.04.23.16.08.33;	author schwarze;	state Exp;
branches;
next	1.212;

1.212
date	2014.04.20.20.48.53;	author schwarze;	state Exp;
branches;
next	1.211;

1.211
date	2014.04.20.19.40.13;	author schwarze;	state Exp;
branches;
next	1.210;

1.210
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.209;

1.209
date	2014.04.15.00.41.09;	author schwarze;	state Exp;
branches;
next	1.208;

1.208
date	2014.03.31.01.05.32;	author schwarze;	state Exp;
branches;
next	1.207;

1.207
date	2014.03.30.23.28.06;	author schwarze;	state Exp;
branches;
next	1.206;

1.206
date	2014.03.30.19.47.48;	author schwarze;	state Exp;
branches;
next	1.205;

1.205
date	2014.03.23.15.14.50;	author schwarze;	state Exp;
branches;
next	1.204;

1.204
date	2014.03.23.12.11.18;	author schwarze;	state Exp;
branches;
next	1.203;

1.203
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.202;

1.202
date	2014.01.11.22.16.10;	author schwarze;	state Exp;
branches;
next	1.201;

1.201
date	2014.01.07.09.10.45;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2014.01.06.22.39.25;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2014.01.06.00.53.33;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2013.12.15.21.23.52;	author schwarze;	state Exp;
branches;
next	1.197;

1.197
date	2013.10.21.23.47.58;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2013.10.06.22.46.15;	author schwarze;	state Exp;
branches;
next	1.195;

1.195
date	2013.10.06.13.32.46;	author schwarze;	state Exp;
branches;
next	1.194;

1.194
date	2013.10.05.22.08.12;	author schwarze;	state Exp;
branches;
next	1.193;

1.193
date	2013.09.16.00.25.07;	author schwarze;	state Exp;
branches;
next	1.192;

1.192
date	2013.08.05.14.36.01;	author schwarze;	state Exp;
branches;
next	1.191;

1.191
date	2012.11.17.00.26.33;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2012.11.16.22.21.05;	author schwarze;	state Exp;
branches;
next	1.189;

1.189
date	2012.07.18.11.11.12;	author schwarze;	state Exp;
branches;
next	1.188;

1.188
date	2012.07.16.09.51.54;	author schwarze;	state Exp;
branches;
next	1.187;

1.187
date	2012.07.12.15.11.14;	author schwarze;	state Exp;
branches;
next	1.186;

1.186
date	2012.07.11.16.57.43;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2012.07.10.14.38.51;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2012.05.27.17.48.57;	author schwarze;	state Exp;
branches;
next	1.183;

1.183
date	2012.05.27.17.39.28;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2012.03.23.05.50.25;	author kristaps;	state Exp;
branches;
next	1.181;

1.181
date	2011.12.03.16.58.54;	author schwarze;	state Exp;
branches;
next	1.180;

1.180
date	2011.12.02.01.37.14;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2011.11.19.13.29.47;	author schwarze;	state Exp;
branches;
next	1.178;

1.178
date	2011.11.18.14.58.24;	author joerg;	state Exp;
branches;
next	1.177;

1.177
date	2011.10.16.12.20.34;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2011.09.02.19.40.18;	author kristaps;	state Exp;
branches;
next	1.175;

1.175
date	2011.08.19.13.59.23;	author kristaps;	state Exp;
branches;
next	1.174;

1.174
date	2011.08.16.12.23.51;	author kristaps;	state Exp;
branches;
next	1.173;

1.173
date	2011.08.10.14.07.23;	author kristaps;	state Exp;
branches;
next	1.172;

1.172
date	2011.07.26.14.09.01;	author kristaps;	state Exp;
branches;
next	1.171;

1.171
date	2011.07.24.18.15.14;	author kristaps;	state Exp;
branches;
next	1.170;

1.170
date	2011.07.18.07.46.41;	author kristaps;	state Exp;
branches;
next	1.169;

1.169
date	2011.04.30.10.18.24;	author kristaps;	state Exp;
branches;
next	1.168;

1.168
date	2011.04.13.09.57.08;	author kristaps;	state Exp;
branches;
next	1.167;

1.167
date	2011.04.09.15.29.40;	author kristaps;	state Exp;
branches;
next	1.166;

1.166
date	2011.04.03.09.53.50;	author kristaps;	state Exp;
branches;
next	1.165;

1.165
date	2011.03.22.14.33.05;	author kristaps;	state Exp;
branches;
next	1.164;

1.164
date	2011.03.20.16.02.05;	author kristaps;	state Exp;
branches;
next	1.163;

1.163
date	2011.03.17.12.14.19;	author kristaps;	state Exp;
branches;
next	1.162;

1.162
date	2011.03.17.11.30.23;	author kristaps;	state Exp;
branches;
next	1.161;

1.161
date	2011.03.17.09.24.51;	author kristaps;	state Exp;
branches;
next	1.160;

1.160
date	2011.03.17.09.22.39;	author kristaps;	state Exp;
branches;
next	1.159;

1.159
date	2011.03.15.16.23.51;	author kristaps;	state Exp;
branches;
next	1.158;

1.158
date	2011.03.07.01.35.51;	author schwarze;	state Exp;
branches;
next	1.157;

1.157
date	2011.02.09.09.18.15;	author kristaps;	state Exp;
branches;
next	1.156;

1.156
date	2011.02.06.21.44.36;	author kristaps;	state Exp;
branches;
next	1.155;

1.155
date	2011.02.02.21.40.45;	author kristaps;	state Exp;
branches;
next	1.154;

1.154
date	2011.01.25.15.46.05;	author kristaps;	state Exp;
branches;
next	1.153;

1.153
date	2011.01.25.10.37.49;	author kristaps;	state Exp;
branches;
next	1.152;

1.152
date	2011.01.22.14.00.52;	author schwarze;	state Exp;
branches;
next	1.151;

1.151
date	2011.01.03.23.53.51;	author schwarze;	state Exp;
branches;
next	1.150;

1.150
date	2011.01.01.12.18.37;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2010.12.25.23.25.53;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2010.12.25.13.50.37;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2010.12.24.14.00.40;	author kristaps;	state Exp;
branches;
next	1.146;

1.146
date	2010.12.22.22.05.38;	author schwarze;	state Exp;
branches;
next	1.145;

1.145
date	2010.12.22.11.15.16;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2010.12.16.17.14.48;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2010.12.16.00.57.50;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2010.12.16.00.53.04;	author kristaps;	state Exp;
branches;
next	1.141;

1.141
date	2010.12.16.00.25.35;	author kristaps;	state Exp;
branches;
next	1.140;

1.140
date	2010.12.15.23.39.40;	author kristaps;	state Exp;
branches;
next	1.139;

1.139
date	2010.12.09.10.32.22;	author kristaps;	state Exp;
branches;
next	1.138;

1.138
date	2010.12.05.15.59.27;	author kristaps;	state Exp;
branches;
next	1.137;

1.137
date	2010.12.05.15.55.01;	author kristaps;	state Exp;
branches;
next	1.136;

1.136
date	2010.12.05.15.49.37;	author kristaps;	state Exp;
branches;
next	1.135;

1.135
date	2010.12.05.15.37.30;	author kristaps;	state Exp;
branches;
next	1.134;

1.134
date	2010.12.01.13.05.13;	author kristaps;	state Exp;
branches;
next	1.133;

1.133
date	2010.11.30.14.27.37;	author kristaps;	state Exp;
branches;
next	1.132;

1.132
date	2010.11.30.12.59.20;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2010.11.30.12.35.10;	author kristaps;	state Exp;
branches;
next	1.130;

1.130
date	2010.11.30.10.32.05;	author kristaps;	state Exp;
branches;
next	1.129;

1.129
date	2010.11.29.16.06.46;	author kristaps;	state Exp;
branches;
next	1.128;

1.128
date	2010.11.29.15.45.15;	author kristaps;	state Exp;
branches;
next	1.127;

1.127
date	2010.11.29.14.56.43;	author kristaps;	state Exp;
branches;
next	1.126;

1.126
date	2010.11.29.14.50.33;	author kristaps;	state Exp;
branches;
next	1.125;

1.125
date	2010.11.29.13.51.03;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2010.11.29.13.12.24;	author kristaps;	state Exp;
branches;
next	1.123;

1.123
date	2010.11.29.13.02.47;	author kristaps;	state Exp;
branches;
next	1.122;

1.122
date	2010.11.29.12.22.28;	author kristaps;	state Exp;
branches;
next	1.121;

1.121
date	2010.10.11.15.46.19;	author kristaps;	state Exp;
branches;
next	1.120;

1.120
date	2010.10.11.13.24.33;	author kristaps;	state Exp;
branches;
next	1.119;

1.119
date	2010.09.27.23.03.44;	author schwarze;	state Exp;
branches;
next	1.118;

1.118
date	2010.09.27.11.25.03;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2010.09.27.09.26.27;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2010.08.29.10.30.58;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2010.08.20.01.02.07;	author schwarze;	state Exp;
branches;
next	1.114;

1.114
date	2010.07.26.13.45.49;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2010.07.21.09.08.26;	author kristaps;	state Exp;
branches;
next	1.112;

1.112
date	2010.07.20.14.56.42;	author kristaps;	state Exp;
branches;
next	1.111;

1.111
date	2010.07.19.11.11.54;	author kristaps;	state Exp;
branches;
next	1.110;

1.110
date	2010.07.13.23.53.20;	author schwarze;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.04.21.59.30;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.02.17.42.23;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.02.15.03.14;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2010.07.02.13.12.47;	author kristaps;	state Exp;
branches;
next	1.105;

1.105
date	2010.07.02.12.54.33;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2010.07.01.22.56.17;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2010.07.01.21.44.47;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2010.06.28.14.39.17;	author kristaps;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.27.17.53.27;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.27.16.36.22;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2010.06.13.21.02.49;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2010.06.12.12.38.01;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.12.12.10.55;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.12.11.58.22;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2010.06.12.11.41.50;	author kristaps;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.12.11.21.44;	author kristaps;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.12.10.09.19;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2010.06.09.19.22.56;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.03.13.44.36;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2010.05.31.23.40.25;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.31.23.10.51;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.31.10.28.04;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2010.05.30.22.56.02;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.30.11.47.44;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.30.11.00.53;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.26.10.39.35;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.26.09.35.35;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.25.12.44.53;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.24.12.31.16;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.17.23.57.06;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.15.16.24.38;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.14.17.54.26;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.14.17.31.25;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.14.16.02.29;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.14.15.26.39;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2010.05.14.14.34.29;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.12.08.41.17;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.09.21.19.42;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.08.07.30.19;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2010.04.07.19.35.42;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2010.04.07.18.50.35;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2010.04.06.17.01.27;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2010.04.06.16.27.53;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2010.04.06.11.52.25;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2010.04.06.11.28.17;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2010.04.03.14.25.12;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2010.04.03.14.12.48;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.03.14.02.10;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.03.13.02.35;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2010.03.31.07.13.53;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2010.02.17.19.28.11;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.30.08.42.21;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.01.17.14.30;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.01.15.14.03;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.02.06.22.46;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.31.08.34.12;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.31.06.10.58;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.26.04.09.46;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.24.05.52.14;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.22.10.35.33;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.19.09.40.23;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.19.07.34.44;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.18.13.26.16;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.15.02.56.51;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.24.15.08.41;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.24.15.01.06;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.20.13.22.48;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.07.25.16.03.03;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.24.12.09.37;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.23.08.36.32;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.20.15.05.34;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.18.23.31.04;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.17.12.40.48;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.17.12.27.49;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.17.12.08.08;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.17.10.56.57;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.13.07.23.07;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.12.20.50.08;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.12.20.30.35;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.12.16.41.33;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.12.16.38.15;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.12.16.34.16;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.12.09.13.21;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.07.11.47.17;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.07.09.52.08;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.06.13.04.52;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.06.11.05.29;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.06.11.00.05;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.06.09.21.24;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.04.10.41.29;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.04.09.01.55;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.27.09.03.03;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.18.20.46.19;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.17.14.10.09;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.17.14.08.47;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.17.11.02.06;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.17.10.53.32;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.17.09.41.00;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.16.19.45.51;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.12.09.18.00;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.11.10.34.31;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.10.20.18.43;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.12.19.49.35;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.12.19.45.26;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.12.19.19.57;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.02.16.37.40;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.31.13.50.19;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.25.15.17.49;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.300
log
@If a .Bd block has no arguments at all, drop the block and only keep
its contents.  Removing a gratuitious difference to groff output
found after a related bug report from krw@@.
@
text
@/*	$Id: mdoc_validate.c,v 1.299 2015/10/21 23:51:11 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2010 Joerg Sonnenberger <joerg@@netbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>
#ifndef OSNAME
#include <sys/utsname.h>
#endif

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libmdoc.h"

/* FIXME: .Bl -diag can't have non-text children in HEAD. */

#define	POST_ARGS struct roff_man *mdoc

enum	check_ineq {
	CHECK_LT,
	CHECK_GT,
	CHECK_EQ
};

typedef	void	(*v_post)(POST_ARGS);

static	void	 check_text(struct roff_man *, int, int, char *);
static	void	 check_argv(struct roff_man *,
			struct roff_node *, struct mdoc_argv *);
static	void	 check_args(struct roff_man *, struct roff_node *);
static	int	 child_an(const struct roff_node *);
static	size_t		macro2len(int);
static	void	 rewrite_macro2len(char **);

static	void	 post_an(POST_ARGS);
static	void	 post_an_norm(POST_ARGS);
static	void	 post_at(POST_ARGS);
static	void	 post_bd(POST_ARGS);
static	void	 post_bf(POST_ARGS);
static	void	 post_bk(POST_ARGS);
static	void	 post_bl(POST_ARGS);
static	void	 post_bl_block(POST_ARGS);
static	void	 post_bl_block_tag(POST_ARGS);
static	void	 post_bl_head(POST_ARGS);
static	void	 post_bl_norm(POST_ARGS);
static	void	 post_bx(POST_ARGS);
static	void	 post_defaults(POST_ARGS);
static	void	 post_display(POST_ARGS);
static	void	 post_dd(POST_ARGS);
static	void	 post_dt(POST_ARGS);
static	void	 post_en(POST_ARGS);
static	void	 post_es(POST_ARGS);
static	void	 post_eoln(POST_ARGS);
static	void	 post_ex(POST_ARGS);
static	void	 post_fa(POST_ARGS);
static	void	 post_fn(POST_ARGS);
static	void	 post_fname(POST_ARGS);
static	void	 post_fo(POST_ARGS);
static	void	 post_hyph(POST_ARGS);
static	void	 post_ignpar(POST_ARGS);
static	void	 post_it(POST_ARGS);
static	void	 post_lb(POST_ARGS);
static	void	 post_nd(POST_ARGS);
static	void	 post_nm(POST_ARGS);
static	void	 post_ns(POST_ARGS);
static	void	 post_obsolete(POST_ARGS);
static	void	 post_os(POST_ARGS);
static	void	 post_par(POST_ARGS);
static	void	 post_prevpar(POST_ARGS);
static	void	 post_root(POST_ARGS);
static	void	 post_rs(POST_ARGS);
static	void	 post_sh(POST_ARGS);
static	void	 post_sh_head(POST_ARGS);
static	void	 post_sh_name(POST_ARGS);
static	void	 post_sh_see_also(POST_ARGS);
static	void	 post_sh_authors(POST_ARGS);
static	void	 post_sm(POST_ARGS);
static	void	 post_st(POST_ARGS);
static	void	 post_std(POST_ARGS);

static	v_post mdoc_valids[MDOC_MAX] = {
	NULL,		/* Ap */
	post_dd,	/* Dd */
	post_dt,	/* Dt */
	post_os,	/* Os */
	post_sh,	/* Sh */
	post_ignpar,	/* Ss */
	post_par,	/* Pp */
	post_display,	/* D1 */
	post_display,	/* Dl */
	post_display,	/* Bd */
	NULL,		/* Ed */
	post_bl,	/* Bl */
	NULL,		/* El */
	post_it,	/* It */
	NULL,		/* Ad */
	post_an,	/* An */
	post_defaults,	/* Ar */
	NULL,		/* Cd */
	NULL,		/* Cm */
	NULL,		/* Dv */
	NULL,		/* Er */
	NULL,		/* Ev */
	post_ex,	/* Ex */
	post_fa,	/* Fa */
	NULL,		/* Fd */
	NULL,		/* Fl */
	post_fn,	/* Fn */
	NULL,		/* Ft */
	NULL,		/* Ic */
	NULL,		/* In */
	post_defaults,	/* Li */
	post_nd,	/* Nd */
	post_nm,	/* Nm */
	NULL,		/* Op */
	post_obsolete,	/* Ot */
	post_defaults,	/* Pa */
	post_std,	/* Rv */
	post_st,	/* St */
	NULL,		/* Va */
	NULL,		/* Vt */
	NULL,		/* Xr */
	NULL,		/* %A */
	post_hyph,	/* %B */ /* FIXME: can be used outside Rs/Re. */
	NULL,		/* %D */
	NULL,		/* %I */
	NULL,		/* %J */
	post_hyph,	/* %N */
	post_hyph,	/* %O */
	NULL,		/* %P */
	post_hyph,	/* %R */
	post_hyph,	/* %T */ /* FIXME: can be used outside Rs/Re. */
	NULL,		/* %V */
	NULL,		/* Ac */
	NULL,		/* Ao */
	NULL,		/* Aq */
	post_at,	/* At */
	NULL,		/* Bc */
	post_bf,	/* Bf */
	NULL,		/* Bo */
	NULL,		/* Bq */
	NULL,		/* Bsx */
	post_bx,	/* Bx */
	post_obsolete,	/* Db */
	NULL,		/* Dc */
	NULL,		/* Do */
	NULL,		/* Dq */
	NULL,		/* Ec */
	NULL,		/* Ef */
	NULL,		/* Em */
	NULL,		/* Eo */
	NULL,		/* Fx */
	NULL,		/* Ms */
	NULL,		/* No */
	post_ns,	/* Ns */
	NULL,		/* Nx */
	NULL,		/* Ox */
	NULL,		/* Pc */
	NULL,		/* Pf */
	NULL,		/* Po */
	NULL,		/* Pq */
	NULL,		/* Qc */
	NULL,		/* Ql */
	NULL,		/* Qo */
	NULL,		/* Qq */
	NULL,		/* Re */
	post_rs,	/* Rs */
	NULL,		/* Sc */
	NULL,		/* So */
	NULL,		/* Sq */
	post_sm,	/* Sm */
	post_hyph,	/* Sx */
	NULL,		/* Sy */
	NULL,		/* Tn */
	NULL,		/* Ux */
	NULL,		/* Xc */
	NULL,		/* Xo */
	post_fo,	/* Fo */
	NULL,		/* Fc */
	NULL,		/* Oo */
	NULL,		/* Oc */
	post_bk,	/* Bk */
	NULL,		/* Ek */
	post_eoln,	/* Bt */
	NULL,		/* Hf */
	post_obsolete,	/* Fr */
	post_eoln,	/* Ud */
	post_lb,	/* Lb */
	post_par,	/* Lp */
	NULL,		/* Lk */
	post_defaults,	/* Mt */
	NULL,		/* Brq */
	NULL,		/* Bro */
	NULL,		/* Brc */
	NULL,		/* %C */
	post_es,	/* Es */
	post_en,	/* En */
	NULL,		/* Dx */
	NULL,		/* %Q */
	post_par,	/* br */
	post_par,	/* sp */
	NULL,		/* %U */
	NULL,		/* Ta */
	NULL,		/* ll */
};

#define	RSORD_MAX 14 /* Number of `Rs' blocks. */

static	const int rsord[RSORD_MAX] = {
	MDOC__A,
	MDOC__T,
	MDOC__B,
	MDOC__I,
	MDOC__J,
	MDOC__R,
	MDOC__N,
	MDOC__V,
	MDOC__U,
	MDOC__P,
	MDOC__Q,
	MDOC__C,
	MDOC__D,
	MDOC__O
};

static	const char * const secnames[SEC__MAX] = {
	NULL,
	"NAME",
	"LIBRARY",
	"SYNOPSIS",
	"DESCRIPTION",
	"CONTEXT",
	"IMPLEMENTATION NOTES",
	"RETURN VALUES",
	"ENVIRONMENT",
	"FILES",
	"EXIT STATUS",
	"EXAMPLES",
	"DIAGNOSTICS",
	"COMPATIBILITY",
	"ERRORS",
	"SEE ALSO",
	"STANDARDS",
	"HISTORY",
	"AUTHORS",
	"CAVEATS",
	"BUGS",
	"SECURITY CONSIDERATIONS",
	NULL
};


void
mdoc_node_validate(struct roff_man *mdoc)
{
	struct roff_node *n;
	v_post *p;

	n = mdoc->last;
	mdoc->last = mdoc->last->child;
	while (mdoc->last != NULL) {
		mdoc_node_validate(mdoc);
		if (mdoc->last == n)
			mdoc->last = mdoc->last->child;
		else
			mdoc->last = mdoc->last->next;
	}

	mdoc->last = n;
	mdoc->next = ROFF_NEXT_SIBLING;
	switch (n->type) {
	case ROFFT_TEXT:
		if (n->sec != SEC_SYNOPSIS || n->parent->tok != MDOC_Fd)
			check_text(mdoc, n->line, n->pos, n->string);
		break;
	case ROFFT_EQN:
	case ROFFT_TBL:
		break;
	case ROFFT_ROOT:
		post_root(mdoc);
		break;
	default:
		check_args(mdoc, mdoc->last);

		/*
		 * Closing delimiters are not special at the
		 * beginning of a block, opening delimiters
		 * are not special at the end.
		 */

		if (n->child != NULL)
			n->child->flags &= ~MDOC_DELIMC;
		if (n->last != NULL)
			n->last->flags &= ~MDOC_DELIMO;

		/* Call the macro's postprocessor. */

		p = mdoc_valids + n->tok;
		if (*p)
			(*p)(mdoc);
		if (mdoc->last == n)
			mdoc_state(mdoc, n);
		break;
	}
}

static void
check_args(struct roff_man *mdoc, struct roff_node *n)
{
	int		 i;

	if (NULL == n->args)
		return;

	assert(n->args->argc);
	for (i = 0; i < (int)n->args->argc; i++)
		check_argv(mdoc, n, &n->args->argv[i]);
}

static void
check_argv(struct roff_man *mdoc, struct roff_node *n, struct mdoc_argv *v)
{
	int		 i;

	for (i = 0; i < (int)v->sz; i++)
		check_text(mdoc, v->line, v->pos, v->value[i]);
}

static void
check_text(struct roff_man *mdoc, int ln, int pos, char *p)
{
	char		*cp;

	if (MDOC_LITERAL & mdoc->flags)
		return;

	for (cp = p; NULL != (p = strchr(p, '\t')); p++)
		mandoc_msg(MANDOCERR_FI_TAB, mdoc->parse,
		    ln, pos + (int)(p - cp), NULL);
}

static void
post_bl_norm(POST_ARGS)
{
	struct roff_node *n;
	struct mdoc_argv *argv, *wa;
	int		  i;
	enum mdocargt	  mdoclt;
	enum mdoc_list	  lt;

	n = mdoc->last->parent;
	n->norm->Bl.type = LIST__NONE;

	/*
	 * First figure out which kind of list to use: bind ourselves to
	 * the first mentioned list type and warn about any remaining
	 * ones.  If we find no list type, we default to LIST_item.
	 */

	wa = (n->args == NULL) ? NULL : n->args->argv;
	mdoclt = MDOC_ARG_MAX;
	for (i = 0; n->args && i < (int)n->args->argc; i++) {
		argv = n->args->argv + i;
		lt = LIST__NONE;
		switch (argv->arg) {
		/* Set list types. */
		case MDOC_Bullet:
			lt = LIST_bullet;
			break;
		case MDOC_Dash:
			lt = LIST_dash;
			break;
		case MDOC_Enum:
			lt = LIST_enum;
			break;
		case MDOC_Hyphen:
			lt = LIST_hyphen;
			break;
		case MDOC_Item:
			lt = LIST_item;
			break;
		case MDOC_Tag:
			lt = LIST_tag;
			break;
		case MDOC_Diag:
			lt = LIST_diag;
			break;
		case MDOC_Hang:
			lt = LIST_hang;
			break;
		case MDOC_Ohang:
			lt = LIST_ohang;
			break;
		case MDOC_Inset:
			lt = LIST_inset;
			break;
		case MDOC_Column:
			lt = LIST_column;
			break;
		/* Set list arguments. */
		case MDOC_Compact:
			if (n->norm->Bl.comp)
				mandoc_msg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -compact");
			n->norm->Bl.comp = 1;
			break;
		case MDOC_Width:
			wa = argv;
			if (0 == argv->sz) {
				mandoc_msg(MANDOCERR_ARG_EMPTY,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -width");
				n->norm->Bl.width = "0n";
				break;
			}
			if (NULL != n->norm->Bl.width)
				mandoc_vmsg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -width %s",
				    argv->value[0]);
			rewrite_macro2len(argv->value);
			n->norm->Bl.width = argv->value[0];
			break;
		case MDOC_Offset:
			if (0 == argv->sz) {
				mandoc_msg(MANDOCERR_ARG_EMPTY,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -offset");
				break;
			}
			if (NULL != n->norm->Bl.offs)
				mandoc_vmsg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bl -offset %s",
				    argv->value[0]);
			rewrite_macro2len(argv->value);
			n->norm->Bl.offs = argv->value[0];
			break;
		default:
			continue;
		}
		if (LIST__NONE == lt)
			continue;
		mdoclt = argv->arg;

		/* Check: multiple list types. */

		if (LIST__NONE != n->norm->Bl.type) {
			mandoc_vmsg(MANDOCERR_BL_REP,
			    mdoc->parse, n->line, n->pos,
			    "Bl -%s", mdoc_argnames[argv->arg]);
			continue;
		}

		/* The list type should come first. */

		if (n->norm->Bl.width ||
		    n->norm->Bl.offs ||
		    n->norm->Bl.comp)
			mandoc_vmsg(MANDOCERR_BL_LATETYPE,
			    mdoc->parse, n->line, n->pos, "Bl -%s",
			    mdoc_argnames[n->args->argv[0].arg]);

		n->norm->Bl.type = lt;
		if (LIST_column == lt) {
			n->norm->Bl.ncols = argv->sz;
			n->norm->Bl.cols = (void *)argv->value;
		}
	}

	/* Allow lists to default to LIST_item. */

	if (LIST__NONE == n->norm->Bl.type) {
		mandoc_msg(MANDOCERR_BL_NOTYPE, mdoc->parse,
		    n->line, n->pos, "Bl");
		n->norm->Bl.type = LIST_item;
	}

	/*
	 * Validate the width field.  Some list types don't need width
	 * types and should be warned about them.  Others should have it
	 * and must also be warned.  Yet others have a default and need
	 * no warning.
	 */

	switch (n->norm->Bl.type) {
	case LIST_tag:
		if (NULL == n->norm->Bl.width)
			mandoc_msg(MANDOCERR_BL_NOWIDTH, mdoc->parse,
			    n->line, n->pos, "Bl -tag");
		break;
	case LIST_column:
	case LIST_diag:
	case LIST_ohang:
	case LIST_inset:
	case LIST_item:
		if (n->norm->Bl.width)
			mandoc_vmsg(MANDOCERR_BL_SKIPW, mdoc->parse,
			    wa->line, wa->pos, "Bl -%s",
			    mdoc_argnames[mdoclt]);
		break;
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
		if (NULL == n->norm->Bl.width)
			n->norm->Bl.width = "2n";
		break;
	case LIST_enum:
		if (NULL == n->norm->Bl.width)
			n->norm->Bl.width = "3n";
		break;
	default:
		break;
	}
}

static void
post_bd(POST_ARGS)
{
	struct roff_node *n;
	struct mdoc_argv *argv;
	int		  i;
	enum mdoc_disp	  dt;

	n = mdoc->last;
	for (i = 0; n->args && i < (int)n->args->argc; i++) {
		argv = n->args->argv + i;
		dt = DISP__NONE;

		switch (argv->arg) {
		case MDOC_Centred:
			dt = DISP_centered;
			break;
		case MDOC_Ragged:
			dt = DISP_ragged;
			break;
		case MDOC_Unfilled:
			dt = DISP_unfilled;
			break;
		case MDOC_Filled:
			dt = DISP_filled;
			break;
		case MDOC_Literal:
			dt = DISP_literal;
			break;
		case MDOC_File:
			mandoc_msg(MANDOCERR_BD_FILE, mdoc->parse,
			    n->line, n->pos, NULL);
			break;
		case MDOC_Offset:
			if (0 == argv->sz) {
				mandoc_msg(MANDOCERR_ARG_EMPTY,
				    mdoc->parse, argv->line,
				    argv->pos, "Bd -offset");
				break;
			}
			if (NULL != n->norm->Bd.offs)
				mandoc_vmsg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bd -offset %s",
				    argv->value[0]);
			rewrite_macro2len(argv->value);
			n->norm->Bd.offs = argv->value[0];
			break;
		case MDOC_Compact:
			if (n->norm->Bd.comp)
				mandoc_msg(MANDOCERR_ARG_REP,
				    mdoc->parse, argv->line,
				    argv->pos, "Bd -compact");
			n->norm->Bd.comp = 1;
			break;
		default:
			abort();
		}
		if (DISP__NONE == dt)
			continue;

		if (DISP__NONE == n->norm->Bd.type)
			n->norm->Bd.type = dt;
		else
			mandoc_vmsg(MANDOCERR_BD_REP,
			    mdoc->parse, n->line, n->pos,
			    "Bd -%s", mdoc_argnames[argv->arg]);
	}

	if (DISP__NONE == n->norm->Bd.type) {
		mandoc_msg(MANDOCERR_BD_NOTYPE, mdoc->parse,
		    n->line, n->pos, "Bd");
		n->norm->Bd.type = DISP_ragged;
	}
}

static void
post_an_norm(POST_ARGS)
{
	struct roff_node *n;
	struct mdoc_argv *argv;
	size_t	 i;

	n = mdoc->last;
	if (n->args == NULL)
		return;

	for (i = 1; i < n->args->argc; i++) {
		argv = n->args->argv + i;
		mandoc_vmsg(MANDOCERR_AN_REP,
		    mdoc->parse, argv->line, argv->pos,
		    "An -%s", mdoc_argnames[argv->arg]);
	}

	argv = n->args->argv;
	if (argv->arg == MDOC_Split)
		n->norm->An.auth = AUTH_split;
	else if (argv->arg == MDOC_Nosplit)
		n->norm->An.auth = AUTH_nosplit;
	else
		abort();
}

static void
post_std(POST_ARGS)
{
	struct roff_node *n;

	n = mdoc->last;
	if (n->args && n->args->argc == 1)
		if (n->args->argv[0].arg == MDOC_Std)
			return;

	mandoc_msg(MANDOCERR_ARG_STD, mdoc->parse,
	    n->line, n->pos, mdoc_macronames[n->tok]);
}

static void
post_obsolete(POST_ARGS)
{
	struct roff_node *n;

	n = mdoc->last;
	if (n->type == ROFFT_ELEM || n->type == ROFFT_BLOCK)
		mandoc_msg(MANDOCERR_MACRO_OBS, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
}

static void
post_bf(POST_ARGS)
{
	struct roff_node *np, *nch;

	/*
	 * Unlike other data pointers, these are "housed" by the HEAD
	 * element, which contains the goods.
	 */

	np = mdoc->last;
	if (np->type != ROFFT_HEAD)
		return;

	assert(np->parent->type == ROFFT_BLOCK);
	assert(np->parent->tok == MDOC_Bf);

	/* Check the number of arguments. */

	nch = np->child;
	if (np->parent->args == NULL) {
		if (nch == NULL) {
			mandoc_msg(MANDOCERR_BF_NOFONT, mdoc->parse,
			    np->line, np->pos, "Bf");
			return;
		}
		nch = nch->next;
	}
	if (nch != NULL)
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nch->line, nch->pos, "Bf ... %s", nch->string);

	/* Extract argument into data. */

	if (np->parent->args != NULL) {
		switch (np->parent->args->argv[0].arg) {
		case MDOC_Emphasis:
			np->norm->Bf.font = FONT_Em;
			break;
		case MDOC_Literal:
			np->norm->Bf.font = FONT_Li;
			break;
		case MDOC_Symbolic:
			np->norm->Bf.font = FONT_Sy;
			break;
		default:
			abort();
		}
		return;
	}

	/* Extract parameter into data. */

	if ( ! strcmp(np->child->string, "Em"))
		np->norm->Bf.font = FONT_Em;
	else if ( ! strcmp(np->child->string, "Li"))
		np->norm->Bf.font = FONT_Li;
	else if ( ! strcmp(np->child->string, "Sy"))
		np->norm->Bf.font = FONT_Sy;
	else
		mandoc_vmsg(MANDOCERR_BF_BADFONT, mdoc->parse,
		    np->child->line, np->child->pos,
		    "Bf %s", np->child->string);
}

static void
post_lb(POST_ARGS)
{
	struct roff_node	*n;
	const char		*stdlibname;
	char			*libname;

	n = mdoc->last->child;
	assert(n->type == ROFFT_TEXT);

	if (NULL == (stdlibname = mdoc_a2lib(n->string)))
		mandoc_asprintf(&libname,
		    "library \\(Lq%s\\(Rq", n->string);
	else
		libname = mandoc_strdup(stdlibname);

	free(n->string);
	n->string = libname;
}

static void
post_eoln(POST_ARGS)
{
	const struct roff_node *n;

	n = mdoc->last;
	if (n->child != NULL)
		mandoc_vmsg(MANDOCERR_ARG_SKIP,
		    mdoc->parse, n->line, n->pos,
		    "%s %s", mdoc_macronames[n->tok],
		    n->child->string);
}

static void
post_fname(POST_ARGS)
{
	const struct roff_node	*n;
	const char		*cp;
	size_t			 pos;

	n = mdoc->last->child;
	pos = strcspn(n->string, "()");
	cp = n->string + pos;
	if ( ! (cp[0] == '\0' || (cp[0] == '(' && cp[1] == '*')))
		mandoc_msg(MANDOCERR_FN_PAREN, mdoc->parse,
		    n->line, n->pos + pos, n->string);
}

static void
post_fn(POST_ARGS)
{

	post_fname(mdoc);
	post_fa(mdoc);
}

static void
post_fo(POST_ARGS)
{
	const struct roff_node	*n;

	n = mdoc->last;

	if (n->type != ROFFT_HEAD)
		return;

	if (n->child == NULL) {
		mandoc_msg(MANDOCERR_FO_NOHEAD, mdoc->parse,
		    n->line, n->pos, "Fo");
		return;
	}
	if (n->child != n->last) {
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    n->child->next->line, n->child->next->pos,
		    "Fo ... %s", n->child->next->string);
		while (n->child != n->last)
			roff_node_delete(mdoc, n->last);
	}

	post_fname(mdoc);
}

static void
post_fa(POST_ARGS)
{
	const struct roff_node *n;
	const char *cp;

	for (n = mdoc->last->child; n != NULL; n = n->next) {
		for (cp = n->string; *cp != '\0'; cp++) {
			/* Ignore callbacks and alterations. */
			if (*cp == '(' || *cp == '{')
				break;
			if (*cp != ',')
				continue;
			mandoc_msg(MANDOCERR_FA_COMMA, mdoc->parse,
			    n->line, n->pos + (cp - n->string),
			    n->string);
			break;
		}
	}
}

static void
post_nm(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;

	if (n->last != NULL &&
	    (n->last->tok == MDOC_Pp ||
	     n->last->tok == MDOC_Lp))
		mdoc_node_relink(mdoc, n->last);

	if (mdoc->meta.name != NULL)
		return;

	deroff(&mdoc->meta.name, n);

	if (mdoc->meta.name == NULL)
		mandoc_msg(MANDOCERR_NM_NONAME, mdoc->parse,
		    n->line, n->pos, "Nm");
}

static void
post_nd(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;

	if (n->type != ROFFT_BODY)
		return;

	if (n->child == NULL)
		mandoc_msg(MANDOCERR_ND_EMPTY, mdoc->parse,
		    n->line, n->pos, "Nd");

	post_hyph(mdoc);
}

static void
post_display(POST_ARGS)
{
	struct roff_node *n, *np;

	n = mdoc->last;
	switch (n->type) {
	case ROFFT_BODY:
		if (n->end != ENDBODY_NOT)
			break;
		if (n->child == NULL)
			mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
			    n->line, n->pos, mdoc_macronames[n->tok]);
		else if (n->tok == MDOC_D1)
			post_hyph(mdoc);
		break;
	case ROFFT_BLOCK:
		if (n->tok == MDOC_Bd) {
			if (n->args == NULL) {
				mandoc_msg(MANDOCERR_BD_NOARG,
				    mdoc->parse, n->line, n->pos, "Bd");
				mdoc->next = ROFF_NEXT_SIBLING;
				while (n->body->child != NULL)
					mdoc_node_relink(mdoc,
					    n->body->child);
				roff_node_delete(mdoc, n);
				break;
			}
			post_bd(mdoc);
			post_prevpar(mdoc);
		}
		for (np = n->parent; np != NULL; np = np->parent) {
			if (np->type == ROFFT_BLOCK && np->tok == MDOC_Bd) {
				mandoc_vmsg(MANDOCERR_BD_NEST,
				    mdoc->parse, n->line, n->pos,
				    "%s in Bd", mdoc_macronames[n->tok]);
				break;
			}
		}
		break;
	default:
		break;
	}
}

static void
post_defaults(POST_ARGS)
{
	struct roff_node *nn;

	/*
	 * The `Ar' defaults to "file ..." if no value is provided as an
	 * argument; the `Mt' and `Pa' macros use "~"; the `Li' just
	 * gets an empty string.
	 */

	if (mdoc->last->child != NULL)
		return;

	nn = mdoc->last;

	switch (nn->tok) {
	case MDOC_Ar:
		mdoc->next = ROFF_NEXT_CHILD;
		roff_word_alloc(mdoc, nn->line, nn->pos, "file");
		roff_word_alloc(mdoc, nn->line, nn->pos, "...");
		break;
	case MDOC_Pa:
	case MDOC_Mt:
		mdoc->next = ROFF_NEXT_CHILD;
		roff_word_alloc(mdoc, nn->line, nn->pos, "~");
		break;
	default:
		abort();
	}
	mdoc->last = nn;
}

static void
post_at(POST_ARGS)
{
	struct roff_node	*n;
	const char		*std_att;
	char			*att;

	n = mdoc->last;
	if (n->child == NULL) {
		mdoc->next = ROFF_NEXT_CHILD;
		roff_word_alloc(mdoc, n->line, n->pos, "AT&T UNIX");
		mdoc->last = n;
		return;
	}

	/*
	 * If we have a child, look it up in the standard keys.  If a
	 * key exist, use that instead of the child; if it doesn't,
	 * prefix "AT&T UNIX " to the existing data.
	 */

	n = n->child;
	assert(n->type == ROFFT_TEXT);
	if ((std_att = mdoc_a2att(n->string)) == NULL) {
		mandoc_vmsg(MANDOCERR_AT_BAD, mdoc->parse,
		    n->line, n->pos, "At %s", n->string);
		mandoc_asprintf(&att, "AT&T UNIX %s", n->string);
	} else
		att = mandoc_strdup(std_att);

	free(n->string);
	n->string = att;
}

static void
post_an(POST_ARGS)
{
	struct roff_node *np, *nch;

	post_an_norm(mdoc);

	np = mdoc->last;
	nch = np->child;
	if (np->norm->An.auth == AUTH__NONE) {
		if (nch == NULL)
			mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
			    np->line, np->pos, "An");
	} else if (nch != NULL)
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nch->line, nch->pos, "An ... %s", nch->string);
}

static void
post_en(POST_ARGS)
{

	post_obsolete(mdoc);
	if (mdoc->last->type == ROFFT_BLOCK)
		mdoc->last->norm->Es = mdoc->last_es;
}

static void
post_es(POST_ARGS)
{

	post_obsolete(mdoc);
	mdoc->last_es = mdoc->last;
}

static void
post_it(POST_ARGS)
{
	struct roff_node *nbl, *nit, *nch;
	int		  i, cols;
	enum mdoc_list	  lt;

	post_prevpar(mdoc);

	nit = mdoc->last;
	if (nit->type != ROFFT_BLOCK)
		return;

	nbl = nit->parent->parent;
	lt = nbl->norm->Bl.type;

	switch (lt) {
	case LIST_tag:
	case LIST_hang:
	case LIST_ohang:
	case LIST_inset:
	case LIST_diag:
		if (nit->head->child == NULL)
			mandoc_vmsg(MANDOCERR_IT_NOHEAD,
			    mdoc->parse, nit->line, nit->pos,
			    "Bl -%s It",
			    mdoc_argnames[nbl->args->argv[0].arg]);
		break;
	case LIST_bullet:
	case LIST_dash:
	case LIST_enum:
	case LIST_hyphen:
		if (nit->body == NULL || nit->body->child == NULL)
			mandoc_vmsg(MANDOCERR_IT_NOBODY,
			    mdoc->parse, nit->line, nit->pos,
			    "Bl -%s It",
			    mdoc_argnames[nbl->args->argv[0].arg]);
		/* FALLTHROUGH */
	case LIST_item:
		if (nit->head->child != NULL)
			mandoc_vmsg(MANDOCERR_ARG_SKIP,
			    mdoc->parse, nit->line, nit->pos,
			    "It %s", nit->head->child->string);
		break;
	case LIST_column:
		cols = (int)nbl->norm->Bl.ncols;

		assert(nit->head->child == NULL);

		i = 0;
		for (nch = nit->child; nch != NULL; nch = nch->next)
			if (nch->type == ROFFT_BODY)
				i++;

		if (i < cols || i > cols + 1)
			mandoc_vmsg(MANDOCERR_BL_COL,
			    mdoc->parse, nit->line, nit->pos,
			    "%d columns, %d cells", cols, i);
		break;
	default:
		abort();
	}
}

static void
post_bl_block(POST_ARGS)
{
	struct roff_node *n, *ni, *nc;

	post_prevpar(mdoc);

	/*
	 * These are fairly complicated, so we've broken them into two
	 * functions.  post_bl_block_tag() is called when a -tag is
	 * specified, but no -width (it must be guessed).  The second
	 * when a -width is specified (macro indicators must be
	 * rewritten into real lengths).
	 */

	n = mdoc->last;

	if (n->norm->Bl.type == LIST_tag &&
	    n->norm->Bl.width == NULL) {
		post_bl_block_tag(mdoc);
		assert(n->norm->Bl.width != NULL);
	}

	for (ni = n->body->child; ni != NULL; ni = ni->next) {
		if (ni->body == NULL)
			continue;
		nc = ni->body->last;
		while (nc != NULL) {
			switch (nc->tok) {
			case MDOC_Pp:
			case MDOC_Lp:
			case MDOC_br:
				break;
			default:
				nc = NULL;
				continue;
			}
			if (ni->next == NULL) {
				mandoc_msg(MANDOCERR_PAR_MOVE,
				    mdoc->parse, nc->line, nc->pos,
				    mdoc_macronames[nc->tok]);
				mdoc_node_relink(mdoc, nc);
			} else if (n->norm->Bl.comp == 0 &&
			    n->norm->Bl.type != LIST_column) {
				mandoc_vmsg(MANDOCERR_PAR_SKIP,
				    mdoc->parse, nc->line, nc->pos,
				    "%s before It",
				    mdoc_macronames[nc->tok]);
				roff_node_delete(mdoc, nc);
			} else
				break;
			nc = ni->body->last;
		}
	}
}

/*
 * If the argument of -offset or -width is a macro,
 * replace it with the associated default width.
 */
void
rewrite_macro2len(char **arg)
{
	size_t		  width;
	int		  tok;

	if (*arg == NULL)
		return;
	else if ( ! strcmp(*arg, "Ds"))
		width = 6;
	else if ((tok = mdoc_hash_find(*arg)) == TOKEN_NONE)
		return;
	else
		width = macro2len(tok);

	free(*arg);
	mandoc_asprintf(arg, "%zun", width);
}

static void
post_bl_block_tag(POST_ARGS)
{
	struct roff_node *n, *nn;
	size_t		  sz, ssz;
	int		  i;
	char		  buf[24];

	/*
	 * Calculate the -width for a `Bl -tag' list if it hasn't been
	 * provided.  Uses the first head macro.  NOTE AGAIN: this is
	 * ONLY if the -width argument has NOT been provided.  See
	 * rewrite_macro2len() for converting the -width string.
	 */

	sz = 10;
	n = mdoc->last;

	for (nn = n->body->child; nn != NULL; nn = nn->next) {
		if (nn->tok != MDOC_It)
			continue;

		assert(nn->type == ROFFT_BLOCK);
		nn = nn->head->child;

		if (nn == NULL)
			break;

		if (nn->type == ROFFT_TEXT) {
			sz = strlen(nn->string) + 1;
			break;
		}

		if (0 != (ssz = macro2len(nn->tok)))
			sz = ssz;

		break;
	}

	/* Defaults to ten ens. */

	(void)snprintf(buf, sizeof(buf), "%un", (unsigned int)sz);

	/*
	 * We have to dynamically add this to the macro's argument list.
	 * We're guaranteed that a MDOC_Width doesn't already exist.
	 */

	assert(n->args != NULL);
	i = (int)(n->args->argc)++;

	n->args->argv = mandoc_reallocarray(n->args->argv,
	    n->args->argc, sizeof(struct mdoc_argv));

	n->args->argv[i].arg = MDOC_Width;
	n->args->argv[i].line = n->line;
	n->args->argv[i].pos = n->pos;
	n->args->argv[i].sz = 1;
	n->args->argv[i].value = mandoc_malloc(sizeof(char *));
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->norm->Bl.width = n->args->argv[i].value[0];
}

static void
post_bl_head(POST_ARGS)
{
	struct roff_node *nbl, *nh, *nch, *nnext;
	struct mdoc_argv *argv;
	int		  i, j;

	post_bl_norm(mdoc);

	nh = mdoc->last;
	if (nh->norm->Bl.type != LIST_column) {
		if ((nch = nh->child) == NULL)
			return;
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nch->line, nch->pos, "Bl ... %s", nch->string);
		while (nch != NULL) {
			roff_node_delete(mdoc, nch);
			nch = nh->child;
		}
		return;
	}

	/*
	 * Append old-style lists, where the column width specifiers
	 * trail as macro parameters, to the new-style ("normal-form")
	 * lists where they're argument values following -column.
	 */

	if (nh->child == NULL)
		return;

	nbl = nh->parent;
	for (j = 0; j < (int)nbl->args->argc; j++)
		if (nbl->args->argv[j].arg == MDOC_Column)
			break;

	assert(j < (int)nbl->args->argc);

	/*
	 * Accommodate for new-style groff column syntax.  Shuffle the
	 * child nodes, all of which must be TEXT, as arguments for the
	 * column field.  Then, delete the head children.
	 */

	argv = nbl->args->argv + j;
	i = argv->sz;
	argv->sz += nh->nchild;
	argv->value = mandoc_reallocarray(argv->value,
	    argv->sz, sizeof(char *));

	nh->norm->Bl.ncols = argv->sz;
	nh->norm->Bl.cols = (void *)argv->value;

	for (nch = nh->child; nch != NULL; nch = nnext) {
		argv->value[i++] = nch->string;
		nch->string = NULL;
		nnext = nch->next;
		roff_node_delete(NULL, nch);
	}
	nh->nchild = 0;
	nh->child = NULL;
}

static void
post_bl(POST_ARGS)
{
	struct roff_node	*nparent, *nprev; /* of the Bl block */
	struct roff_node	*nblock, *nbody;  /* of the Bl */
	struct roff_node	*nchild, *nnext;  /* of the Bl body */

	nbody = mdoc->last;
	switch (nbody->type) {
	case ROFFT_BLOCK:
		post_bl_block(mdoc);
		return;
	case ROFFT_HEAD:
		post_bl_head(mdoc);
		return;
	case ROFFT_BODY:
		break;
	default:
		return;
	}
	if (nbody->end != ENDBODY_NOT)
		return;

	nchild = nbody->child;
	if (nchild == NULL) {
		mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
		    nbody->line, nbody->pos, "Bl");
		return;
	}
	while (nchild != NULL) {
		if (nchild->tok == MDOC_It ||
		    (nchild->tok == MDOC_Sm &&
		     nchild->next != NULL &&
		     nchild->next->tok == MDOC_It)) {
			nchild = nchild->next;
			continue;
		}

		mandoc_msg(MANDOCERR_BL_MOVE, mdoc->parse,
		    nchild->line, nchild->pos,
		    mdoc_macronames[nchild->tok]);

		/*
		 * Move the node out of the Bl block.
		 * First, collect all required node pointers.
		 */

		nblock  = nbody->parent;
		nprev   = nblock->prev;
		nparent = nblock->parent;
		nnext   = nchild->next;

		/*
		 * Unlink this child.
		 */

		assert(nchild->prev == NULL);
		if (--nbody->nchild == 0) {
			nbody->child = NULL;
			nbody->last  = NULL;
			assert(nnext == NULL);
		} else {
			nbody->child = nnext;
			nnext->prev = NULL;
		}

		/*
		 * Relink this child.
		 */

		nchild->parent = nparent;
		nchild->prev   = nprev;
		nchild->next   = nblock;

		nblock->prev = nchild;
		nparent->nchild++;
		if (nprev == NULL)
			nparent->child = nchild;
		else
			nprev->next = nchild;

		nchild = nnext;
	}
}

static void
post_bk(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;

	if (n->type == ROFFT_BLOCK && n->body->child == NULL) {
		mandoc_msg(MANDOCERR_BLK_EMPTY,
		    mdoc->parse, n->line, n->pos, "Bk");
		roff_node_delete(mdoc, n);
	}
}

static void
post_sm(POST_ARGS)
{
	struct roff_node	*nch;

	nch = mdoc->last->child;

	if (nch == NULL) {
		mdoc->flags ^= MDOC_SMOFF;
		return;
	}

	assert(nch->type == ROFFT_TEXT);

	if ( ! strcmp(nch->string, "on")) {
		mdoc->flags &= ~MDOC_SMOFF;
		return;
	}
	if ( ! strcmp(nch->string, "off")) {
		mdoc->flags |= MDOC_SMOFF;
		return;
	}

	mandoc_vmsg(MANDOCERR_SM_BAD,
	    mdoc->parse, nch->line, nch->pos,
	    "%s %s", mdoc_macronames[mdoc->last->tok], nch->string);
	mdoc_node_relink(mdoc, nch);
	return;
}

static void
post_root(POST_ARGS)
{
	struct roff_node *n;

	/* Add missing prologue data. */

	if (mdoc->meta.date == NULL)
		mdoc->meta.date = mdoc->quick ?
		    mandoc_strdup("") :
		    mandoc_normdate(mdoc->parse, NULL, 0, 0);

	if (mdoc->meta.title == NULL) {
		mandoc_msg(MANDOCERR_DT_NOTITLE,
		    mdoc->parse, 0, 0, "EOF");
		mdoc->meta.title = mandoc_strdup("UNTITLED");
	}

	if (mdoc->meta.vol == NULL)
		mdoc->meta.vol = mandoc_strdup("LOCAL");

	if (mdoc->meta.os == NULL) {
		mandoc_msg(MANDOCERR_OS_MISSING,
		    mdoc->parse, 0, 0, NULL);
		mdoc->meta.os = mandoc_strdup("");
	}

	/* Check that we begin with a proper `Sh'. */

	n = mdoc->first->child;
	while (n != NULL && n->tok != TOKEN_NONE &&
	    mdoc_macros[n->tok].flags & MDOC_PROLOGUE)
		n = n->next;

	if (n == NULL)
		mandoc_msg(MANDOCERR_DOC_EMPTY, mdoc->parse, 0, 0, NULL);
	else if (n->tok != MDOC_Sh)
		mandoc_msg(MANDOCERR_SEC_BEFORE, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
}

static void
post_st(POST_ARGS)
{
	struct roff_node	 *n, *nch;
	const char		 *p;

	n = mdoc->last;
	nch = n->child;

	assert(nch->type == ROFFT_TEXT);

	if ((p = mdoc_a2st(nch->string)) == NULL) {
		mandoc_vmsg(MANDOCERR_ST_BAD, mdoc->parse,
		    nch->line, nch->pos, "St %s", nch->string);
		roff_node_delete(mdoc, n);
	} else {
		free(nch->string);
		nch->string = mandoc_strdup(p);
	}
}

static void
post_rs(POST_ARGS)
{
	struct roff_node *np, *nch, *next, *prev;
	int		  i, j;

	np = mdoc->last;

	if (np->type != ROFFT_BODY)
		return;

	if (np->child == NULL) {
		mandoc_msg(MANDOCERR_RS_EMPTY, mdoc->parse,
		    np->line, np->pos, "Rs");
		return;
	}

	/*
	 * The full `Rs' block needs special handling to order the
	 * sub-elements according to `rsord'.  Pick through each element
	 * and correctly order it.  This is an insertion sort.
	 */

	next = NULL;
	for (nch = np->child->next; nch != NULL; nch = next) {
		/* Determine order number of this child. */
		for (i = 0; i < RSORD_MAX; i++)
			if (rsord[i] == nch->tok)
				break;

		if (i == RSORD_MAX) {
			mandoc_msg(MANDOCERR_RS_BAD,
			    mdoc->parse, nch->line, nch->pos,
			    mdoc_macronames[nch->tok]);
			i = -1;
		} else if (nch->tok == MDOC__J || nch->tok == MDOC__B)
			np->norm->Rs.quote_T++;

		/*
		 * Remove this child from the chain.  This somewhat
		 * repeats roff_node_unlink(), but since we're
		 * just re-ordering, there's no need for the
		 * full unlink process.
		 */

		if ((next = nch->next) != NULL)
			next->prev = nch->prev;

		if ((prev = nch->prev) != NULL)
			prev->next = nch->next;

		nch->prev = nch->next = NULL;

		/*
		 * Scan back until we reach a node that's
		 * to be ordered before this child.
		 */

		for ( ; prev ; prev = prev->prev) {
			/* Determine order of `prev'. */
			for (j = 0; j < RSORD_MAX; j++)
				if (rsord[j] == prev->tok)
					break;
			if (j == RSORD_MAX)
				j = -1;

			if (j <= i)
				break;
		}

		/*
		 * Set this child back into its correct place
		 * in front of the `prev' node.
		 */

		nch->prev = prev;

		if (prev == NULL) {
			np->child->prev = nch;
			nch->next = np->child;
			np->child = nch;
		} else {
			if (prev->next)
				prev->next->prev = nch;
			nch->next = prev->next;
			prev->next = nch;
		}
	}
}

/*
 * For some arguments of some macros,
 * convert all breakable hyphens into ASCII_HYPH.
 */
static void
post_hyph(POST_ARGS)
{
	struct roff_node	*nch;
	char			*cp;

	for (nch = mdoc->last->child; nch != NULL; nch = nch->next) {
		if (nch->type != ROFFT_TEXT)
			continue;
		cp = nch->string;
		if (*cp == '\0')
			continue;
		while (*(++cp) != '\0')
			if (*cp == '-' &&
			    isalpha((unsigned char)cp[-1]) &&
			    isalpha((unsigned char)cp[1]))
				*cp = ASCII_HYPH;
	}
}

static void
post_ns(POST_ARGS)
{

	if (mdoc->last->flags & MDOC_LINE)
		mandoc_msg(MANDOCERR_NS_SKIP, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, NULL);
}

static void
post_sh(POST_ARGS)
{

	post_ignpar(mdoc);

	switch (mdoc->last->type) {
	case ROFFT_HEAD:
		post_sh_head(mdoc);
		break;
	case ROFFT_BODY:
		switch (mdoc->lastsec)  {
		case SEC_NAME:
			post_sh_name(mdoc);
			break;
		case SEC_SEE_ALSO:
			post_sh_see_also(mdoc);
			break;
		case SEC_AUTHORS:
			post_sh_authors(mdoc);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
}

static void
post_sh_name(POST_ARGS)
{
	struct roff_node *n;
	int hasnm, hasnd;

	hasnm = hasnd = 0;

	for (n = mdoc->last->child; n != NULL; n = n->next) {
		switch (n->tok) {
		case MDOC_Nm:
			hasnm = 1;
			break;
		case MDOC_Nd:
			hasnd = 1;
			if (n->next != NULL)
				mandoc_msg(MANDOCERR_NAMESEC_ND,
				    mdoc->parse, n->line, n->pos, NULL);
			break;
		case TOKEN_NONE:
			if (hasnm)
				break;
			/* FALLTHROUGH */
		default:
			mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
			    n->line, n->pos, mdoc_macronames[n->tok]);
			break;
		}
	}

	if ( ! hasnm)
		mandoc_msg(MANDOCERR_NAMESEC_NONM, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, NULL);
	if ( ! hasnd)
		mandoc_msg(MANDOCERR_NAMESEC_NOND, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, NULL);
}

static void
post_sh_see_also(POST_ARGS)
{
	const struct roff_node	*n;
	const char		*name, *sec;
	const char		*lastname, *lastsec, *lastpunct;
	int			 cmp;

	n = mdoc->last->child;
	lastname = lastsec = lastpunct = NULL;
	while (n != NULL) {
		if (n->tok != MDOC_Xr || n->nchild < 2)
			break;

		/* Process one .Xr node. */

		name = n->child->string;
		sec = n->child->next->string;
		if (lastsec != NULL) {
			if (lastpunct[0] != ',' || lastpunct[1] != '\0')
				mandoc_vmsg(MANDOCERR_XR_PUNCT,
				    mdoc->parse, n->line, n->pos,
				    "%s before %s(%s)", lastpunct,
				    name, sec);
			cmp = strcmp(lastsec, sec);
			if (cmp > 0)
				mandoc_vmsg(MANDOCERR_XR_ORDER,
				    mdoc->parse, n->line, n->pos,
				    "%s(%s) after %s(%s)", name,
				    sec, lastname, lastsec);
			else if (cmp == 0 &&
			    strcasecmp(lastname, name) > 0)
				mandoc_vmsg(MANDOCERR_XR_ORDER,
				    mdoc->parse, n->line, n->pos,
				    "%s after %s", name, lastname);
		}
		lastname = name;
		lastsec = sec;

		/* Process the following node. */

		n = n->next;
		if (n == NULL)
			break;
		if (n->tok == MDOC_Xr) {
			lastpunct = "none";
			continue;
		}
		if (n->type != ROFFT_TEXT)
			break;
		for (name = n->string; *name != '\0'; name++)
			if (isalpha((const unsigned char)*name))
				return;
		lastpunct = n->string;
		if (n->next == NULL)
			mandoc_vmsg(MANDOCERR_XR_PUNCT, mdoc->parse,
			    n->line, n->pos, "%s after %s(%s)",
			    lastpunct, lastname, lastsec);
		n = n->next;
	}
}

static int
child_an(const struct roff_node *n)
{

	for (n = n->child; n != NULL; n = n->next)
		if ((n->tok == MDOC_An && n->nchild) || child_an(n))
			return 1;
	return 0;
}

static void
post_sh_authors(POST_ARGS)
{

	if ( ! child_an(mdoc->last))
		mandoc_msg(MANDOCERR_AN_MISSING, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, NULL);
}

static void
post_sh_head(POST_ARGS)
{
	const char	*goodsec;
	enum roff_sec	 sec;

	/*
	 * Process a new section.  Sections are either "named" or
	 * "custom".  Custom sections are user-defined, while named ones
	 * follow a conventional order and may only appear in certain
	 * manual sections.
	 */

	sec = mdoc->last->sec;

	/* The NAME should be first. */

	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed)
		mandoc_vmsg(MANDOCERR_NAMESEC_FIRST, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s", secnames[sec]);

	/* The SYNOPSIS gets special attention in other areas. */

	if (sec == SEC_SYNOPSIS) {
		roff_setreg(mdoc->roff, "nS", 1, '=');
		mdoc->flags |= MDOC_SYNOPSIS;
	} else {
		roff_setreg(mdoc->roff, "nS", 0, '=');
		mdoc->flags &= ~MDOC_SYNOPSIS;
	}

	/* Mark our last section. */

	mdoc->lastsec = sec;

	/* We don't care about custom sections after this. */

	if (sec == SEC_CUSTOM)
		return;

	/*
	 * Check whether our non-custom section is being repeated or is
	 * out of order.
	 */

	if (sec == mdoc->lastnamed)
		mandoc_vmsg(MANDOCERR_SEC_REP, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s", secnames[sec]);

	if (sec < mdoc->lastnamed)
		mandoc_vmsg(MANDOCERR_SEC_ORDER, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s", secnames[sec]);

	/* Mark the last named section. */

	mdoc->lastnamed = sec;

	/* Check particular section/manual conventions. */

	if (mdoc->meta.msec == NULL)
		return;

	goodsec = NULL;
	switch (sec) {
	case SEC_ERRORS:
		if (*mdoc->meta.msec == '4')
			break;
		goodsec = "2, 3, 4, 9";
		/* FALLTHROUGH */
	case SEC_RETURN_VALUES:
	case SEC_LIBRARY:
		if (*mdoc->meta.msec == '2')
			break;
		if (*mdoc->meta.msec == '3')
			break;
		if (NULL == goodsec)
			goodsec = "2, 3, 9";
		/* FALLTHROUGH */
	case SEC_CONTEXT:
		if (*mdoc->meta.msec == '9')
			break;
		if (NULL == goodsec)
			goodsec = "9";
		mandoc_vmsg(MANDOCERR_SEC_MSEC, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
		    "Sh %s for %s only", secnames[sec], goodsec);
		break;
	default:
		break;
	}
}

static void
post_ignpar(POST_ARGS)
{
	struct roff_node *np;

	switch (mdoc->last->type) {
	case ROFFT_HEAD:
		post_hyph(mdoc);
		return;
	case ROFFT_BODY:
		break;
	default:
		return;
	}

	if ((np = mdoc->last->child) != NULL)
		if (np->tok == MDOC_Pp || np->tok == MDOC_Lp) {
			mandoc_vmsg(MANDOCERR_PAR_SKIP,
			    mdoc->parse, np->line, np->pos,
			    "%s after %s", mdoc_macronames[np->tok],
			    mdoc_macronames[mdoc->last->tok]);
			roff_node_delete(mdoc, np);
		}

	if ((np = mdoc->last->last) != NULL)
		if (np->tok == MDOC_Pp || np->tok == MDOC_Lp) {
			mandoc_vmsg(MANDOCERR_PAR_SKIP, mdoc->parse,
			    np->line, np->pos, "%s at the end of %s",
			    mdoc_macronames[np->tok],
			    mdoc_macronames[mdoc->last->tok]);
			roff_node_delete(mdoc, np);
		}
}

static void
post_prevpar(POST_ARGS)
{
	struct roff_node *n;

	n = mdoc->last;
	if (NULL == n->prev)
		return;
	if (n->type != ROFFT_ELEM && n->type != ROFFT_BLOCK)
		return;

	/*
	 * Don't allow prior `Lp' or `Pp' prior to a paragraph-type
	 * block:  `Lp', `Pp', or non-compact `Bd' or `Bl'.
	 */

	if (n->prev->tok != MDOC_Pp &&
	    n->prev->tok != MDOC_Lp &&
	    n->prev->tok != MDOC_br)
		return;
	if (n->tok == MDOC_Bl && n->norm->Bl.comp)
		return;
	if (n->tok == MDOC_Bd && n->norm->Bd.comp)
		return;
	if (n->tok == MDOC_It && n->parent->norm->Bl.comp)
		return;

	mandoc_vmsg(MANDOCERR_PAR_SKIP, mdoc->parse,
	    n->prev->line, n->prev->pos,
	    "%s before %s", mdoc_macronames[n->prev->tok],
	    mdoc_macronames[n->tok]);
	roff_node_delete(mdoc, n->prev);
}

static void
post_par(POST_ARGS)
{
	struct roff_node *np;

	np = mdoc->last;
	if (np->tok != MDOC_br && np->tok != MDOC_sp)
		post_prevpar(mdoc);

	if (np->tok == MDOC_sp) {
		if (np->nchild > 1)
			mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
			    np->child->next->line, np->child->next->pos,
			    "sp ... %s", np->child->next->string);
	} else if (np->child != NULL)
		mandoc_vmsg(MANDOCERR_ARG_SKIP,
		    mdoc->parse, np->line, np->pos, "%s %s",
		    mdoc_macronames[np->tok], np->child->string);

	if ((np = mdoc->last->prev) == NULL) {
		np = mdoc->last->parent;
		if (np->tok != MDOC_Sh && np->tok != MDOC_Ss)
			return;
	} else if (np->tok != MDOC_Pp && np->tok != MDOC_Lp &&
	    (mdoc->last->tok != MDOC_br ||
	     (np->tok != MDOC_sp && np->tok != MDOC_br)))
		return;

	mandoc_vmsg(MANDOCERR_PAR_SKIP, mdoc->parse,
	    mdoc->last->line, mdoc->last->pos,
	    "%s after %s", mdoc_macronames[mdoc->last->tok],
	    mdoc_macronames[np->tok]);
	roff_node_delete(mdoc, mdoc->last);
}

static void
post_dd(POST_ARGS)
{
	struct roff_node *n;
	char		 *datestr;

	n = mdoc->last;
	if (mdoc->meta.date != NULL) {
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dd");
		free(mdoc->meta.date);
	} else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Dd");
	else if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Os");

	if (n->child == NULL || n->child->string[0] == '\0') {
		mdoc->meta.date = mdoc->quick ? mandoc_strdup("") :
		    mandoc_normdate(mdoc->parse, NULL, n->line, n->pos);
		goto out;
	}

	datestr = NULL;
	deroff(&datestr, n);
	if (mdoc->quick)
		mdoc->meta.date = datestr;
	else {
		mdoc->meta.date = mandoc_normdate(mdoc->parse,
		    datestr, n->line, n->pos);
		free(datestr);
	}
out:
	roff_node_delete(mdoc, n);
}

static void
post_dt(POST_ARGS)
{
	struct roff_node *nn, *n;
	const char	 *cp;
	char		 *p;

	n = mdoc->last;
	if (mdoc->flags & MDOC_PBODY) {
		mandoc_msg(MANDOCERR_DT_LATE, mdoc->parse,
		    n->line, n->pos, "Dt");
		goto out;
	}

	if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dt after Os");

	free(mdoc->meta.title);
	free(mdoc->meta.msec);
	free(mdoc->meta.vol);
	free(mdoc->meta.arch);

	mdoc->meta.title = NULL;
	mdoc->meta.msec = NULL;
	mdoc->meta.vol = NULL;
	mdoc->meta.arch = NULL;

	/* Mandatory first argument: title. */

	nn = n->child;
	if (nn == NULL || *nn->string == '\0') {
		mandoc_msg(MANDOCERR_DT_NOTITLE,
		    mdoc->parse, n->line, n->pos, "Dt");
		mdoc->meta.title = mandoc_strdup("UNTITLED");
	} else {
		mdoc->meta.title = mandoc_strdup(nn->string);

		/* Check that all characters are uppercase. */

		for (p = nn->string; *p != '\0'; p++)
			if (islower((unsigned char)*p)) {
				mandoc_vmsg(MANDOCERR_TITLE_CASE,
				    mdoc->parse, nn->line,
				    nn->pos + (p - nn->string),
				    "Dt %s", nn->string);
				break;
			}
	}

	/* Mandatory second argument: section.*/

	if (nn != NULL)
		nn = nn->next;

	if (nn == NULL) {
		mandoc_vmsg(MANDOCERR_MSEC_MISSING,
		    mdoc->parse, n->line, n->pos,
		    "Dt %s", mdoc->meta.title);
		mdoc->meta.vol = mandoc_strdup("LOCAL");
		goto out;  /* msec and arch remain NULL. */
	}

	mdoc->meta.msec = mandoc_strdup(nn->string);

	/* Infer volume title from section number. */

	cp = mandoc_a2msec(nn->string);
	if (cp == NULL) {
		mandoc_vmsg(MANDOCERR_MSEC_BAD, mdoc->parse,
		    nn->line, nn->pos, "Dt ... %s", nn->string);
		mdoc->meta.vol = mandoc_strdup(nn->string);
	} else
		mdoc->meta.vol = mandoc_strdup(cp);

	/* Optional third argument: architecture. */

	if ((nn = nn->next) == NULL)
		goto out;

	for (p = nn->string; *p != '\0'; p++)
		*p = tolower((unsigned char)*p);
	mdoc->meta.arch = mandoc_strdup(nn->string);

	/* Ignore fourth and later arguments. */

	if ((nn = nn->next) != NULL)
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, mdoc->parse,
		    nn->line, nn->pos, "Dt ... %s", nn->string);

out:
	roff_node_delete(mdoc, n);
}

static void
post_bx(POST_ARGS)
{
	struct roff_node	*n;

	/*
	 * Make `Bx's second argument always start with an uppercase
	 * letter.  Groff checks if it's an "accepted" term, but we just
	 * uppercase blindly.
	 */

	if ((n = mdoc->last->child) != NULL && (n = n->next) != NULL)
		*n->string = (char)toupper((unsigned char)*n->string);
}

static void
post_os(POST_ARGS)
{
#ifndef OSNAME
	struct utsname	  utsname;
	static char	 *defbuf;
#endif
	struct roff_node *n;

	n = mdoc->last;
	if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Os");
	else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Os");

	/*
	 * Set the operating system by way of the `Os' macro.
	 * The order of precedence is:
	 * 1. the argument of the `Os' macro, unless empty
	 * 2. the -Ios=foo command line argument, if provided
	 * 3. -DOSNAME="\"foo\"", if provided during compilation
	 * 4. "sysname release" from uname(3)
	 */

	free(mdoc->meta.os);
	mdoc->meta.os = NULL;
	deroff(&mdoc->meta.os, n);
	if (mdoc->meta.os)
		goto out;

	if (mdoc->defos) {
		mdoc->meta.os = mandoc_strdup(mdoc->defos);
		goto out;
	}

#ifdef OSNAME
	mdoc->meta.os = mandoc_strdup(OSNAME);
#else /*!OSNAME */
	if (defbuf == NULL) {
		if (uname(&utsname) == -1) {
			mandoc_msg(MANDOCERR_OS_UNAME, mdoc->parse,
			    n->line, n->pos, "Os");
			defbuf = mandoc_strdup("UNKNOWN");
		} else
			mandoc_asprintf(&defbuf, "%s %s",
			    utsname.sysname, utsname.release);
	}
	mdoc->meta.os = mandoc_strdup(defbuf);
#endif /*!OSNAME*/

out:
	roff_node_delete(mdoc, n);
}

/*
 * If no argument is provided,
 * fill in the name of the current manual page.
 */
static void
post_ex(POST_ARGS)
{
	struct roff_node *n;

	post_std(mdoc);

	n = mdoc->last;
	if (n->child != NULL)
		return;

	if (mdoc->meta.name == NULL) {
		mandoc_msg(MANDOCERR_EX_NONAME, mdoc->parse,
		    n->line, n->pos, "Ex");
		return;
	}

	mdoc->next = ROFF_NEXT_CHILD;
	roff_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name);
	mdoc->last = n;
}

enum roff_sec
mdoc_a2sec(const char *p)
{
	int		 i;

	for (i = 0; i < (int)SEC__MAX; i++)
		if (secnames[i] && 0 == strcmp(p, secnames[i]))
			return (enum roff_sec)i;

	return SEC_CUSTOM;
}

static size_t
macro2len(int macro)
{

	switch (macro) {
	case MDOC_Ad:
		return 12;
	case MDOC_Ao:
		return 12;
	case MDOC_An:
		return 12;
	case MDOC_Aq:
		return 12;
	case MDOC_Ar:
		return 12;
	case MDOC_Bo:
		return 12;
	case MDOC_Bq:
		return 12;
	case MDOC_Cd:
		return 12;
	case MDOC_Cm:
		return 10;
	case MDOC_Do:
		return 10;
	case MDOC_Dq:
		return 12;
	case MDOC_Dv:
		return 12;
	case MDOC_Eo:
		return 12;
	case MDOC_Em:
		return 10;
	case MDOC_Er:
		return 17;
	case MDOC_Ev:
		return 15;
	case MDOC_Fa:
		return 12;
	case MDOC_Fl:
		return 10;
	case MDOC_Fo:
		return 16;
	case MDOC_Fn:
		return 16;
	case MDOC_Ic:
		return 10;
	case MDOC_Li:
		return 16;
	case MDOC_Ms:
		return 6;
	case MDOC_Nm:
		return 10;
	case MDOC_No:
		return 12;
	case MDOC_Oo:
		return 10;
	case MDOC_Op:
		return 14;
	case MDOC_Pa:
		return 32;
	case MDOC_Pf:
		return 12;
	case MDOC_Po:
		return 12;
	case MDOC_Pq:
		return 12;
	case MDOC_Ql:
		return 16;
	case MDOC_Qo:
		return 12;
	case MDOC_So:
		return 12;
	case MDOC_Sq:
		return 12;
	case MDOC_Sy:
		return 6;
	case MDOC_Sx:
		return 16;
	case MDOC_Tn:
		return 10;
	case MDOC_Va:
		return 12;
	case MDOC_Vt:
		return 12;
	case MDOC_Xr:
		return 10;
	default:
		break;
	};
	return 0;
}
@


1.299
log
@Move all mdoc(7) node validation done before child parsing
to the new separate validation pass, except for a tiny bit
needed by the parser which goes to the new mdoc_state() module;
cleaner, simpler, and surprisingly also shorter by 15 lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.298 2015/10/20 02:01:32 schwarze Exp $ */
d898 10
@


1.298
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.297 2015/10/19 20:04:10 schwarze Exp $ */
a43 1
#define	PRE_ARGS  struct roff_man *mdoc, struct roff_node *n
a51 1
typedef	void	(*v_pre)(PRE_ARGS);
a53 5
struct	valids {
	v_pre	 pre;
	v_post	 post;
};

d63 1
d65 1
d72 1
a73 1
static	void	 post_d1(POST_ARGS);
d75 1
a89 1
static	void	 post_literal(POST_ARGS);
d93 1
d96 1
d106 1
d108 124
a231 132
static	void	 pre_an(PRE_ARGS);
static	void	 pre_bd(PRE_ARGS);
static	void	 pre_bl(PRE_ARGS);
static	void	 pre_display(PRE_ARGS);
static	void	 pre_obsolete(PRE_ARGS);
static	void	 pre_par(PRE_ARGS);
static	void	 pre_std(PRE_ARGS);

static	const struct valids mdoc_valids[MDOC_MAX] = {
	{ NULL, NULL },				/* Ap */
	{ NULL, post_dd },			/* Dd */
	{ NULL, post_dt },			/* Dt */
	{ NULL, post_os },			/* Os */
	{ NULL, post_sh },			/* Sh */
	{ NULL, post_ignpar },			/* Ss */
	{ pre_par, post_par },			/* Pp */
	{ pre_display, post_d1 },		/* D1 */
	{ pre_display, post_literal },		/* Dl */
	{ pre_bd, post_literal },		/* Bd */
	{ NULL, NULL },				/* Ed */
	{ pre_bl, post_bl },			/* Bl */
	{ NULL, NULL },				/* El */
	{ pre_par, post_it },			/* It */
	{ NULL, NULL },				/* Ad */
	{ pre_an, post_an },			/* An */
	{ NULL, post_defaults },		/* Ar */
	{ NULL, NULL },				/* Cd */
	{ NULL, NULL },				/* Cm */
	{ NULL, NULL },				/* Dv */
	{ NULL, NULL },				/* Er */
	{ NULL, NULL },				/* Ev */
	{ pre_std, post_ex },			/* Ex */
	{ NULL, post_fa },			/* Fa */
	{ NULL, NULL },				/* Fd */
	{ NULL, NULL },				/* Fl */
	{ NULL, post_fn },			/* Fn */
	{ NULL, NULL },				/* Ft */
	{ NULL, NULL },				/* Ic */
	{ NULL, NULL },				/* In */
	{ NULL, post_defaults },		/* Li */
	{ NULL, post_nd },			/* Nd */
	{ NULL, post_nm },			/* Nm */
	{ NULL, NULL },				/* Op */
	{ pre_obsolete, NULL },			/* Ot */
	{ NULL, post_defaults },		/* Pa */
	{ pre_std, NULL },			/* Rv */
	{ NULL, post_st },			/* St */
	{ NULL, NULL },				/* Va */
	{ NULL, NULL },				/* Vt */
	{ NULL, NULL },				/* Xr */
	{ NULL, NULL },				/* %A */
	{ NULL, post_hyph },			/* %B */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, NULL },				/* %D */
	{ NULL, NULL },				/* %I */
	{ NULL, NULL },				/* %J */
	{ NULL, post_hyph },			/* %N */
	{ NULL, post_hyph },			/* %O */
	{ NULL, NULL },				/* %P */
	{ NULL, post_hyph },			/* %R */
	{ NULL, post_hyph },			/* %T */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, NULL },				/* %V */
	{ NULL, NULL },				/* Ac */
	{ NULL, NULL },				/* Ao */
	{ NULL, NULL },				/* Aq */
	{ NULL, post_at },			/* At */
	{ NULL, NULL },				/* Bc */
	{ NULL, post_bf },			/* Bf */
	{ NULL, NULL },				/* Bo */
	{ NULL, NULL },				/* Bq */
	{ NULL, NULL },				/* Bsx */
	{ NULL, post_bx },			/* Bx */
	{ pre_obsolete, NULL },			/* Db */
	{ NULL, NULL },				/* Dc */
	{ NULL, NULL },				/* Do */
	{ NULL, NULL },				/* Dq */
	{ NULL, NULL },				/* Ec */
	{ NULL, NULL },				/* Ef */
	{ NULL, NULL },				/* Em */
	{ NULL, NULL },				/* Eo */
	{ NULL, NULL },				/* Fx */
	{ NULL, NULL },				/* Ms */
	{ NULL, NULL },				/* No */
	{ NULL, post_ns },			/* Ns */
	{ NULL, NULL },				/* Nx */
	{ NULL, NULL },				/* Ox */
	{ NULL, NULL },				/* Pc */
	{ NULL, NULL },				/* Pf */
	{ NULL, NULL },				/* Po */
	{ NULL, NULL },				/* Pq */
	{ NULL, NULL },				/* Qc */
	{ NULL, NULL },				/* Ql */
	{ NULL, NULL },				/* Qo */
	{ NULL, NULL },				/* Qq */
	{ NULL, NULL },				/* Re */
	{ NULL, post_rs },			/* Rs */
	{ NULL, NULL },				/* Sc */
	{ NULL, NULL },				/* So */
	{ NULL, NULL },				/* Sq */
	{ NULL, post_sm },			/* Sm */
	{ NULL, post_hyph },			/* Sx */
	{ NULL, NULL },				/* Sy */
	{ NULL, NULL },				/* Tn */
	{ NULL, NULL },				/* Ux */
	{ NULL, NULL },				/* Xc */
	{ NULL, NULL },				/* Xo */
	{ NULL, post_fo },			/* Fo */
	{ NULL, NULL },				/* Fc */
	{ NULL, NULL },				/* Oo */
	{ NULL, NULL },				/* Oc */
	{ NULL, post_bk },			/* Bk */
	{ NULL, NULL },				/* Ek */
	{ NULL, post_eoln },			/* Bt */
	{ NULL, NULL },				/* Hf */
	{ pre_obsolete, NULL },			/* Fr */
	{ NULL, post_eoln },			/* Ud */
	{ NULL, post_lb },			/* Lb */
	{ pre_par, post_par },			/* Lp */
	{ NULL, NULL },				/* Lk */
	{ NULL, post_defaults },		/* Mt */
	{ NULL, NULL },				/* Brq */
	{ NULL, NULL },				/* Bro */
	{ NULL, NULL },				/* Brc */
	{ NULL, NULL },				/* %C */
	{ pre_obsolete, post_es },		/* Es */
	{ pre_obsolete, post_en },		/* En */
	{ NULL, NULL },				/* Dx */
	{ NULL, NULL },				/* %Q */
	{ NULL, post_par },			/* br */
	{ NULL, post_par },			/* sp */
	{ NULL, NULL },				/* %U */
	{ NULL, NULL },				/* Ta */
	{ NULL, NULL },				/* ll */
a280 24
mdoc_valid_pre(struct roff_man *mdoc, struct roff_node *n)
{
	v_pre	 p;

	switch (n->type) {
	case ROFFT_TEXT:
		if (n->sec != SEC_SYNOPSIS || n->parent->tok != MDOC_Fd)
			check_text(mdoc, n->line, n->pos, n->string);
		return;
	case ROFFT_TBL:
	case ROFFT_EQN:
	case ROFFT_ROOT:
		return;
	default:
		break;
	}

	check_args(mdoc, n);
	p = mdoc_valids[n->tok].pre;
	if (*p)
		(*p)(mdoc, n);
}

void
d284 1
a284 1
	v_post p;
d300 3
d310 1
d325 1
a325 1
		p = mdoc_valids[n->tok].post;
d370 1
a370 20
pre_display(PRE_ARGS)
{
	struct roff_node *node;

	if (n->type != ROFFT_BLOCK)
		return;

	for (node = mdoc->last->parent; node; node = node->parent)
		if (node->type == ROFFT_BLOCK)
			if (MDOC_Bd == node->tok)
				break;

	if (node)
		mandoc_vmsg(MANDOCERR_BD_NEST,
		    mdoc->parse, n->line, n->pos,
		    "%s in Bd", mdoc_macronames[n->tok]);
}

static void
pre_bl(PRE_ARGS)
d372 1
d378 2
a379 2
	if (n->type != ROFFT_BLOCK)
		return;
a542 1
	pre_par(mdoc, n);
d546 1
a546 1
pre_bd(PRE_ARGS)
d548 1
d553 1
a553 5
	pre_display(mdoc, n);

	if (n->type != ROFFT_BLOCK)
		return;

a618 1
	pre_par(mdoc, n);
d622 1
a622 1
pre_an(PRE_ARGS)
d624 1
d628 1
d649 1
a649 1
pre_std(PRE_ARGS)
d651 1
d653 3
a655 2
	if (n->args && 1 == n->args->argc)
		if (MDOC_Std == n->args->argv[0].arg)
d663 1
a663 1
pre_obsolete(PRE_ARGS)
d665 1
d667 1
d881 1
a881 18
post_d1(POST_ARGS)
{
	struct roff_node	*n;

	n = mdoc->last;

	if (n->type != ROFFT_BODY)
		return;

	if (n->child == NULL)
		mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
		    n->line, n->pos, "D1");

	post_hyph(mdoc);
}

static void
post_literal(POST_ARGS)
d883 1
a883 1
	struct roff_node	*n;
d886 27
a912 7

	if (n->type != ROFFT_BODY || n->end != ENDBODY_NOT)
		return;

	if (n->child == NULL)
		mandoc_msg(MANDOCERR_BLK_EMPTY, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
d987 2
d1004 1
d1013 1
d1024 2
d1086 2
d1232 2
a1234 1

d1881 1
a1881 1
pre_par(PRE_ARGS)
d1883 1
d1885 2
a1886 1
	if (NULL == mdoc->last)
d1896 3
a1898 3
	if (MDOC_Pp != mdoc->last->tok &&
	    MDOC_Lp != mdoc->last->tok &&
	    MDOC_br != mdoc->last->tok)
d1900 1
a1900 1
	if (MDOC_Bl == n->tok && n->norm->Bl.comp)
d1902 1
a1902 1
	if (MDOC_Bd == n->tok && n->norm->Bd.comp)
d1904 1
a1904 1
	if (MDOC_It == n->tok && n->parent->norm->Bl.comp)
d1908 2
a1909 2
	    mdoc->last->line, mdoc->last->pos,
	    "%s before %s", mdoc_macronames[mdoc->last->tok],
d1911 1
a1911 1
	roff_node_delete(mdoc, mdoc->last);
d1920 2
d2166 2
a2168 1

@


1.297
log
@style cleanup, no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.296 2015/10/12 21:26:02 schwarze Exp $ */
a65 1
static	enum roff_sec	a2sec(const char *);
a112 1
static	void	 pre_dd(PRE_ARGS);
a113 2
static	void	 pre_dt(PRE_ARGS);
static	void	 pre_literal(PRE_ARGS);
a114 1
static	void	 pre_os(PRE_ARGS);
d120 3
a122 3
	{ pre_dd, post_dd },			/* Dd */
	{ pre_dt, post_dt },			/* Dt */
	{ pre_os, post_os },			/* Os */
d127 1
a127 1
	{ pre_literal, post_literal },		/* Dl */
d315 1
a315 1
mdoc_valid_post(struct roff_man *mdoc)
d321 8
a328 3
	if (n->flags & MDOC_VALID)
		return;
	n->flags |= MDOC_VALID | MDOC_ENDED;
d330 2
d358 2
d601 1
a601 1
	pre_literal(mdoc, n);
a720 42
pre_dt(PRE_ARGS)
{

	if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dt after Os");
}

static void
pre_os(PRE_ARGS)
{

	if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Os");
	else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Os");
}

static void
pre_dd(PRE_ARGS)
{

	if (mdoc->meta.date != NULL)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
		    n->line, n->pos, "Dd");
	else if (mdoc->flags & MDOC_PBODY)
		mandoc_msg(MANDOCERR_PROLOG_LATE, mdoc->parse,
		    n->line, n->pos, "Dd");
	else if (mdoc->meta.title != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Dt");
	else if (mdoc->meta.os != NULL)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dd after Os");
}

static void
d951 1
a951 1
	if (n->type != ROFFT_BODY)
a956 7

	if (n->tok == MDOC_Bd &&
	    n->norm->Bd.type != DISP_literal &&
	    n->norm->Bd.type != DISP_unfilled)
		return;

	mdoc->flags &= ~MDOC_LITERAL;
a973 1
	mdoc->next = ROFF_NEXT_CHILD;
d977 1
d983 1
d1343 2
a1788 1
	struct roff_node *n;
a1789 1
	char		*secname;
d1799 1
a1799 3
	secname = NULL;
	deroff(&secname, mdoc->last);
	sec = NULL == secname ? SEC_CUSTOM : a2sec(secname);
d1806 1
a1806 1
		    "Sh %s", secname);
d1810 1
a1810 1
	if (SEC_SYNOPSIS == sec) {
a1821 14
	/*
	 * Set the section attribute for the current HEAD, for its
	 * parent BLOCK, and for the HEAD children; the latter can
	 * only be TEXT nodes, so no recursion is needed.
	 * For other blocks and elements, including .Sh BODY, this is
	 * done when allocating the node data structures, but for .Sh
	 * BLOCK and HEAD, the section is still unknown at that time.
	 */

	mdoc->last->parent->sec = sec;
	mdoc->last->sec = sec;
	for (n = mdoc->last->child; n != NULL; n = n->next)
		n->sec = sec;

d1824 1
a1824 2
	if (SEC_CUSTOM == sec) {
		free(secname);
a1825 1
	}
d1835 1
a1835 1
		    "Sh %s", secname);
d1840 1
a1840 1
		    "Sh %s", secname);
d1848 1
a1848 2
	if (mdoc->meta.msec == NULL) {
		free(secname);
a1849 1
	}
d1874 1
a1874 1
		    "Sh %s for %s only", secname, goodsec);
a1878 1
	free(secname);
a1980 29
pre_literal(PRE_ARGS)
{

	pre_display(mdoc, n);

	if (n->type != ROFFT_BODY)
		return;

	/*
	 * The `Dl' (note "el" not "one") and `Bd -literal' and `Bd
	 * -unfilled' macros set MDOC_LITERAL on entrance to the body.
	 */

	switch (n->tok) {
	case MDOC_Dl:
		mdoc->flags |= MDOC_LITERAL;
		break;
	case MDOC_Bd:
		if (DISP_literal == n->norm->Bd.type)
			mdoc->flags |= MDOC_LITERAL;
		if (DISP_unfilled == n->norm->Bd.type)
			mdoc->flags |= MDOC_LITERAL;
		break;
	default:
		abort();
	}
}

static void
d1986 4
a1989 1
	if (mdoc->meta.date)
d1991 9
a2000 1
	n = mdoc->last;
d2028 12
d2142 6
d2213 2
a2214 2
static enum roff_sec
a2sec(const char *p)
@


1.296
log
@Delete an assignment that is unconditionally overwritten two lines later;
found by Svyatoslav Mishyn <juef at openmailbox dot org>
with the clang static analyzer.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.295 2015/10/12 00:08:16 schwarze Exp $ */
a761 1
	enum mdocargt	  arg;
d773 1
a773 1
	assert(MDOC_Bf == np->parent->tok);
d778 2
a779 2
	if (NULL == np->parent->args) {
		if (NULL == nch) {
d786 1
a786 1
	if (NULL != nch)
d792 3
a794 3
	if (np->parent->args) {
		arg = np->parent->args->argv[0].arg;
		if (MDOC_Emphasis == arg)
d796 2
a797 1
		else if (MDOC_Literal == arg)
d799 2
a800 1
		else if (MDOC_Symbolic == arg)
d802 2
a803 1
		else
d805 1
d811 1
a811 1
	if (0 == strcmp(np->child->string, "Em"))
d813 1
a813 1
	else if (0 == strcmp(np->child->string, "Li"))
d815 1
a815 1
	else if (0 == strcmp(np->child->string, "Sy"))
d849 1
a849 1
	if (n->child)
d938 1
a938 1
	if (NULL != mdoc->meta.name)
d943 1
a943 1
	if (NULL == mdoc->meta.name)
d1015 1
a1015 1
	if (mdoc->last->child)
d1059 1
a1059 1
	if (NULL == (std_att = mdoc_a2att(n->string))) {
d1148 2
a1149 1
		for (i = 0, nch = nit->child; nch; nch = nch->next)
d1178 2
a1179 2
	if (LIST_tag == n->norm->Bl.type &&
	    NULL == n->norm->Bl.width) {
d1181 1
a1181 1
		assert(n->norm->Bl.width);
d1184 2
a1185 2
	for (ni = n->body->child; ni; ni = ni->next) {
		if (NULL == ni->body)
d1188 1
a1188 1
		while (NULL != nc) {
d1198 1
a1198 1
			if (NULL == ni->next) {
d1203 2
a1204 2
			} else if (0 == n->norm->Bl.comp &&
			    LIST_column != n->norm->Bl.type) {
d1258 2
a1259 2
	for (nn = n->body->child; nn; nn = nn->next) {
		if (MDOC_It != nn->tok)
d1288 1
a1288 1
	assert(n->args);
d1421 2
a1422 2
		assert(NULL == nchild->prev);
		if (0 == --nbody->nchild) {
d1425 1
a1425 1
			assert(NULL == nnext);
d1441 1
a1441 1
		if (NULL == nprev)
d1465 1
a1465 1
post_sm(struct roff_man *mdoc)
d1546 1
a1546 1
	if (NULL == (p = mdoc_a2st(nch->string))) {
d1674 1
a1674 1
	if (MDOC_LINE & mdoc->last->flags)
d1879 1
a1879 1
	for (n = mdoc->last->child; n; n = n->next)
d1961 2
a1962 2
	if (NULL != (np = mdoc->last->child))
		if (MDOC_Pp == np->tok || MDOC_Lp == np->tok) {
d1970 2
a1971 2
	if (NULL != (np = mdoc->last->last))
		if (MDOC_Pp == np->tok || MDOC_Lp == np->tok) {
d2029 1
a2029 1
	if (NULL == (np = mdoc->last->prev)) {
d2031 1
a2031 1
		if (MDOC_Sh != np->tok && MDOC_Ss != np->tok)
d2033 3
a2035 3
	} else if (MDOC_Pp != np->tok && MDOC_Lp != np->tok &&
	    (MDOC_br != mdoc->last->tok ||
	     (MDOC_sp != np->tok && MDOC_br != np->tok)))
d2084 1
a2084 1
	if (NULL == n->child || '\0' == n->child->string[0]) {
d2199 1
a2199 2
	n = mdoc->last->child;
	if (n && NULL != (n = n->next))
d2237 2
a2238 2
	if (NULL == defbuf) {
		if (-1 == uname(&utsname)) {
d2264 1
a2264 1
	if (n->child)
@


1.295
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.294 2015/10/06 18:32:19 schwarze Exp $ */
a1839 1
	sec = SEC_CUSTOM;
@


1.294
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.293 2015/09/26 00:54:04 schwarze Exp $ */
d304 1
a304 1
		/* FALLTHROUGH */
a305 1
		/* FALLTHROUGH */
a306 1
		/* FALLTHROUGH */
a331 1
		/* FALLTHROUGH */
a332 1
		/* FALLTHROUGH */
a564 1
		/* FALLTHROUGH */
a565 1
		/* FALLTHROUGH */
a566 1
		/* FALLTHROUGH */
a567 1
		/* FALLTHROUGH */
a574 1
		/* FALLTHROUGH */
a575 1
		/* FALLTHROUGH */
a1023 1
		/* FALLTHROUGH */
a1113 1
		/* FALLTHROUGH */
a1114 1
		/* FALLTHROUGH */
a1115 1
		/* FALLTHROUGH */
a1116 1
		/* FALLTHROUGH */
a1124 1
		/* FALLTHROUGH */
a1125 1
		/* FALLTHROUGH */
a1126 1
		/* FALLTHROUGH */
a1186 1
				/* FALLTHROUGH */
a1187 1
				/* FALLTHROUGH */
a1919 1
		/* FALLTHROUGH */
@


1.293
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.292 2015/09/14 15:36:14 schwarze Exp $ */
d1831 2
a1832 2
			return(1);
	return(0);
d2304 1
a2304 1
			return((enum roff_sec)i);
d2306 1
a2306 1
	return(SEC_CUSTOM);
d2315 1
a2315 1
		return(12);
d2317 1
a2317 1
		return(12);
d2319 1
a2319 1
		return(12);
d2321 1
a2321 1
		return(12);
d2323 1
a2323 1
		return(12);
d2325 1
a2325 1
		return(12);
d2327 1
a2327 1
		return(12);
d2329 1
a2329 1
		return(12);
d2331 1
a2331 1
		return(10);
d2333 1
a2333 1
		return(10);
d2335 1
a2335 1
		return(12);
d2337 1
a2337 1
		return(12);
d2339 1
a2339 1
		return(12);
d2341 1
a2341 1
		return(10);
d2343 1
a2343 1
		return(17);
d2345 1
a2345 1
		return(15);
d2347 1
a2347 1
		return(12);
d2349 1
a2349 1
		return(10);
d2351 1
a2351 1
		return(16);
d2353 1
a2353 1
		return(16);
d2355 1
a2355 1
		return(10);
d2357 1
a2357 1
		return(16);
d2359 1
a2359 1
		return(6);
d2361 1
a2361 1
		return(10);
d2363 1
a2363 1
		return(12);
d2365 1
a2365 1
		return(10);
d2367 1
a2367 1
		return(14);
d2369 1
a2369 1
		return(32);
d2371 1
a2371 1
		return(12);
d2373 1
a2373 1
		return(12);
d2375 1
a2375 1
		return(12);
d2377 1
a2377 1
		return(16);
d2379 1
a2379 1
		return(12);
d2381 1
a2381 1
		return(12);
d2383 1
a2383 1
		return(12);
d2385 1
a2385 1
		return(6);
d2387 1
a2387 1
		return(16);
d2389 1
a2389 1
		return(10);
d2391 1
a2391 1
		return(12);
d2393 1
a2393 1
		return(12);
d2395 1
a2395 1
		return(10);
d2399 1
a2399 1
	return(0);
@


1.292
log
@Remove the warning about children of .Vt blocks because actually,
.Vt type global_variable No = Dv defined_constant ;
is the best way to specify in the SYNOPSIS how a global variable
is initialized in the rare case where that matters.
Issue noticed by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.291 2015/04/23 16:17:44 schwarze Exp $ */
a659 1
			/* NOTREACHED */
a1039 1
		/* NOTREACHED */
a2088 1
		/* NOTREACHED */
@


1.291
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.290 2015/04/20 09:48:53 schwarze Exp $ */
a109 1
static	void	 post_vt(POST_ARGS);
d163 1
a163 1
	{ NULL, post_vt },			/* Vt */
a934 22
post_vt(POST_ARGS)
{
	const struct roff_node *n;

	/*
	 * The Vt macro comes in both ELEM and BLOCK form, both of which
	 * have different syntaxes (yet more context-sensitive
	 * behaviour).  ELEM types must have a child, which is already
	 * guaranteed by the in_line parsing routine; BLOCK types,
	 * specifically the BODY, should only have TEXT children.
	 */

	if (mdoc->last->type != ROFFT_BODY)
		return;

	for (n = mdoc->last->child; n; n = n->next)
		if (n->type != ROFFT_TEXT)
			mandoc_msg(MANDOCERR_VT_CHILD, mdoc->parse,
			    n->line, n->pos, mdoc_macronames[n->tok]);
}

static void
@


1.290
log
@Avoid out-of-bounds read access before the beginning of the
mdoc_macros[] array.  This sometimes prevented proper warnings
about text nodes preceding the first section header.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.289 2015/04/19 14:25:41 schwarze Exp $ */
d972 1
a972 1
	mdoc_deroff(&mdoc->meta.name, n);
d1886 1
a1886 1
	mdoc_deroff(&secname, mdoc->last);
d2135 1
a2135 1
	mdoc_deroff(&datestr, n);
d2270 1
a2270 1
	mdoc_deroff(&mdoc->meta.os, n);
@


1.289
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.288 2015/04/19 14:00:20 schwarze Exp $ */
d1565 2
a1566 1
	while (n != NULL && mdoc_macros[n->tok].flags & MDOC_PROLOGUE)
@


1.288
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.287 2015/04/19 13:50:26 schwarze Exp $ */
d1054 2
a1055 2
		mdoc_word_alloc(mdoc, nn->line, nn->pos, "file");
		mdoc_word_alloc(mdoc, nn->line, nn->pos, "...");
d1060 1
a1060 1
		mdoc_word_alloc(mdoc, nn->line, nn->pos, "~");
d1079 1
a1079 1
		mdoc_word_alloc(mdoc, n->line, n->pos, "AT&T UNIX");
d2318 1
a2318 1
	mdoc_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name);
@


1.287
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.286 2015/04/18 16:06:41 schwarze Exp $ */
d1272 1
a1272 1
	else if ((tok = mdoc_hash_find(*arg)) == MDOC_MAX)
d1768 1
a1768 1
		case MDOC_MAX:
@


1.286
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.285 2015/04/02 22:48:17 schwarze Exp $ */
d39 1
d908 1
a908 1
			mdoc_node_delete(mdoc, n->last);
d1250 1
a1250 1
				mdoc_node_delete(mdoc, nc);
d1361 1
a1361 1
			mdoc_node_delete(mdoc, nch);
d1402 1
a1402 1
		mdoc_node_delete(NULL, nch);
d1501 1
a1501 1
		mdoc_node_delete(mdoc, n);
d1589 1
a1589 1
		mdoc_node_delete(mdoc, n);
d1636 1
a1636 1
		 * repeats mdoc_node_unlink(), but since we're
d2009 1
a2009 1
			mdoc_node_delete(mdoc, np);
d2018 1
a2018 1
			mdoc_node_delete(mdoc, np);
d2051 1
a2051 1
	mdoc_node_delete(mdoc, mdoc->last);
d2084 1
a2084 1
	mdoc_node_delete(mdoc, mdoc->last);
d2143 1
a2143 1
	mdoc_node_delete(mdoc, n);
d2228 1
a2228 1
	mdoc_node_delete(mdoc, n);
d2294 1
a2294 1
	mdoc_node_delete(mdoc, n);
@


1.285
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.284 2015/04/02 21:36:50 schwarze Exp $ */
d43 2
a44 2
#define	PRE_ARGS  struct mdoc *mdoc, struct roff_node *n
#define	POST_ARGS struct mdoc *mdoc
d60 2
a61 2
static	void	 check_text(struct mdoc *, int, int, char *);
static	void	 check_argv(struct mdoc *,
d63 1
a63 1
static	void	 check_args(struct mdoc *, struct roff_node *);
d296 1
a296 1
mdoc_valid_pre(struct mdoc *mdoc, struct roff_node *n)
d322 1
a322 1
mdoc_valid_post(struct mdoc *mdoc)
d365 1
a365 1
check_args(struct mdoc *mdoc, struct roff_node *n)
d378 1
a378 1
check_argv(struct mdoc *mdoc, struct roff_node *n, struct mdoc_argv *v)
d387 1
a387 1
check_text(struct mdoc *mdoc, int ln, int pos, char *p)
d1049 1
a1049 1
	mdoc->next = MDOC_NEXT_CHILD;
d1077 1
a1077 1
		mdoc->next = MDOC_NEXT_CHILD;
d1505 1
a1505 1
post_sm(struct mdoc *mdoc)
d2316 1
a2316 1
	mdoc->next = MDOC_NEXT_CHILD;
@


1.284
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.283 2015/02/23 13:55:55 schwarze Exp $ */
d43 1
a43 1
#define	PRE_ARGS  struct mdoc *mdoc, struct mdoc_node *n
d62 5
a66 5
			struct mdoc_node *, struct mdoc_argv *);
static	void	 check_args(struct mdoc *, struct mdoc_node *);
static	int	 child_an(const struct mdoc_node *);
static	enum mdoc_sec	a2sec(const char *);
static	size_t		macro2len(enum mdoct);
d251 1
a251 1
static	const enum mdoct rsord[RSORD_MAX] = {
d296 1
a296 1
mdoc_valid_pre(struct mdoc *mdoc, struct mdoc_node *n)
d324 1
a324 1
	struct mdoc_node *n;
d365 1
a365 1
check_args(struct mdoc *mdoc, struct mdoc_node *n)
d378 1
a378 1
check_argv(struct mdoc *mdoc, struct mdoc_node *n, struct mdoc_argv *v)
d402 1
a402 1
	struct mdoc_node *node;
d772 1
a772 1
	struct mdoc_node *np, *nch;
d834 1
a834 1
	struct mdoc_node	*n;
d854 1
a854 1
	const struct mdoc_node *n;
d867 1
a867 1
	const struct mdoc_node	*n;
d890 1
a890 1
	const struct mdoc_node	*n;
d916 1
a916 1
	const struct mdoc_node *n;
d937 1
a937 1
	const struct mdoc_node *n;
d959 1
a959 1
	struct mdoc_node	*n;
d981 1
a981 1
	struct mdoc_node	*n;
d998 1
a998 1
	struct mdoc_node	*n;
d1015 1
a1015 1
	struct mdoc_node	*n;
d1037 1
a1037 1
	struct mdoc_node *nn;
d1071 1
a1071 1
	struct mdoc_node	*n;
d1105 1
a1105 1
	struct mdoc_node *np, *nch;
d1136 1
a1138 1
	struct mdoc_node *nbl, *nit, *nch;
d1204 1
a1204 1
	struct mdoc_node *n, *ni, *nc;
d1265 1
a1265 1
	enum mdoct	  tok;
d1283 1
a1283 1
	struct mdoc_node *n, *nn;
d1348 1
a1348 1
	struct mdoc_node *nbl, *nh, *nch, *nnext;
d1410 3
a1412 3
	struct mdoc_node	*nparent, *nprev; /* of the Bl block */
	struct mdoc_node	*nblock, *nbody;  /* of the Bl */
	struct mdoc_node	*nchild, *nnext;  /* of the Bl body */
d1493 1
a1493 1
	struct mdoc_node	*n;
d1507 1
a1507 1
	struct mdoc_node	*nch;
d1537 1
a1537 1
	struct mdoc_node *n;
d1577 1
a1577 1
	struct mdoc_node	 *n, *nch;
d1598 1
a1598 1
	struct mdoc_node *np, *nch, *next, *prev;
d1692 1
a1692 1
	struct mdoc_node	*nch;
d1751 1
a1751 1
	struct mdoc_node *n;
d1789 1
a1789 1
	const struct mdoc_node	*n;
d1849 1
a1849 1
child_an(const struct mdoc_node *n)
d1870 1
a1870 1
	struct mdoc_node *n;
d1873 1
a1873 1
	enum mdoc_sec	 sec;
d1990 1
a1990 1
	struct mdoc_node *np;
d2056 1
a2056 1
	struct mdoc_node *np;
d2119 1
a2119 1
	struct mdoc_node *n;
d2148 1
a2148 1
	struct mdoc_node *nn, *n;
d2233 1
a2233 1
	struct mdoc_node	*n;
d2253 1
a2253 1
	struct mdoc_node *n;
d2303 1
a2303 1
	struct mdoc_node *n;
d2321 1
a2321 1
static enum mdoc_sec
d2328 1
a2328 1
			return((enum mdoc_sec)i);
d2334 1
a2334 1
macro2len(enum mdoct macro)
@


1.283
log
@oops, in NAME, don't nag about the comma after .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.282 2015/02/23 13:31:04 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d34 3
d38 1
a38 2
#include "mandoc.h"
#include "mandoc_aux.h"
a39 1
#include "libmandoc.h"
d301 1
a301 1
	case MDOC_TEXT:
d305 1
a305 1
	case MDOC_TBL:
d307 1
a307 1
	case MDOC_EQN:
d309 1
a309 1
	case MDOC_ROOT:
d333 1
a333 1
	case MDOC_TEXT:
d335 1
a335 1
	case MDOC_EQN:
d337 1
a337 1
	case MDOC_TBL:
d339 1
a339 1
	case MDOC_ROOT:
d404 1
a404 1
	if (MDOC_BLOCK != n->type)
d408 1
a408 1
		if (MDOC_BLOCK == node->type)
d426 1
a426 1
	if (n->type != MDOC_BLOCK)
d609 1
a609 1
	if (n->type != MDOC_BLOCK)
d722 1
a722 1
	if (MDOC_ELEM == n->type || MDOC_BLOCK == n->type)
d781 1
a781 1
	if (MDOC_HEAD != np->type)
d784 1
a784 1
	assert(MDOC_BLOCK == np->parent->type);
d839 1
a839 1
	assert(MDOC_TEXT == n->type);
d894 1
a894 1
	if (n->type != MDOC_HEAD)
d947 1
a947 1
	if (MDOC_BODY != mdoc->last->type)
d951 1
a951 1
		if (MDOC_TEXT != n->type)
d985 1
a985 1
	if (n->type != MDOC_BODY)
d1002 1
a1002 1
	if (n->type != MDOC_BODY)
d1019 1
a1019 1
	if (n->type != MDOC_BODY)
d1090 1
a1090 1
	assert(MDOC_TEXT == n->type);
d1122 1
a1122 1
	if (MDOC_BLOCK == mdoc->last->type)
d1141 1
a1141 1
	if (nit->type != MDOC_BLOCK)
d1188 1
a1188 1
			if (nch->type == MDOC_BODY)
d1302 1
a1302 1
		assert(MDOC_BLOCK == nn->type);
d1308 1
a1308 1
		if (MDOC_TEXT == nn->type) {
d1416 1
a1416 1
	case MDOC_BLOCK:
d1419 1
a1419 1
	case MDOC_HEAD:
d1422 1
a1422 1
	case MDOC_BODY:
d1497 1
a1497 1
	if (n->type == MDOC_BLOCK && n->body->child == NULL) {
d1516 1
a1516 1
	assert(nch->type == MDOC_TEXT);
d1583 1
a1583 1
	assert(MDOC_TEXT == nch->type);
d1603 1
a1603 1
	if (np->type != MDOC_BODY)
d1696 1
a1696 1
		if (nch->type != MDOC_TEXT)
d1725 1
a1725 1
	case MDOC_HEAD:
d1728 1
a1728 1
	case MDOC_BODY:
d1834 1
a1834 1
		if (n->type != MDOC_TEXT)
d1993 1
a1993 1
	case MDOC_HEAD:
d1996 1
a1996 1
	case MDOC_BODY:
d2027 1
a2027 1
	if (MDOC_ELEM != n->type && MDOC_BLOCK != n->type)
d2092 1
a2092 1
	if (MDOC_BODY != n->type)
@


1.282
log
@improve NAME section diagnostics;
confusing messages reported by Jan Stary <hans at stare dot cz>
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.281 2015/02/17 20:37:17 schwarze Exp $ */
d1766 4
@


1.281
log
@Render \(lq and \(rq as '"' in -Tascii mode but leave the rendering
of .Do/.Dc, .Dq, .Lb, and .St untouched.
Reduces groff-mandoc differences in OpenBSD base by about 7%.
Reminded of the issue by naddy@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.280 2015/02/16 19:02:48 schwarze Exp $ */
d1751 1
d1753 1
a1753 5
	/*
	 * Warn if the NAME section doesn't contain the `Nm' and `Nd'
	 * macros (can have multiple `Nm' and one `Nd').  Note that the
	 * children of the BODY declaration can also be "text".
	 */
d1755 16
a1770 4
	if (NULL == (n = mdoc->last->child)) {
		mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, "empty");
		return;
d1773 6
a1778 15
	for ( ; n && n->next; n = n->next) {
		if (MDOC_ELEM == n->type && MDOC_Nm == n->tok)
			continue;
		if (MDOC_TEXT == n->type)
			continue;
		mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
	}

	assert(n);
	if (MDOC_BLOCK == n->type && MDOC_Nd == n->tok)
		return;

	mandoc_msg(MANDOCERR_NAMESEC_BAD, mdoc->parse,
	    n->line, n->pos, mdoc_macronames[n->tok]);
@


1.280
log
@clean up post_dt() validation function;
improved diagnostics, minus six lines of code
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.279 2015/02/14 13:23:57 schwarze Exp $ */
d842 1
a842 1
		    "library \\(lq%s\\(rq", n->string);
@


1.279
log
@shut up about tabs in SYNOPSIS .Fd lines, there is no good way to avoid them
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.278 2015/02/12 12:24:33 schwarze Exp $ */
d2159 1
a2159 1
	/* First check that all characters are uppercase. */
d2161 2
a2162 14
	if (NULL != (nn = n->child))
		for (p = nn->string; *p; p++) {
			if (toupper((unsigned char)*p) == *p)
				continue;
			mandoc_vmsg(MANDOCERR_TITLE_CASE,
			    mdoc->parse, nn->line,
			    nn->pos + (p - nn->string),
			    "Dt %s", nn->string);
			break;
		}

	/* No argument: msec and arch remain NULL. */

	if (NULL == (nn = n->child)) {
d2166 13
a2178 2
		mdoc->meta.vol = mandoc_strdup("LOCAL");
		goto out;
d2181 1
a2181 1
	/* One argument: msec and arch remain NULL. */
d2183 2
a2184 2
	mdoc->meta.title = mandoc_strdup(
	    '\0' == nn->string[0] ? "UNTITLED" : nn->string);
d2186 1
a2186 1
	if (NULL == (nn = nn->next)) {
d2191 1
a2191 1
		goto out;
d2194 3
a2196 6
	/* Handles: `.Dt TITLE SEC'
	 * title = TITLE,
	 * volume = SEC is msec ? format(msec) : SEC,
	 * msec = SEC is msec ? atoi(msec) : 0,
	 * arch = NULL
	 */
d2199 1
a2199 4
	if (cp) {
		mdoc->meta.vol = mandoc_strdup(cp);
		mdoc->meta.msec = mandoc_strdup(nn->string);
	} else {
d2203 11
a2213 2
		mdoc->meta.msec = mandoc_strdup(nn->string);
	}
d2215 1
a2215 1
	/* Handle an optional architecture */
d2217 3
a2219 5
	if ((nn = nn->next) != NULL) {
		for (p = nn->string; *p; p++)
			*p = tolower((unsigned char)*p);
		mdoc->meta.arch = mandoc_strdup(nn->string);
	}
a2220 2
	/* Ignore any subsequent parameters... */
	/* FIXME: warn about subsequent parameters. */
@


1.278
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.277 2015/02/10 08:05:30 schwarze Exp $ */
d301 2
a302 1
		check_text(mdoc, n->line, n->pos, n->string);
@


1.277
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.276 2015/02/06 16:06:25 schwarze Exp $ */
d328 1
a328 1
	n->flags |= MDOC_VALID;
a418 1
	struct mdoc_node *np;
d424 1
a424 10
	if (MDOC_BLOCK != n->type) {
		if (ENDBODY_NOT != n->end) {
			assert(n->pending);
			np = n->pending->parent;
		} else
			np = n->parent;

		assert(np);
		assert(MDOC_BLOCK == np->type);
		assert(MDOC_Bl == np->tok);
a425 1
	}
a600 1
	struct mdoc_node *np;
d607 1
a607 10
	if (MDOC_BLOCK != n->type) {
		if (ENDBODY_NOT != n->end) {
			assert(n->pending);
			np = n->pending->parent;
		} else
			np = n->parent;

		assert(np);
		assert(MDOC_BLOCK == np->type);
		assert(MDOC_Bd == np->tok);
a608 1
	}
d778 2
a779 12
	if (MDOC_HEAD != mdoc->last->type) {
		if (ENDBODY_NOT != mdoc->last->end) {
			assert(mdoc->last->pending);
			np = mdoc->last->pending->parent->head;
		} else if (MDOC_BLOCK != mdoc->last->type) {
			np = mdoc->last->parent->head;
		} else
			np = mdoc->last->head;

		assert(np);
		assert(MDOC_HEAD == np->type);
		assert(MDOC_Bf == np->tok);
a780 1
	}
a781 1
	np = mdoc->last;
@


1.276
log
@replace the last legacy generic message type, "argument count wrong",
by more specific messages, improving diagnostics for .cc .tr .Bl -column
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.275 2015/02/06 07:13:14 schwarze Exp $ */
d1818 1
a1818 1
	const char 		*name, *sec;
@


1.275
log
@Delete the legacy generic warning type MANDOCERR_ARGCWARN,
replacing the last instances by more specific warnings.
Improved functionality, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.274 2015/02/06 03:38:45 schwarze Exp $ */
d1224 1
a1224 1
			mandoc_vmsg(MANDOCERR_ARGCOUNT,
d1226 1
a1226 1
			    "columns == %d (have %d)", cols, i);
@


1.274
log
@better handle .Fo and .Fd without argument
better handle .Fo with more than one argument
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.273 2015/02/06 02:04:54 schwarze Exp $ */
a58 2
static	void	 check_count(struct mdoc *, enum mdoc_type,
			enum check_ineq, int);
a67 3
static	void	 ewarn_eq1(POST_ARGS);
static	void	 ewarn_ge1(POST_ARGS);

a89 1
static	void	 post_hyphtext(POST_ARGS);
d164 11
a174 11
	{ NULL, ewarn_ge1 },			/* %A */
	{ NULL, post_hyphtext },		/* %B */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, ewarn_ge1 },			/* %D */
	{ NULL, ewarn_ge1 },			/* %I */
	{ NULL, ewarn_ge1 },			/* %J */
	{ NULL, post_hyphtext },		/* %N */
	{ NULL, post_hyphtext },		/* %O */
	{ NULL, ewarn_ge1 },			/* %P */
	{ NULL, post_hyphtext },		/* %R */
	{ NULL, post_hyphtext },		/* %T */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, ewarn_ge1 },			/* %V */
d236 1
a236 1
	{ NULL, ewarn_ge1 },			/* %C */
d240 1
a240 1
	{ NULL, ewarn_ge1 },			/* %Q */
d243 1
a243 1
	{ NULL, ewarn_eq1 },			/* %U */
a362 47
check_count(struct mdoc *mdoc, enum mdoc_type type,
	enum check_ineq ineq, int val)
{
	const char	*p;

	if (mdoc->last->type != type)
		return;

	switch (ineq) {
	case CHECK_LT:
		p = "less than ";
		if (mdoc->last->nchild < val)
			return;
		break;
	case CHECK_GT:
		p = "more than ";
		if (mdoc->last->nchild > val)
			return;
		break;
	case CHECK_EQ:
		p = "";
		if (val == mdoc->last->nchild)
			return;
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	mandoc_vmsg(MANDOCERR_ARGCWARN, mdoc->parse, mdoc->last->line,
	    mdoc->last->pos, "want %s%d children (have %d)",
	    p, val, mdoc->last->nchild);
}

static void
ewarn_eq1(POST_ARGS)
{
	check_count(mdoc, MDOC_ELEM, CHECK_EQ, 1);
}

static void
ewarn_ge1(POST_ARGS)
{
	check_count(mdoc, MDOC_ELEM, CHECK_GT, 0);
}

static void
a869 1
	check_count(mdoc, MDOC_ELEM, CHECK_EQ, 1);
d1038 1
a1038 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
d1055 1
a1055 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
d1462 1
a1462 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
d1530 1
a1530 1
		mandoc_msg(MANDOCERR_MACRO_EMPTY,
a1741 8
post_hyphtext(POST_ARGS)
{

	ewarn_ge1(mdoc);
	post_hyph(mdoc);
}

static void
@


1.273
log
@better handle empty .Bd .Bl .D1 .Dl blocks
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.272 2015/02/06 01:07:22 schwarze Exp $ */
a69 1
static	void	 bwarn_ge1(POST_ARGS);
d153 1
a153 1
	{ NULL, ewarn_ge1 },			/* Fd */
a403 6
bwarn_ge1(POST_ARGS)
{
	check_count(mdoc, MDOC_BODY, CHECK_GT, 0);
}

static void
d976 19
d996 1
a996 4
	check_count(mdoc, MDOC_HEAD, CHECK_EQ, 1);
	bwarn_ge1(mdoc);
	if (mdoc->last->type == MDOC_HEAD && mdoc->last->nchild)
		post_fname(mdoc);
@


1.272
log
@better handle .In .Sh .Ss .St .Xr without arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.271 2015/02/05 01:46:56 schwarze Exp $ */
d1075 10
a1085 1
	bwarn_ge1(mdoc);
d1092 1
d1094 8
a1101 1
	bwarn_ge1(mdoc);
d1103 4
a1106 6
	/*
	 * The `Dl' (note "el" not "one") and `Bd' macros unset the
	 * MDOC_LITERAL flag as they leave.  Note that `Bd' only sets
	 * this in literal mode, but it doesn't hurt to just switch it
	 * off in general since displays can't be nested.
	 */
d1108 1
a1108 2
	if (MDOC_BODY == mdoc->last->type)
		mdoc->flags &= ~MDOC_LITERAL;
a1504 2
	bwarn_ge1(mdoc);

d1506 6
a1511 1
	while (NULL != nchild) {
d1769 1
a1769 1
	struct mdoc_node	*n, *nch;
d1772 2
a1773 18
	n = mdoc->last;
	switch (n->type) {
	case MDOC_HEAD:
		if (MDOC_Sh == n->tok || MDOC_Ss == n->tok)
			break;
		return;
	case MDOC_BODY:
		if (MDOC_D1 == n->tok || MDOC_Nd == n->tok)
			break;
		return;
	case MDOC_ELEM:
		break;
	default:
		return;
	}

	for (nch = n->child; nch; nch = nch->next) {
		if (MDOC_TEXT != nch->type)
d1776 1
a1776 1
		if ('\0' == *cp)
d1778 2
a1779 2
		while ('\0' != *(++cp))
			if ('-' == *cp &&
d2073 7
a2079 3
	post_hyph(mdoc);

	if (MDOC_BODY != mdoc->last->type)
d2081 1
@


1.271
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.270 2015/02/04 22:30:10 schwarze Exp $ */
d159 1
a159 1
	{ NULL, ewarn_eq1 },			/* In */
d170 1
a170 1
	{ NULL, ewarn_ge1 },			/* Xr */
a1642 7
	if (NULL == nch) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    n->line, n->pos, mdoc_macronames[n->tok]);
		mdoc_node_delete(mdoc, n);
		return;
	}

a2071 1
	check_count(mdoc, MDOC_HEAD, CHECK_GT, 0);
@


1.270
log
@Discard excess head arguments for .Bd .Bl .Bk and delete hwarn_eq0().
Discard empty .Bk blocks.
Improve related diagnostics.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.269 2015/02/04 19:20:12 schwarze Exp $ */
d1171 6
a1176 4
	if (AUTH__NONE == np->norm->An.auth) {
		if (0 == np->child)
			check_count(mdoc, MDOC_ELEM, CHECK_GT, 0);
	} else if ((nch = np->child) != NULL)
@


1.269
log
@improve diagnostics regarding arguments of .An .Pp .Lp .br .sp
in particular, get rid of check_count(..., CHECK_EQ, 0)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.268 2015/02/04 18:03:47 schwarze Exp $ */
a72 1
static	void	 hwarn_eq0(POST_ARGS);
a422 6
hwarn_eq0(POST_ARGS)
{
	check_count(mdoc, MDOC_HEAD, CHECK_EQ, 0);
}

static void
a1083 2
	if (mdoc->last->tok == MDOC_Bd)
		hwarn_eq0(mdoc);
d1409 1
a1409 1
	struct mdoc_node *np, *nn, *nnp;
d1413 11
a1423 3
	if (LIST_column != mdoc->last->norm->Bl.type) {
		/* FIXME: this should be ERROR class... */
		hwarn_eq0(mdoc);
d1433 1
a1433 1
	if (mdoc->last->child == NULL)
d1436 3
a1438 5
	np = mdoc->last->parent;
	assert(np->args);

	for (j = 0; j < (int)np->args->argc; j++)
		if (MDOC_Column == np->args->argv[j].arg)
d1441 1
a1441 1
	assert(j < (int)np->args->argc);
d1449 1
a1449 1
	argv = np->args->argv + j;
d1451 1
a1451 1
	argv->sz += mdoc->last->nchild;
d1455 2
a1456 2
	mdoc->last->norm->Bl.ncols = argv->sz;
	mdoc->last->norm->Bl.cols = (void *)argv->value;
d1458 5
a1462 6
	for (nn = mdoc->last->child; nn; i++) {
		argv->value[i] = nn->string;
		nn->string = NULL;
		nnp = nn;
		nn = nn->next;
		mdoc_node_delete(NULL, nnp);
d1464 2
a1465 3

	mdoc->last->nchild = 0;
	mdoc->last->child = NULL;
d1551 3
d1555 5
a1559 2
	hwarn_eq0(mdoc);
	bwarn_ge1(mdoc);
@


1.268
log
@discard .Rs head arguments and improve .Rs diagnostics
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.267 2015/02/04 16:38:56 schwarze Exp $ */
d1177 1
a1177 1
	struct mdoc_node *np;
d1183 3
a1185 2
	} else if (np->child)
		check_count(mdoc, MDOC_ELEM, CHECK_EQ, 0);
d2138 1
a2138 4
	if (mdoc->last->tok == MDOC_sp)
		check_count(mdoc, MDOC_ELEM, CHECK_LT, 2);
	else
		check_count(mdoc, MDOC_ELEM, CHECK_EQ, 0);
d2140 9
a2148 3
	if (MDOC_ELEM != mdoc->last->type &&
	    MDOC_BLOCK != mdoc->last->type)
		return;
@


1.267
log
@more specific .Nd diagnostics, allowing to get rid of enum check_lvl
and the respective argument of check_count()
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.266 2015/02/03 00:48:47 schwarze Exp $ */
d1661 1
a1661 1
	struct mdoc_node *nn, *next, *prev;
d1664 3
a1666 3
	switch (mdoc->last->type) {
	case MDOC_HEAD:
		check_count(mdoc, MDOC_HEAD, CHECK_EQ, 0);
d1668 4
a1671 6
	case MDOC_BODY:
		if (mdoc->last->child)
			break;
		check_count(mdoc, MDOC_BODY, CHECK_GT, 0);
		return;
	default:
d1682 2
a1683 2
	for (nn = mdoc->last->child->next; nn; nn = next) {
		/* Determine order of `nn'. */
d1685 1
a1685 1
			if (rsord[i] == nn->tok)
d1690 2
a1691 2
			    mdoc->parse, nn->line, nn->pos,
			    mdoc_macronames[nn->tok]);
d1693 2
a1694 2
		} else if (MDOC__J == nn->tok || MDOC__B == nn->tok)
			mdoc->last->norm->Rs.quote_T++;
d1697 1
a1697 1
		 * Remove `nn' from the chain.  This somewhat
d1703 2
a1704 2
		if (NULL != (next = nn->next))
			next->prev = nn->prev;
d1706 2
a1707 2
		if (NULL != (prev = nn->prev))
			prev->next = nn->next;
d1709 1
a1709 1
		nn->prev = nn->next = NULL;
d1713 1
a1713 1
		 * ordered before `nn'.
d1729 2
a1730 2
		 * Set `nn' back into its correct place in front
		 * of the `prev' node.
d1733 1
a1733 1
		nn->prev = prev;
d1735 5
a1739 1
		if (prev) {
d1741 3
a1743 7
				prev->next->prev = nn;
			nn->next = prev->next;
			prev->next = nn;
		} else {
			mdoc->last->child->prev = nn;
			nn->next = mdoc->last->child;
			mdoc->last->child = nn;
@


1.266
log
@Bring .Pp/.Lp handling inside .Nm blocks closer to groff;
as a bonus, get rid of another call to rew_sub().
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.265 2014/12/18 20:15:56 schwarze Exp $ */
a50 5
enum	check_lvl {
	CHECK_WARN,
	CHECK_ERROR,
};

d60 1
a60 1
			enum check_lvl, enum check_ineq, int);
d372 1
a372 1
		enum check_lvl lvl, enum check_ineq ineq, int val)
a374 1
	enum mandocerr	 t;
d400 1
a400 2
	t = lvl == CHECK_WARN ? MANDOCERR_ARGCWARN : MANDOCERR_ARGCOUNT;
	mandoc_vmsg(t, mdoc->parse, mdoc->last->line,
d408 1
a408 1
	check_count(mdoc, MDOC_BODY, CHECK_WARN, CHECK_GT, 0);
d414 1
a414 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1);
d420 1
a420 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_GT, 0);
d426 1
a426 1
	check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0);
d937 1
a937 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1);
d991 1
a991 1
	check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 1);
d1065 10
a1075 1
	check_count(mdoc, MDOC_BODY, CHECK_ERROR, CHECK_GT, 0);
d1182 1
a1182 1
			check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_GT, 0);
d1184 1
a1184 1
		check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0);
d1666 1
a1666 1
		check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0);
d1671 1
a1671 1
		check_count(mdoc, MDOC_BODY, CHECK_WARN, CHECK_GT, 0);
d2077 1
a2077 1
	check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_GT, 0);
d2140 1
a2140 1
		check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_LT, 2);
d2142 1
a2142 1
		check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0);
@


1.265
log
@Only keep leading .Sm inside a list when it immediately precedes
the first .It.  Otherwise, move it out together with whatever
follows.  Fixing an assertion failure found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.264 2014/12/18 19:23:41 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
d1050 8
d1062 1
a1062 1
	mdoc_deroff(&mdoc->meta.name, mdoc->last);
d1066 1
a1066 1
		    mdoc->last->line, mdoc->last->pos, "Nm");
@


1.264
log
@When the head of a list item is extended with a partial explicit
macro (for example .Xo) and never closed again, the item ends up
without a body block.  This can even happen for list types that
usually don't have heads in the first place.  So even in this
case, check for the existence of the body before accessing it.
NULL pointer access found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.263 2014/11/30 05:29:00 schwarze Exp $ */
d1487 4
a1490 1
		if (MDOC_It == nchild->tok || MDOC_Sm == nchild->tok) {
@


1.263
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.262 2014/11/28 18:36:35 schwarze Exp $ */
d1200 1
a1200 1
	if (MDOC_BLOCK != nit->type)
d1216 1
a1216 1
		if (NULL == nit->head->child)
d1229 1
a1229 1
		if (NULL == nit->body->child)
d1236 1
a1236 1
		if (NULL != nit->head->child)
d1244 1
a1244 1
		assert(NULL == nit->head->child);
d1247 1
a1247 1
			if (MDOC_BODY == nch->type)
@


1.262
log
@Retire support for CSRG supplementary document titles.  These are
long obsolete and were never written in mdoc(7) in the first place.
Removes 100 lines from source files.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.261 2014/11/28 18:09:01 schwarze Exp $ */
d213 1
a213 1
	{ NULL, ewarn_eq1 },			/* Pf */
@


1.261
log
@Drop useless architecture table.  Validating architecture names
is a job for makewhatis(8)/mandoc.db(5), not for the parser.
Removes 150 lines from source files and 4k (1%) from the binary.
Bloat found by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.260 2014/11/28 17:24:41 schwarze Exp $ */
d2283 1
a2283 7
	if (NULL == (nn = nn->next))
		goto out;

	/*
	 * If the third argument is a volume name, format is,
	 * otherwise assume it's an architecture.
	 */
d2285 1
a2285 5
	cp = mdoc_a2vol(nn->string);
	if (cp) {
		free(mdoc->meta.vol);
		mdoc->meta.vol = mandoc_strdup(cp);
	} else {
@


1.260
log
@kill a pointless assert
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.259 2014/11/28 01:05:43 schwarze Exp $ */
d2286 3
a2288 5
	/* Handles: `.Dt TITLE SEC VOL'
	 * title = TITLE,
	 * volume = VOL is vol ? format(VOL) :
	 *	    VOL is arch ? format(arch) :
	 *	    VOL
d2296 3
a2298 8
		cp = mdoc_a2arch(nn->string);
		if (NULL == cp) {
			mandoc_vmsg(MANDOCERR_ARCH_BAD, mdoc->parse,
			    nn->line, nn->pos, "Dt ... %s", nn->string);
			free(mdoc->meta.vol);
			mdoc->meta.vol = mandoc_strdup(nn->string);
		} else
			mdoc->meta.arch = mandoc_strdup(cp);
@


1.259
log
@Simplify code by making mdoc validation handlers void.
No functional change, minus 90 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.258 2014/11/27 23:40:19 schwarze Exp $ */
a944 1

a945 2

	assert(n);
@


1.258
log
@Downgrade .Bd -file from FATAL to ERROR.
Since this was the last remaining FATAL error in this area,
this change will allow major simplifications in the mdoc(7) parser.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.257 2014/11/27 16:20:31 schwarze Exp $ */
d56 2
a57 2
typedef	int	(*v_pre)(PRE_ARGS);
typedef	int	(*v_post)(POST_ARGS);
d64 1
a64 1
static	int	 check_count(struct mdoc *, enum mdoc_type,
d75 59
a133 63
static	int	 berr_ge1(POST_ARGS);
static	int	 bwarn_ge1(POST_ARGS);
static	int	 ewarn_eq0(POST_ARGS);
static	int	 ewarn_eq1(POST_ARGS);
static	int	 ewarn_ge1(POST_ARGS);
static	int	 ewarn_le1(POST_ARGS);
static	int	 hwarn_eq0(POST_ARGS);
static	int	 hwarn_eq1(POST_ARGS);
static	int	 hwarn_ge1(POST_ARGS);

static	int	 post_an(POST_ARGS);
static	int	 post_at(POST_ARGS);
static	int	 post_bf(POST_ARGS);
static	int	 post_bk(POST_ARGS);
static	int	 post_bl(POST_ARGS);
static	int	 post_bl_block(POST_ARGS);
static	int	 post_bl_block_tag(POST_ARGS);
static	int	 post_bl_head(POST_ARGS);
static	int	 post_bx(POST_ARGS);
static	int	 post_d1(POST_ARGS);
static	int	 post_defaults(POST_ARGS);
static	int	 post_dd(POST_ARGS);
static	int	 post_dt(POST_ARGS);
static	int	 post_en(POST_ARGS);
static	int	 post_es(POST_ARGS);
static	int	 post_eoln(POST_ARGS);
static	int	 post_ex(POST_ARGS);
static	int	 post_fa(POST_ARGS);
static	int	 post_fn(POST_ARGS);
static	int	 post_fname(POST_ARGS);
static	int	 post_fo(POST_ARGS);
static	int	 post_hyph(POST_ARGS);
static	int	 post_hyphtext(POST_ARGS);
static	int	 post_ignpar(POST_ARGS);
static	int	 post_it(POST_ARGS);
static	int	 post_lb(POST_ARGS);
static	int	 post_literal(POST_ARGS);
static	int	 post_nd(POST_ARGS);
static	int	 post_nm(POST_ARGS);
static	int	 post_ns(POST_ARGS);
static	int	 post_os(POST_ARGS);
static	int	 post_par(POST_ARGS);
static	int	 post_root(POST_ARGS);
static	int	 post_rs(POST_ARGS);
static	int	 post_sh(POST_ARGS);
static	int	 post_sh_head(POST_ARGS);
static	int	 post_sh_name(POST_ARGS);
static	int	 post_sh_see_also(POST_ARGS);
static	int	 post_sh_authors(POST_ARGS);
static	int	 post_sm(POST_ARGS);
static	int	 post_st(POST_ARGS);
static	int	 post_vt(POST_ARGS);
static	int	 pre_an(PRE_ARGS);
static	int	 pre_bd(PRE_ARGS);
static	int	 pre_bl(PRE_ARGS);
static	int	 pre_dd(PRE_ARGS);
static	int	 pre_display(PRE_ARGS);
static	int	 pre_dt(PRE_ARGS);
static	int	 pre_literal(PRE_ARGS);
static	int	 pre_obsolete(PRE_ARGS);
static	int	 pre_os(PRE_ARGS);
static	int	 pre_par(PRE_ARGS);
static	int	 pre_std(PRE_ARGS);
d307 1
a307 1
int
d321 1
a321 1
		return(1);
d328 2
a329 1
	return(*p ? (*p)(mdoc, n) : 1);
d332 1
a332 1
int
d340 1
a340 1
		return(1);
d349 1
a349 1
		return(1);
d351 2
a352 1
		return(post_root(mdoc));
d369 3
a371 1
		return(*p ? (*p)(mdoc) : 1);
d375 1
a375 1
static int
d383 1
a383 1
		return(1);
d389 1
a389 1
			return(1);
d394 1
a394 1
			return(1);
d399 1
a399 1
			return(1);
a409 1
	return(1);
d412 1
a412 8
static int
berr_ge1(POST_ARGS)
{

	return(check_count(mdoc, MDOC_BODY, CHECK_ERROR, CHECK_GT, 0));
}

static int
d415 1
a415 1
	return(check_count(mdoc, MDOC_BODY, CHECK_WARN, CHECK_GT, 0));
d418 1
a418 7
static int
ewarn_eq0(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0));
}

static int
d421 1
a421 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1));
d424 1
a424 1
static int
d427 1
a427 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_GT, 0));
d430 1
a430 7
static int
ewarn_le1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_LT, 2));
}

static int
d433 1
a433 13
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0));
}

static int
hwarn_eq1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 1));
}

static int
hwarn_ge1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_GT, 0));
d471 1
a471 1
static int
d477 1
a477 1
		return(1);
a487 2

	return(1);
d490 1
a490 1
static int
d509 1
a509 1
		return(1);
d680 1
a680 2

	return(pre_par(mdoc, n));
d683 1
a683 1
static int
d703 1
a703 1
		return(1);
d772 1
a772 2

	return(pre_par(mdoc, n));
d775 1
a775 1
static int
d782 1
a782 1
		return(1);
a797 2

	return(1);
d800 1
a800 1
static int
d806 1
a806 1
			return(1);
a809 1
	return(1);
d812 1
a812 1
static int
a818 1
	return(1);
d821 1
a821 1
static int
a830 1
	return(1);
d833 1
a833 1
static int
a842 1
	return(1);
d845 1
a845 1
static int
a860 1
	return(1);
d863 1
a863 1
static int
d886 1
a886 1
		return(1);
d900 1
a900 1
			return(1);
d920 1
a920 1
		return(1);
a934 2

	return(1);
d937 1
a937 1
static int
a958 1
	return(1);
d961 1
a961 1
static int
a971 1
	return(1);
d974 1
a974 1
static int
a986 1
	return(1);
d989 1
a989 1
static int
a994 1
	return(1);
d997 1
a997 1
static int
d1001 1
a1001 1
	hwarn_eq1(mdoc);
a1004 1
	return(1);
d1007 1
a1007 1
static int
a1025 1
	return(1);
d1028 1
a1028 1
static int
d1042 1
a1042 1
		return(1);
a1047 2

	return(1);
d1050 1
a1050 1
static int
d1055 1
a1055 1
		return(1);
a1061 1
	return(1);
d1064 1
a1064 1
static int
d1068 2
a1069 2
	berr_ge1(mdoc);
	return(post_hyph(mdoc));
d1072 1
a1072 1
static int
d1077 1
a1077 1
	return(post_hyph(mdoc));
d1080 1
a1080 1
static int
a1096 2

	return(1);
d1099 1
a1099 1
static int
d1111 1
a1111 1
		return(1);
d1118 2
a1119 4
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "file"))
			return(0);
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "..."))
			return(0);
d1124 1
a1124 2
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "~"))
			return(0);
a1129 1

a1130 1
	return(1);
d1133 1
a1133 1
static int
d1143 1
a1143 2
		if ( ! mdoc_word_alloc(mdoc, n->line, n->pos, "AT&T UNIX"))
			return(0);
d1145 1
a1145 1
		return(1);
a1164 1
	return(1);
d1167 1
a1167 1
static int
a1177 2

	return(1);
d1180 1
a1180 1
static int
a1185 1
	return(1);
d1188 1
a1188 1
static int
a1192 1
	return(1);
d1195 1
a1195 1
static int
d1204 1
a1204 1
		return(1);
a1260 2

	return(1);
d1263 1
a1263 1
static int
d1280 1
a1280 2
		if ( ! post_bl_block_tag(mdoc))
			return(0);
d1304 1
a1304 2
				if ( ! mdoc_node_relink(mdoc, nc))
					return(0);
a1316 1
	return(1);
d1342 1
a1342 1
static int
a1404 1
	return(1);
d1407 1
a1407 1
static int
d1414 1
a1414 1
	if (LIST_column != mdoc->last->norm->Bl.type)
d1416 3
a1418 1
		return(hwarn_eq0(mdoc));
d1427 1
a1427 1
		return(1);
a1462 2

	return(1);
d1465 1
a1465 1
static int
d1475 2
a1476 1
		return(post_bl_block(mdoc));
d1478 2
a1479 1
		return(post_bl_head(mdoc));
d1483 1
a1483 1
		return(1);
a1539 2

	return(1);
d1542 1
a1542 1
static int
a1547 1
	return(1);
d1550 1
a1550 1
static int
d1559 1
a1559 1
		return(1);
d1566 1
a1566 1
		return(1);
d1570 1
a1570 1
		return(1);
d1576 2
a1577 1
	return(mdoc_node_relink(mdoc, nch));
d1580 1
a1580 1
static int
a1617 2

	return(1);
d1620 1
a1620 1
static int
d1633 1
a1633 1
		return(1);
a1645 2

	return(1);
d1648 1
a1648 1
static int
d1657 1
a1657 1
		return(1);
d1662 1
a1662 1
		return(1);
d1664 1
a1664 1
		return(1);
a1737 2

	return(1);
d1744 1
a1744 1
static int
d1755 1
a1755 1
		return(1);
d1759 1
a1759 1
		return(1);
d1763 1
a1763 1
		return(1);
a1777 1
	return(1);
d1780 1
a1780 1
static int
d1785 1
a1785 1
	return(post_hyph(mdoc));
d1788 1
a1788 1
static int
a1794 1
	return(1);
d1797 1
a1797 1
static int
d1805 2
a1806 1
		return(post_sh_head(mdoc));
d1810 2
a1811 1
			return(post_sh_name(mdoc));
d1813 2
a1814 1
			return(post_sh_see_also(mdoc));
d1816 2
a1817 1
			return(post_sh_authors(mdoc));
a1824 2

	return(1);
d1827 1
a1827 1
static int
d1841 1
a1841 1
		return(1);
d1855 1
a1855 1
		return(1);
a1858 1
	return(1);
d1861 1
a1861 1
static int
d1913 1
a1913 1
				return(1);
a1920 1
	return(1);
d1933 1
a1933 1
static int
a1939 1
	return(1);
d1942 1
a1942 1
static int
d2001 1
a2001 1
		return(1);
d2027 1
a2027 1
		return(1);
a2058 1

a2059 1
	return(1);
d2062 1
a2062 1
static int
d2067 1
a2067 1
	hwarn_ge1(mdoc);
d2071 1
a2071 1
		return(1);
a2089 2

	return(1);
d2092 1
a2092 1
static int
d2097 1
a2097 1
		return(1);
d2099 1
a2099 1
		return(1);
d2109 1
a2109 1
		return(1);
d2111 1
a2111 1
		return(1);
d2113 1
a2113 1
		return(1);
d2115 1
a2115 1
		return(1);
a2121 1
	return(1);
d2124 1
a2124 1
static int
d2130 1
a2130 1
		ewarn_le1(mdoc);
d2132 1
a2132 1
		ewarn_eq0(mdoc);
d2136 1
a2136 1
		return(1);
d2141 5
a2145 7
			return(1);
	} else {
		if (MDOC_Pp != np->tok && MDOC_Lp != np->tok &&
		    (MDOC_br != mdoc->last->tok ||
		     (MDOC_sp != np->tok && MDOC_br != np->tok)))
			return(1);
	}
a2151 1
	return(1);
d2154 1
a2154 1
static int
d2161 1
a2161 1
		return(1);
a2181 2

	return(1);
d2184 1
a2184 1
static int
a2210 1
	return(1);
d2213 1
a2213 1
static int
a2314 1
	return(1);
d2317 1
a2317 1
static int
a2330 2

	return(1);
d2333 1
a2333 1
static int
a2380 1
	return(1);
d2387 1
a2387 1
static int
d2395 1
a2395 1
		return(1);
d2400 1
a2400 1
		return(1);
d2404 1
a2404 4

	if ( ! mdoc_word_alloc(mdoc, n->line, n->pos, mdoc->meta.name))
		return(0);

a2405 1
	return(1);
@


1.257
log
@Fix the obsolete .Db (toggle debug mode) macro to ignore its arguments
and not trigger an assertion when there is more than one argument;
the latter found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.256 2014/11/26 19:24:03 schwarze Exp $ */
d764 1
a764 1
			return(0);
@


1.256
log
@remove an unreachable warning about .Sm arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.255 2014/11/17 06:44:58 schwarze Exp $ */
a74 1
static	int	 ebool(POST_ARGS);
d124 1
d202 1
a202 1
	{ NULL, ebool },			/* Db */
d229 1
a229 1
	{ NULL, ebool },			/* Sm */
d1625 1
a1625 1
ebool(struct mdoc *mdoc)
a1627 1
	enum mdoct		 tok;
a1628 1
	tok = mdoc->last->tok;
d1631 2
a1632 3
	if (NULL == nch) {
		if (MDOC_Sm == tok)
			mdoc->flags ^= MDOC_SMOFF;
d1636 1
a1636 1
	assert(MDOC_TEXT == nch->type);
d1638 2
a1639 3
	if (0 == strcmp(nch->string, "on")) {
		if (MDOC_Sm == tok)
			mdoc->flags &= ~MDOC_SMOFF;
d1642 2
a1643 3
	if (0 == strcmp(nch->string, "off")) {
		if (MDOC_Sm == tok)
			mdoc->flags |= MDOC_SMOFF;
d1649 1
a1649 1
	    "%s %s", mdoc_macronames[tok], nch->string);
@


1.255
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.254 2014/10/30 20:10:02 schwarze Exp $ */
a1638 2
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_LT, 2);

@


1.254
log
@Major bugsquashing with respect to -offset and -width:
1. Support specifying the .Bd and .Bl -offset as a macro default width;
while here, simplify the code handling the same for .Bl -width.
2. Correct handling of .Bl -offset arguments:  unlike .Bd -offset, the
arguments "left", "indent", and "indent-two" have no special meaning.
3. Fix the scaling of string length -offset and -width arguments in -Thtml.
Triggered by an incomplete documentation patch from bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.253 2014/10/13 14:05:32 schwarze Exp $ */
d212 1
a212 1
	{ NULL, ewarn_eq0 },			/* No */
d356 14
a1178 4
	case MDOC_Li:
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, ""))
			return(0);
		break;
@


1.253
log
@sync with OpenBSD:
check sorting of .Xr's case-insensitively;
no idea why this was different here
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.252 2014/10/13 14:01:21 schwarze Exp $ */
d73 1
a91 1
static	int	 post_bl_block_width(POST_ARGS);
d600 1
d615 1
d763 1
a1341 4
	} else if (NULL != n->norm->Bl.width) {
		if ( ! post_bl_block_width(mdoc))
			return(0);
		assert(n->norm->Bl.width);
d1381 6
a1386 2
static int
post_bl_block_width(POST_ARGS)
a1388 1
	int		  i;
a1389 2
	struct mdoc_node *n;
	char		  buf[24];
d1391 3
a1393 12
	n = mdoc->last;

	/*
	 * Calculate the real width of a list from the -width string,
	 * which may contain a macro (with a known default width), a
	 * literal string, or a scaling width.
	 *
	 * If the value to -width is a macro, then we re-write it to be
	 * the macro's width as set in share/tmac/mdoc/doc-common.
	 */

	if (0 == strcmp(n->norm->Bl.width, "Ds"))
d1395 2
a1396 2
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->norm->Bl.width)))
		return(1);
d1400 2
a1401 17
	/* The value already exists: free and reallocate it. */

	assert(n->args);

	for (i = 0; i < (int)n->args->argc; i++)
		if (MDOC_Width == n->args->argv[i].arg)
			break;

	assert(i < (int)n->args->argc);

	(void)snprintf(buf, sizeof(buf), "%un", (unsigned int)width);
	free(n->args->argv[i].value[0]);
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->norm->Bl.width = n->args->argv[i].value[0];
	return(1);
d1416 1
a1416 1
	 * post_bl_block_width() for converting the -width string.
@


1.252
log
@Do not warn about declarations of functions returning function pointers,
getting rid of a false positive noticed by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.251 2014/10/11 21:34:04 schwarze Exp $ */
d1992 2
a1993 1
			else if (cmp == 0 && strcmp(lastname, name) > 0)
@


1.251
log
@oops, don't crash when .Fo has no argument
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.250 2014/10/11 21:14:16 schwarze Exp $ */
d1007 3
a1009 2
	const struct mdoc_node *n;
	size_t pos;
d1013 2
a1014 1
	if (n->string[pos] != '\0')
@


1.250
log
@warn about parentheses in function names after .Fn and .Fo;
particularly useful when converting from other languages to mdoc(7);
feature suggested by bentley@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.249 2014/09/12 00:54:10 schwarze Exp $ */
d1033 1
a1033 1
	if (mdoc->last->type == MDOC_HEAD)
@


1.249
log
@warn about commas in function arguments; inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.248 2014/09/11 23:53:30 schwarze Exp $ */
d104 2
d166 1
a166 1
	{ NULL, post_fa },			/* Fn */
d1005 23
d1033 2
@


1.248
log
@warn about botched .Xr ordering and punctuation below SEE ALSO;
inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.247 2014/09/07 23:25:01 schwarze Exp $ */
d103 1
d161 1
a161 1
	{ NULL, NULL },				/* Fa */
d164 1
a164 1
	{ NULL, NULL },				/* Fn */
d1012 22
@


1.247
log
@warn about AUTHORS sections without .An macros, inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.246 2014/09/07 00:05:28 schwarze Exp $ */
d120 1
d1860 2
d1911 62
@


1.246
log
@Allow .ll in the prologue; Daniel Levai reports Slackware Linux uses this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.245 2014/08/19 17:31:55 schwarze Exp $ */
d70 1
a117 1
static	int	 post_sh_body(POST_ARGS);
d119 2
d1852 2
a1853 1
	if (MDOC_HEAD == mdoc->last->type)
d1855 13
a1867 2
	if (MDOC_BODY == mdoc->last->type)
		return(post_sh_body(mdoc));
d1873 1
a1873 1
post_sh_body(POST_ARGS)
a1876 3
	if (SEC_NAME != mdoc->lastsec)
		return(1);

d1908 20
@


1.245
log
@Do not dereference a NULL pointer if a .Bl macro has
no -type, -width, -offset or -compact arguments whatsoever;
this got broken in rev. 1.238.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.244 2014/08/10 23:54:41 schwarze Exp $ */
a1645 3
	n = mdoc->first;
	assert(n);

d1648 7
a1654 4
	if (NULL == n->child)
		mandoc_msg(MANDOCERR_DOC_EMPTY, mdoc->parse,
		    n->line, n->pos, NULL);
	else if (MDOC_Sh != n->child->tok)
d1656 1
a1656 2
		    n->child->line, n->child->pos,
		    mdoc_macronames[n->child->tok]);
@


1.244
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.243 2014/08/06 15:09:05 schwarze Exp $ */
d532 1
a532 1
	wa = n->args->argv;
@


1.243
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.242 2014/08/02 00:02:42 schwarze Exp $ */
a18 1
#ifdef HAVE_CONFIG_H
a19 1
#endif
d21 1
a25 2
#include <sys/types.h>

@


1.242
log
@Simplify by allowing only one post-handler.
Saves 36 static arrays and 10 lines of code
at the expense of only five new trivial static functions.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.241 2014/08/01 22:22:11 schwarze Exp $ */
a116 1
static	int	 post_prol(POST_ARGS);
d845 1
a845 5
	if (NULL == mdoc->meta.date || mdoc->meta.os)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
		    n->line, n->pos, "Dt");

	if (mdoc->meta.title)
d848 3
a850 1

d858 2
a859 2
	if (NULL == mdoc->meta.title || NULL == mdoc->meta.date)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
d861 2
a862 3

	if (mdoc->meta.os)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
a863 1

d871 2
a872 2
	if (mdoc->meta.title || mdoc->meta.os)
		mandoc_msg(MANDOCERR_PROLOG_ORDER, mdoc->parse,
d874 2
a875 3

	if (mdoc->meta.date)
		mandoc_msg(MANDOCERR_PROLOG_REP, mdoc->parse,
d877 6
a882 1

d1629 18
a1646 14
	if ( ! (MDOC_PBODY & mdoc->flags)) {
		mandoc_msg(MANDOCERR_PROLOG_BAD, mdoc->parse, 0, 0, "EOF");
		if (mdoc->meta.date == NULL)
			mdoc->meta.date = mdoc->quick ?
			    mandoc_strdup("") :
			    mandoc_normdate(mdoc->parse, NULL, 0, 0);
		if (mdoc->meta.title == NULL)
			mdoc->meta.title = mandoc_strdup("UNKNOWN");
		if (mdoc->meta.vol == NULL)
			mdoc->meta.vol = mandoc_strdup("LOCAL");
		if (mdoc->meta.arch == NULL)
			mdoc->meta.msec = mandoc_strdup("1");
		if (mdoc->meta.os == NULL)
			mdoc->meta.os = mandoc_strdup("UNKNOWN");
d1983 4
a1986 1
	assert(mdoc->meta.msec);
d2165 1
a2165 1
		return(post_prol(mdoc));
d2177 3
a2179 1
	return(post_prol(mdoc));
d2191 9
a2199 8
	if (mdoc->meta.title)
		free(mdoc->meta.title);
	if (mdoc->meta.vol)
		free(mdoc->meta.vol);
	if (mdoc->meta.arch)
		free(mdoc->meta.arch);

	mdoc->meta.title = mdoc->meta.vol = mdoc->meta.arch = NULL;
d2214 1
a2214 3
	/* Handles: `.Dt'
	 * title = unknown, volume = local, msec = 0, arch = NULL
	 */
d2217 3
a2219 3
		/* XXX: make these macro values. */
		/* FIXME: warn about missing values. */
		mdoc->meta.title = mandoc_strdup("UNKNOWN");
d2221 1
a2221 2
		mdoc->meta.msec = mandoc_strdup("1");
		return(post_prol(mdoc));
d2224 1
a2224 3
	/* Handles: `.Dt TITLE'
	 * title = TITLE, volume = local, msec = 0, arch = NULL
	 */
d2227 1
a2227 1
	    '\0' == nn->string[0] ? "UNKNOWN" : nn->string);
d2230 3
a2232 2
		/* FIXME: warn about missing msec. */
		/* XXX: make this a macro value. */
d2234 1
a2234 2
		mdoc->meta.msec = mandoc_strdup("1");
		return(post_prol(mdoc));
d2256 1
a2256 1
		return(post_prol(mdoc));
d2282 2
a2283 17

	return(post_prol(mdoc));
}

static int
post_prol(POST_ARGS)
{
	/*
	 * Remove prologue macros from the document after they're
	 * processed.  The final document uses mdoc_meta for these
	 * values and discards the originals.
	 */

	mdoc_node_delete(mdoc, mdoc->last);
	if (mdoc->meta.title && mdoc->meta.date && mdoc->meta.os)
		mdoc->flags |= MDOC_PBODY;

d2329 1
a2329 1
		return(post_prol(mdoc));
d2333 1
a2333 1
		return(post_prol(mdoc));
d2350 4
a2353 1
	return(post_prol(mdoc));
@


1.241
log
@Simplify by allowing only one pre-handler.
Saves 12 static arrays and 19 lines of code.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.240 2014/08/01 17:40:34 schwarze Exp $ */
d64 1
a64 1
	v_post	*post;
d90 1
d97 1
d105 1
d107 1
d112 1
a136 37
static	v_post	 posts_an[] = { post_an, NULL };
static	v_post	 posts_at[] = { post_at, post_defaults, NULL };
static	v_post	 posts_bd[] = { post_literal, hwarn_eq0, bwarn_ge1, NULL };
static	v_post	 posts_bf[] = { post_bf, NULL };
static	v_post	 posts_bk[] = { hwarn_eq0, bwarn_ge1, NULL };
static	v_post	 posts_bl[] = { bwarn_ge1, post_bl, NULL };
static	v_post	 posts_bx[] = { post_bx, NULL };
static	v_post	 posts_bool[] = { ebool, NULL };
static	v_post	 posts_eoln[] = { post_eoln, NULL };
static	v_post	 posts_defaults[] = { post_defaults, NULL };
static	v_post	 posts_d1[] = { bwarn_ge1, post_hyph, NULL };
static	v_post	 posts_dd[] = { post_dd, post_prol, NULL };
static	v_post	 posts_dl[] = { post_literal, bwarn_ge1, NULL };
static	v_post	 posts_dt[] = { post_dt, post_prol, NULL };
static	v_post	 posts_en[] = { post_en, NULL };
static	v_post	 posts_es[] = { post_es, NULL };
static	v_post	 posts_ex[] = { post_ex, NULL };
static	v_post	 posts_fo[] = { hwarn_eq1, bwarn_ge1, NULL };
static	v_post	 posts_hyph[] = { post_hyph, NULL };
static	v_post	 posts_hyphtext[] = { ewarn_ge1, post_hyph, NULL };
static	v_post	 posts_it[] = { post_it, NULL };
static	v_post	 posts_lb[] = { post_lb, NULL };
static	v_post	 posts_nd[] = { berr_ge1, post_hyph, NULL };
static	v_post	 posts_nm[] = { post_nm, NULL };
static	v_post	 posts_notext[] = { ewarn_eq0, NULL };
static	v_post	 posts_ns[] = { post_ns, NULL };
static	v_post	 posts_os[] = { post_os, post_prol, NULL };
static	v_post	 posts_pp[] = { post_par, ewarn_eq0, NULL };
static	v_post	 posts_rs[] = { post_rs, NULL };
static	v_post	 posts_sh[] = { post_ignpar,hwarn_ge1,post_sh,post_hyph,NULL };
static	v_post	 posts_sp[] = { post_par, ewarn_le1, NULL };
static	v_post	 posts_ss[] = { post_ignpar, hwarn_ge1, post_hyph, NULL };
static	v_post	 posts_st[] = { post_st, NULL };
static	v_post	 posts_text[] = { ewarn_ge1, NULL };
static	v_post	 posts_text1[] = { ewarn_eq1, NULL };
static	v_post	 posts_vt[] = { post_vt, NULL };

d139 9
a147 9
	{ pre_dd, posts_dd },			/* Dd */
	{ pre_dt, posts_dt },			/* Dt */
	{ pre_os, posts_os },			/* Os */
	{ NULL, posts_sh },			/* Sh */
	{ NULL, posts_ss },			/* Ss */
	{ pre_par, posts_pp },			/* Pp */
	{ pre_display, posts_d1 },		/* D1 */
	{ pre_literal, posts_dl },		/* Dl */
	{ pre_bd, posts_bd },			/* Bd */
d149 1
a149 1
	{ pre_bl, posts_bl },			/* Bl */
d151 1
a151 1
	{ pre_par, posts_it },			/* It */
d153 2
a154 2
	{ pre_an, posts_an },			/* An */
	{ NULL, posts_defaults },		/* Ar */
d160 1
a160 1
	{ pre_std, posts_ex },			/* Ex */
d162 1
a162 1
	{ NULL, posts_text },			/* Fd */
d167 4
a170 4
	{ NULL, posts_text1 },			/* In */
	{ NULL, posts_defaults },		/* Li */
	{ NULL, posts_nd },			/* Nd */
	{ NULL, posts_nm },			/* Nm */
d173 1
a173 1
	{ NULL, posts_defaults },		/* Pa */
d175 1
a175 1
	{ NULL, posts_st },			/* St */
d177 13
a189 13
	{ NULL, posts_vt },			/* Vt */
	{ NULL, posts_text },			/* Xr */
	{ NULL, posts_text },			/* %A */
	{ NULL, posts_hyphtext },		/* %B */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, posts_text },			/* %D */
	{ NULL, posts_text },			/* %I */
	{ NULL, posts_text },			/* %J */
	{ NULL, posts_hyphtext },		/* %N */
	{ NULL, posts_hyphtext },		/* %O */
	{ NULL, posts_text },			/* %P */
	{ NULL, posts_hyphtext },		/* %R */
	{ NULL, posts_hyphtext },		/* %T */ /* FIXME: can be used outside Rs/Re. */
	{ NULL, posts_text },			/* %V */
d193 1
a193 1
	{ NULL, posts_at },			/* At */
d195 1
a195 1
	{ NULL, posts_bf },			/* Bf */
d199 2
a200 2
	{ NULL, posts_bx },			/* Bx */
	{ NULL, posts_bool },			/* Db */
d210 2
a211 2
	{ NULL, posts_notext },			/* No */
	{ NULL, posts_ns },			/* Ns */
d215 1
a215 1
	{ NULL, posts_text1 },			/* Pf */
d223 1
a223 1
	{ NULL, posts_rs },			/* Rs */
d227 2
a228 2
	{ NULL, posts_bool },			/* Sm */
	{ NULL, posts_hyph },			/* Sx */
d234 1
a234 1
	{ NULL, posts_fo },			/* Fo */
d238 1
a238 1
	{ NULL, posts_bk },			/* Bk */
d240 1
a240 1
	{ NULL, posts_eoln },			/* Bt */
d243 3
a245 3
	{ NULL, posts_eoln },			/* Ud */
	{ NULL, posts_lb },			/* Lb */
	{ pre_par, posts_pp },			/* Lp */
d247 1
a247 1
	{ NULL, posts_defaults },		/* Mt */
d251 3
a253 3
	{ NULL, posts_text },			/* %C */
	{ pre_obsolete, posts_es },		/* Es */
	{ pre_obsolete, posts_en },		/* En */
d255 4
a258 4
	{ NULL, posts_text },			/* %Q */
	{ NULL, posts_pp },			/* br */
	{ NULL, posts_sp },			/* sp */
	{ NULL, posts_text1 },			/* %U */
d336 2
a337 1
	v_post		*p;
d339 2
a340 1
	if (MDOC_VALID & mdoc->last->flags)
d342 1
a342 1
	mdoc->last->flags |= MDOC_VALID;
d344 1
a344 1
	switch (mdoc->last->type) {
d354 2
a355 1
		break;
a356 8

	if (NULL == mdoc_valids[mdoc->last->tok].post)
		return(1);
	for (p = mdoc_valids[mdoc->last->tok].post; *p; p++)
		if ( ! (*p)(mdoc))
			return(0);

	return(1);
d1003 9
d1051 16
d1070 4
a1110 6
	case MDOC_At:
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "AT&T"))
			return(0);
		if ( ! mdoc_word_alloc(mdoc, nn->line, nn->pos, "UNIX"))
			return(0);
		break;
d1137 9
d1152 1
a1152 3
	if (NULL == (n = mdoc->last->child))
		return(1);

d1520 2
d1579 9
d1828 8
d1849 2
d2021 3
d2086 5
d2159 1
a2159 1
		return(1);
d2171 1
a2171 1
	return(1);
d2215 1
a2215 1
		return(1);
d2230 1
a2230 1
		return(1);
d2252 1
a2252 1
		return(1);
d2279 1
a2279 1
	return(1);
d2340 1
a2340 1
		return(1);
d2344 1
a2344 1
		return(1);
d2361 1
a2361 1
	return(1);
@


1.240
log
@demacrify: get rid of man_nmsg(), man_pmsg(), mdoc_nmsg(), mdoc_pmsg()
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.239 2014/08/01 17:27:44 schwarze Exp $ */
d63 1
a63 1
	v_pre	*pre;
a167 12
static	v_pre	 pres_an[] = { pre_an, NULL };
static	v_pre	 pres_bd[] = { pre_display, pre_bd, pre_literal, pre_par, NULL };
static	v_pre	 pres_bl[] = { pre_bl, pre_par, NULL };
static	v_pre	 pres_d1[] = { pre_display, NULL };
static	v_pre	 pres_dl[] = { pre_literal, pre_display, NULL };
static	v_pre	 pres_dd[] = { pre_dd, NULL };
static	v_pre	 pres_dt[] = { pre_dt, NULL };
static	v_pre	 pres_it[] = { pre_par, NULL };
static	v_pre	 pres_obsolete[] = { pre_obsolete, NULL };
static	v_pre	 pres_os[] = { pre_os, NULL };
static	v_pre	 pres_pp[] = { pre_par, NULL };
static	v_pre	 pres_std[] = { pre_std, NULL };
d171 3
a173 3
	{ pres_dd, posts_dd },			/* Dd */
	{ pres_dt, posts_dt },			/* Dt */
	{ pres_os, posts_os },			/* Os */
d176 4
a179 4
	{ pres_pp, posts_pp },			/* Pp */
	{ pres_d1, posts_d1 },			/* D1 */
	{ pres_dl, posts_dl },			/* Dl */
	{ pres_bd, posts_bd },			/* Bd */
d181 1
a181 1
	{ pres_bl, posts_bl },			/* Bl */
d183 1
a183 1
	{ pres_it, posts_it },			/* It */
d185 1
a185 1
	{ pres_an, posts_an },			/* An */
d192 1
a192 1
	{ pres_std, posts_ex },			/* Ex */
d204 1
a204 1
	{ pres_obsolete, NULL },		/* Ot */
d206 1
a206 1
	{ pres_std, NULL },			/* Rv */
d274 1
a274 1
	{ pres_obsolete, NULL },		/* Fr */
d277 1
a277 1
	{ pres_pp, posts_pp },			/* Lp */
d284 2
a285 2
	{ pres_obsolete, posts_es },		/* Es */
	{ pres_obsolete, posts_en },		/* En */
d344 1
a344 3
	v_pre		*p;
	int		 line, pos;
	char		*tp;
d348 1
a348 4
		tp = n->string;
		line = n->line;
		pos = n->pos;
		check_text(mdoc, line, pos, tp);
d361 2
a362 7

	if (NULL == mdoc_valids[n->tok].pre)
		return(1);
	for (p = mdoc_valids[n->tok].pre; *p; p++)
		if ( ! (*p)(mdoc, n))
			return(0);
	return(1);
d734 1
a734 1
	return(1);
d745 2
d826 1
a826 1
	return(1);
d2096 2
@


1.239
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.238 2014/07/31 09:22:21 schwarze Exp $ */
d1668 2
a1669 1
		mdoc_nmsg(mdoc, n, MANDOCERR_DOC_EMPTY);
d1848 2
a1849 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NS_SKIP);
@


1.238
log
@Split MANDOCERR_IGNARGV into one message for .An and one for .Bl
and report the macro name and argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.237 2014/07/31 00:41:10 schwarze Exp $ */
d683 1
a683 1
			mandoc_msg(MANDOCERR_BL_REP,
d685 1
a685 1
			    mdoc_argnames[argv->arg]);
d694 2
a695 2
			mandoc_msg(MANDOCERR_BL_LATETYPE,
			    mdoc->parse, n->line, n->pos,
d708 2
a709 1
		mdoc_nmsg(mdoc, n, MANDOCERR_BL_NOTYPE);
d723 2
a724 1
			mdoc_nmsg(mdoc, n, MANDOCERR_BL_NOWIDTH);
d801 2
a802 1
			mdoc_nmsg(mdoc, n, MANDOCERR_BADDISP);
d835 1
a835 1
			mandoc_msg(MANDOCERR_BD_REP,
d837 1
a837 1
			    mdoc_argnames[argv->arg]);
d841 2
a842 1
		mdoc_nmsg(mdoc, n, MANDOCERR_BD_NOTYPE);
d979 2
a980 1
			mdoc_nmsg(mdoc, np, MANDOCERR_BF_NOFONT);
d1093 2
a1094 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NM_NONAME);
d1182 2
a1183 2
		mandoc_msg(MANDOCERR_AT_BAD, mdoc->parse,
		    n->line, n->pos, n->string);
d1250 1
a1250 1
			mandoc_msg(MANDOCERR_IT_NOHEAD,
d1252 1
d1263 1
a1263 1
			mandoc_msg(MANDOCERR_IT_NOBODY,
d1265 1
d1696 2
a1697 2
		mandoc_msg(MANDOCERR_ST_BAD, mdoc->parse,
		    nch->line, nch->pos, nch->string);
d1924 3
a1926 2
		mandoc_msg(MANDOCERR_NAMESEC_FIRST, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d1969 3
a1971 2
		mandoc_msg(MANDOCERR_SEC_REP, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d1974 3
a1976 2
		mandoc_msg(MANDOCERR_SEC_ORDER, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d2010 1
a2010 1
		    "%s for %s only", secname, goodsec);
d2192 1
a2192 1
			mandoc_msg(MANDOCERR_TITLE_CASE,
d2195 1
a2195 1
			    nn->string);
d2239 2
a2240 2
		mandoc_msg(MANDOCERR_MSEC_BAD, mdoc->parse,
		    nn->line, nn->pos, nn->string);
d2262 2
a2263 2
			mandoc_msg(MANDOCERR_ARCH_BAD, mdoc->parse,
			    nn->line, nn->pos, nn->string);
d2373 2
a2374 1
		mdoc_nmsg(mdoc, n, MANDOCERR_EX_NONAME);
@


1.237
log
@In .Bl -column, if some of the column width declarations are given
right after the -column argument and some at the very end of the
argument list, after some other arguments like -compact, concatenate
the column lists.
This gets rid of one of the last useless FATAL errors
and actually shortens the code by a few lines.

This fixes an issue introduced more than five years ago, at first
causing an assert() since mdoc_action.c rev. 1.14 (June 17, 2009),
then later a FATAL error since mdoc_validate rev. 1.130 (Nov. 30, 2010),
and marked as "TODO" ever since.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.236 2014/07/30 23:38:52 schwarze Exp $ */
d571 1
a571 1
	struct mdoc_argv *argv;
d573 1
d595 2
d644 1
d678 1
d734 3
a736 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
d848 2
a849 1
	int		 i;
d851 1
a851 1
	if (NULL == n->args)
d854 6
a859 3
	for (i = 1; i < (int)n->args->argc; i++)
		mdoc_pmsg(mdoc, n->args->argv[i].line,
		    n->args->argv[i].pos, MANDOCERR_IGNARGV);
d861 2
a862 1
	if (MDOC_Split == n->args->argv[0].arg)
d864 1
a864 1
	else if (MDOC_Nosplit == n->args->argv[0].arg)
@


1.236
log
@Remove the useless FATAL error "argument count wrong, violates syntax".
The last remaining instance was .It in .Bl -column with more than one
excessive .Ta.  However, simply downgrading from FATAL to ERROR, it just
works fine, almost the same way as in groff, without any other changes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.235 2014/07/30 17:06:26 schwarze Exp $ */
d1454 1
d1462 1
a1462 1
	 * Convert old-style lists, where the column width specifiers
d1467 1
a1467 11
	/* First, disallow both types and allow normal-form. */

	/*
	 * TODO: technically, we can accept both and just merge the two
	 * lists, but I'll leave that for another day.
	 */

	if (mdoc->last->norm->Bl.ncols && mdoc->last->nchild) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_COLUMNS);
		return(0);
	} else if (NULL == mdoc->last->child)
a1477 1
	assert(0 == np->args->argv[j].sz);
d1485 5
a1489 3
	np->args->argv[j].sz = (size_t)mdoc->last->nchild;
	np->args->argv[j].value = mandoc_reallocarray(NULL,
	    (size_t)mdoc->last->nchild, sizeof(char *));
d1491 2
a1492 2
	mdoc->last->norm->Bl.ncols = np->args->argv[j].sz;
	mdoc->last->norm->Bl.cols = (void *)np->args->argv[j].value;
d1494 2
a1495 2
	for (i = 0, nn = mdoc->last->child; nn; i++) {
		np->args->argv[j].value[i] = nn->string;
@


1.235
log
@Get rid of the useless FATAL error "child violates parent syntax".
When finding items outside lists, simply skip them and throw an ERROR.
Handle subsections before the first section instead of bailing out.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.234 2014/07/30 14:50:08 schwarze Exp $ */
a1212 1
	enum mandocerr	  er;
d1263 5
a1267 10
		if (i < cols)
			er = MANDOCERR_ARGCOUNT;
		else if (i == cols || i == cols + 1)
			break;
		else
			er = MANDOCERR_SYNTARGCOUNT;

		mandoc_vmsg(er, mdoc->parse, nit->line, nit->pos,
		    "columns == %d (have %d)", cols, i);
		return(MANDOCERR_ARGCOUNT == er);
@


1.234
log
@Remove two useless FATAL errors.
When a file contains neither text nor macros, treat it as an empty document.
When the mdoc(7) document prologue is incomplete, use some default values.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.233 2014/07/30 12:58:21 schwarze Exp $ */
a68 1
static	int	 check_parent(PRE_ARGS, enum mdoct, enum mdoc_type);
a125 1
static	int	 pre_it(PRE_ARGS);
a129 2
static	int	 pre_sh(PRE_ARGS);
static	int	 pre_ss(PRE_ARGS);
d175 1
a175 1
static	v_pre	 pres_it[] = { pre_it, pre_par, NULL };
a178 2
static	v_pre	 pres_sh[] = { pre_sh, NULL };
static	v_pre	 pres_ss[] = { pre_ss, NULL };
d186 2
a187 2
	{ pres_sh, posts_sh },			/* Sh */
	{ pres_ss, posts_ss },			/* Ss */
a546 16
check_parent(PRE_ARGS, enum mdoct tok, enum mdoc_type t)
{

	assert(n->parent);
	if ((MDOC_ROOT == t || tok == n->parent->tok) &&
			(t == n->parent->type))
		return(1);

	mandoc_vmsg(MANDOCERR_SYNTCHILD, mdoc->parse,
	    n->line, n->pos, "want parent %s",
	    MDOC_ROOT == t ? "<root>" : mdoc_macronames[tok]);
	return(0);
}


static int
a838 28
pre_ss(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);
	return(check_parent(mdoc, n, MDOC_Sh, MDOC_BODY));
}

static int
pre_sh(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);
	return(check_parent(mdoc, n, MDOC_MAX, MDOC_ROOT));
}

static int
pre_it(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);

	return(check_parent(mdoc, n, MDOC_Bl, MDOC_BODY));
}

static int
@


1.233
log
@better name and wording for the last two non-generic errors
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.232 2014/07/30 00:19:16 schwarze Exp $ */
a1685 1
	int		  ret;
d1688 1
a1688 3
	ret = 1;

	/* Check that we have a finished prologue. */
d1691 13
a1703 2
		ret = 0;
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCPROLOG);
d1718 1
a1718 1
	return(ret);
@


1.232
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.231 2014/07/29 13:58:18 schwarze Exp $ */
d2379 2
a2380 1
			mdoc_nmsg(mdoc, n, MANDOCERR_UNAME);
@


1.231
log
@Partial implementation of .Bd -centered.

In groff, .Bd -centered operates in fill mode, which is relatively
hard to implement, while this implementation operates in non-fill
mode so far.  As long as you pay attention that your lines do not
overflow, it works.  To make sure that rendering is the same for
mandoc and groff, it is recommended to insert .br between lines
for now.  This implementation will need improvement later.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.230 2014/07/07 16:12:20 schwarze Exp $ */
d103 1
a119 1
static	int	 post_std(POST_ARGS);
d152 1
a168 1
static	v_post	 posts_std[] = { post_std, NULL };
d210 1
a210 1
	{ pres_std, posts_std },		/* Ex */
d224 1
a224 1
	{ pres_std, posts_std },		/* Rv */
a536 6

	/* FIXME: move to post_std(). */

	if (MDOC_Std == v->arg)
		if ( ! (v->sz || mdoc->meta.name))
			mdoc_nmsg(mdoc, n, MANDOCERR_NONAME);
d1125 2
a1126 4
	if (NULL == mdoc->meta.name) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NONAME);
		mdoc->meta.name = mandoc_strdup("UNKNOWN");
	}
d2390 4
d2395 1
a2395 1
post_std(POST_ARGS)
d2397 1
a2397 1
	struct mdoc_node *nn, *n;
a2400 6
	/*
	 * Macros accepting `-std' as an argument have the name of the
	 * current document (`Nm') filled in as the argument if it's not
	 * provided.
	 */

d2404 2
a2405 1
	if (NULL == mdoc->meta.name)
d2407 1
a2408 1
	nn = n;
d2414 1
a2414 1
	mdoc->last = nn;
@


1.230
log
@no need to delete any content from .Rs blocks,
and downgrade the related message from ERROR to WARNING
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.229 2014/07/06 19:09:00 schwarze Exp $ */
d805 1
a805 1
			dt = DISP_centred;
@


1.229
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.228 2014/07/05 12:34:17 schwarze Exp $ */
a1770 33
	 * Make sure only certain types of nodes are allowed within the
	 * the `Rs' body.  Delete offending nodes and raise a warning.
	 * Do this before re-ordering for the sake of clarity.
	 */

	next = NULL;
	for (nn = mdoc->last->child; nn; nn = next) {
		for (i = 0; i < RSORD_MAX; i++)
			if (nn->tok == rsord[i])
				break;

		if (i < RSORD_MAX) {
			if (MDOC__J == rsord[i] || MDOC__B == rsord[i])
				mdoc->last->norm->Rs.quote_T++;
			next = nn->next;
			continue;
		}

		next = nn->next;
		mandoc_msg(MANDOCERR_RS_SKIP, mdoc->parse,
		    nn->line, nn->pos, mdoc_macronames[nn->tok]);
		mdoc_node_delete(mdoc, nn);
	}

	/*
	 * Nothing to sort if only invalid nodes were found
	 * inside the `Rs' body.
	 */

	if (NULL == mdoc->last->child)
		return(1);

	/*
d1773 1
a1773 1
	 * and correctly order it.  This is a insertion sort.
d1783 8
d1816 2
@


1.228
log
@Cleanup with respect to bad macro arguments.
* Fix .Sm with invalid arg: move arg out and toggle mode.
* Promote "unknown standard" from WARNING to ERROR, it loses information.
* Delete MANDOCERR_BADWIDTH, it would only indicate a mandoc(1) bug.
* Do not report MANDOCERR_BL_LATETYPE when there is no type at all.
* Mention macro names, arguments and fallbacks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.227 2014/07/05 01:12:20 schwarze Exp $ */
d554 2
a555 1
		mdoc_pmsg(mdoc, ln, pos + (int)(p - cp), MANDOCERR_BADTAB);
@


1.227
log
@Cleanup regarding -offset and -width:
* Bugfix: Last one wins, not first one.
* Fix .Bl -width without argument: it means 0n, so do not ignore it.
* Report macro names, argument names and fallbacks in related messages.
* Simplify: Garbage collect auxiliary variables in pre_bd() and pre_bl().
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.226 2014/07/04 16:12:08 schwarze Exp $ */
d699 2
d704 5
a708 14
		if (LIST__NONE != lt && n->norm->Bl.type != LIST__NONE)
			mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP);

		/* Assign list type. */

		if (LIST__NONE != lt && n->norm->Bl.type == LIST__NONE) {
			n->norm->Bl.type = lt;
			/* Set column information, too. */
			if (LIST_column == lt) {
				n->norm->Bl.ncols =
				    n->args->argv[i].sz;
				n->norm->Bl.cols = (void *)
				    n->args->argv[i].value;
			}
d713 12
a724 8
		if (n->norm->Bl.type == LIST__NONE)
			if (n->norm->Bl.width ||
			    n->norm->Bl.offs ||
			    n->norm->Bl.comp)
				mandoc_msg(MANDOCERR_BL_LATETYPE,
				    mdoc->parse, n->line, n->pos,
				    mdoc_argnames[n->args->argv[0].arg]);
		continue;
d744 1
a744 1
			mdoc_nmsg(mdoc, n, MANDOCERR_BL_WIDTH);
d846 2
d849 1
a849 8
		/* Check whether a type has already been assigned. */

		if (DISP__NONE != dt && n->norm->Bd.type != DISP__NONE)
			mdoc_nmsg(mdoc, n, MANDOCERR_DISPREP);

		/* Make our type assignment. */

		if (DISP__NONE != dt && n->norm->Bd.type == DISP__NONE)
d851 4
d1221 2
a1222 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADATT);
d1425 2
a1426 4
	else if (0 == (width = macro2len(tok)))  {
		mdoc_nmsg(mdoc, n, MANDOCERR_BADWIDTH);
		return(1);
	}
d1657 5
d1663 2
a1664 2
	if (NULL == mdoc->last->child) {
		if (MDOC_Sm == mdoc->last->tok)
d1671 1
a1671 1
	assert(MDOC_TEXT == mdoc->last->child->type);
d1673 2
a1674 2
	if (0 == strcmp(mdoc->last->child->string, "on")) {
		if (MDOC_Sm == mdoc->last->tok)
d1678 2
a1679 2
	if (0 == strcmp(mdoc->last->child->string, "off")) {
		if (MDOC_Sm == mdoc->last->tok)
d1684 4
a1687 2
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADBOOL);
	return(1);
d1723 1
a1723 1
	struct mdoc_node	 *ch;
d1726 4
a1729 1
	if (NULL == (ch = mdoc->last->child)) {
d1731 2
a1732 3
		    mdoc->last->line, mdoc->last->pos,
		    mdoc_macronames[mdoc->last->tok]);
		mdoc_node_delete(mdoc, mdoc->last);
d1736 1
a1736 1
	assert(MDOC_TEXT == ch->type);
d1738 4
a1741 3
	if (NULL == (p = mdoc_a2st(ch->string))) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADSTANDARD);
		mdoc_node_delete(mdoc, mdoc->last);
d1743 2
a1744 2
		free(ch->string);
		ch->string = mandoc_strdup(p);
@


1.226
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.225 2014/07/04 01:50:07 schwarze Exp $ */
d597 3
a599 2
	int		  i, comp, dup;
	const char	 *offs, *width;
a600 1
	struct mdoc_node *np;
d622 1
d624 1
a624 3
		dup = comp = 0;
		width = offs = NULL;
		switch (n->args->argv[i].arg) {
d661 5
a665 2
			dup = n->norm->Bl.comp;
			comp = 1;
d668 5
a672 4
			/* NB: this can be empty! */
			if (n->args->argv[i].sz) {
				width = n->args->argv[i].value[0];
				dup = (NULL != n->norm->Bl.width);
d675 6
a680 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
d683 4
a686 4
			/* NB: this can be empty! */
			if (n->args->argv[i].sz) {
				offs = n->args->argv[i].value[0];
				dup = (NULL != n->norm->Bl.offs);
d689 6
a694 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
a699 12
		/* Check: duplicate auxiliary arguments. */

		if (dup)
			mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP);

		if (comp && ! dup)
			n->norm->Bl.comp = comp;
		if (offs && ! dup)
			n->norm->Bl.offs = offs;
		if (width && ! dup)
			n->norm->Bl.width = width;

d783 3
a785 1
	int		  i, dup, comp;
a786 2
	const char	 *offs;
	struct mdoc_node *np;
d802 1
a803 2
		dup = comp = 0;
		offs = NULL;
d805 1
a805 1
		switch (n->args->argv[i].arg) {
d825 4
a828 4
			/* NB: this can be empty! */
			if (n->args->argv[i].sz) {
				offs = n->args->argv[i].value[0];
				dup = (NULL != n->norm->Bd.offs);
d831 6
a836 1
			mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV);
d839 5
a843 2
			comp = 1;
			dup = n->norm->Bd.comp;
a849 12
		/* Check whether we have duplicates. */

		if (dup)
			mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP);

		/* Make our auxiliary assignments. */

		if (offs && ! dup)
			n->norm->Bd.offs = offs;
		if (comp && ! dup)
			n->norm->Bd.comp = comp;

@


1.225
log
@Clean up messages related to missing arguments.
* Do not warn about empty -column cells, they seem valid to me.
* Downgrade empty item and missing -std from ERROR to WARNING.
* Hierarchical naming.
* Descriptive, not imperative style.
* Mention macro names, argument names, and fallbacks.
* Garbage collect some unreachable code in post_it().
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.224 2014/07/03 23:24:56 schwarze Exp $ */
a86 1
static	int	 hwarn_le1(POST_ARGS);
d139 1
a139 1
static	v_post	 posts_bf[] = { hwarn_le1, post_bf, NULL };
a516 6
static int
hwarn_le1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_LT, 2));
}

d994 1
a994 1
	struct mdoc_node *np;
d1021 1
a1021 4
	/*
	 * Cannot have both argument and parameter.
	 * If neither is specified, let it through with a warning.
	 */
d1023 7
a1029 6
	if (np->parent->args && np->child) {
		mdoc_nmsg(mdoc, np, MANDOCERR_SYNTARGVCOUNT);
		return(0);
	} else if (NULL == np->parent->args && NULL == np->child) {
		mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE);
		return(1);
d1031 3
d1059 3
a1061 1
		mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE);
d1094 1
d1096 6
a1101 2
	if (mdoc->last->child)
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST);
d1315 3
a1317 1
			mdoc_nmsg(mdoc, nit, MANDOCERR_ARGSLOST);
@


1.224
log
@Fix formatting of empty .Bl -inset item heads.
Downgrade empty item heads from ERROR to WARNING.
Show the list type in the error message.
Choose better variable names for nodes in post_it().
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.223 2014/07/02 20:19:11 schwarze Exp $ */
d730 3
a732 2
				mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST);

d739 1
a739 1
		mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE);
d753 1
a753 1
			mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG);
d873 1
a873 1
		mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE);
d938 2
a939 1
	mdoc_nmsg(mdoc, n, MANDOCERR_NOARGV);
a1284 5
	if (LIST__NONE == lt) {
		mdoc_nmsg(mdoc, nit, MANDOCERR_LISTTYPE);
		return(1);
	}

d1308 3
a1310 1
			mdoc_nmsg(mdoc, nit, MANDOCERR_NOBODY);
a1320 3
		if (NULL == nit->body->child)
			mdoc_nmsg(mdoc, nit, MANDOCERR_NOBODY);

d1336 1
a1336 1
		break;
@


1.223
log
@Improve and test the messages about empty macros,
in particular reporting the macro names involved.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.222 2014/07/02 19:55:10 schwarze Exp $ */
d1273 1
a1273 1
	struct mdoc_node *n, *c;
d1276 2
a1277 1
	if (MDOC_BLOCK != mdoc->last->type)
d1280 2
a1281 2
	n = mdoc->last->parent->parent;
	lt = n->norm->Bl.type;
d1284 1
a1284 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_LISTTYPE);
d1290 1
a1290 5
		if (mdoc->last->head->child)
			break;
		/* FIXME: give this a dummy value. */
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS);
		break;
d1298 4
a1301 2
		if (NULL == mdoc->last->head->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS);
d1310 2
a1311 2
		if (NULL == mdoc->last->body->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY);
d1314 2
a1315 2
		if (mdoc->last->head->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST);
d1318 1
a1318 1
		cols = (int)n->norm->Bl.ncols;
d1320 1
a1320 1
		assert(NULL == mdoc->last->head->child);
d1322 2
a1323 2
		if (NULL == mdoc->last->body->child)
			mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY);
d1325 2
a1326 2
		for (i = 0, c = mdoc->last->child; c; c = c->next)
			if (MDOC_BODY == c->type)
d1336 1
a1336 2
		mandoc_vmsg(er, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos,
@


1.222
log
@When .Sm is called without an argument, groff toggles the spacing mode,
so let us do the same for compatibility.  Using this feature is of
course not recommended except in manual page obfuscation contests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.221 2014/07/02 13:10:45 schwarze Exp $ */
d1732 3
a1734 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_MACROEMPTY);
@


1.221
log
@Disentangle the MANDOCERR_CHILD message, which reported three
completely different things, into three distinct messages.
Also mention the macro names we are talking about.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.220 2014/07/02 11:43:20 schwarze Exp $ */
d1671 2
a1672 2
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_MACROEMPTY);
		mdoc_node_delete(mdoc, mdoc->last);
d1675 2
a1676 1
	check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 1);
@


1.220
log
@Clean up warnings related to macros and nesting.
* Hierarchical naming of enum mandocerr items.
* Improve the wording to make it comprehensible.
* Mention the offending macro.
* Garbage collect one chunk of ancient, long unreachable code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.219 2014/07/02 05:52:25 schwarze Exp $ */
d1120 2
a1121 1
			mdoc_nmsg(mdoc, n, MANDOCERR_CHILD);
d1617 3
a1619 1
		mdoc_nmsg(mdoc, nchild, MANDOCERR_CHILD);
d1788 2
a1789 1
		mdoc_nmsg(mdoc, nn, MANDOCERR_CHILD);
@


1.219
log
@Improve "skipping paragraph macro" messages,
showing which macro was skipped and before or after what.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.218 2014/07/02 03:48:07 schwarze Exp $ */
d594 3
a596 1
		mdoc_nmsg(mdoc, n, MANDOCERR_NESTEDDISP);
d1908 1
a1908 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_IGNNS);
@


1.218
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.217 2014/07/01 22:37:15 schwarze Exp $ */
d1388 3
a1390 1
				mdoc_nmsg(mdoc, nc, MANDOCERR_MOVEPAR);
d1395 4
a1398 1
				mdoc_nmsg(mdoc, nc, MANDOCERR_IGNPAR);
d2086 4
a2089 1
			mdoc_nmsg(mdoc, np, MANDOCERR_IGNPAR);
d2095 4
a2098 1
			mdoc_nmsg(mdoc, np, MANDOCERR_IGNPAR);
d2130 4
a2133 1
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_IGNPAR);
d2141 1
d2147 3
a2149 3
	if (NULL == mdoc->last->prev) {
		if (MDOC_Sh != mdoc->last->parent->tok &&
		    MDOC_Ss != mdoc->last->parent->tok)
d2152 1
a2152 2
		if (MDOC_Pp != mdoc->last->prev->tok &&
		    MDOC_Lp != mdoc->last->prev->tok &&
d2154 1
a2154 2
		     (MDOC_sp != mdoc->last->prev->tok &&
		      MDOC_br != mdoc->last->prev->tok)))
d2158 4
a2161 1
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_IGNPAR);
@


1.217
log
@Clean up the warnings related to document structure.
* Hierarchical naming of the related enum mandocerr items.
* Mention the offending macro, section title, or string.
While here, improve some wordings:
* Descriptive instead of imperative style.
* Uniform style for "missing" and "skipping".
* Where applicable, mention the fallback used.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.216 2014/06/20 23:02:31 schwarze Exp $ */
d101 2
d130 1
d151 2
d181 1
d223 1
a223 1
	{ NULL, NULL },				/* Ot */
d293 1
a293 1
	{ NULL, NULL },				/* Fr */
d303 2
a304 2
	{ NULL, NULL },				/* Es */
	{ NULL, NULL },				/* En */
d940 10
d1249 17
@


1.216
log
@As suggested by jmc@@, only include line and column numbers into messages
when they are meaningful, to avoid confusing stuff like this:
$ mandoc /dev/null
mandoc: /dev/null:0:1: FATAL: not a manual
Instead, just say:
mandoc: /dev/null: FATAL: not a manual

Another example this applies to is documents having a prologue,
but lacking a body.  Do not throw a FATAL error for these; instead,
issue a WARNING and show the empty document, in the man(7) case with
the same amount of blank lines as groff does.  Also downgrade mdoc(7)
documents having content before the first .Sh from FATAL to WARNING.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.215 2014/06/20 17:24:00 schwarze Exp $ */
d938 2
a939 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_ORDER);
d942 2
a943 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_REP);
d953 2
a954 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_ORDER);
d957 2
a958 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_REP);
d968 2
a969 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_ORDER);
d972 2
a973 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOG_REP);
d1673 4
a1676 3
	else if (MDOC_BLOCK != n->child->type ||
	    MDOC_Sh != n->child->tok)
		mdoc_nmsg(mdoc, n->child, MANDOCERR_SEC_BEFORE);
d1899 2
a1900 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC);
d1909 2
a1910 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC);
d1917 2
a1918 1
	mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC);
d1926 1
d1945 2
a1946 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NAMESECFIRST);
d1989 2
a1990 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECREP);
d1993 2
a1994 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECOOO);
d2004 1
d2009 1
d2018 2
d2024 5
a2028 2
		mandoc_msg(MANDOCERR_SECMSEC, mdoc->parse,
		    mdoc->last->line, mdoc->last->pos, secname);
d2193 1
a2193 1
	/* First make all characters uppercase. */
d2199 4
a2202 6

			/*
			 * FIXME: don't be lazy: have this make all
			 * characters be uppercase and just warn once.
			 */
			mdoc_nmsg(mdoc, nn, MANDOCERR_TITLE_CASE);
d2246 2
a2247 1
		mdoc_nmsg(mdoc, n, MANDOCERR_MSEC_BAD);
d2269 2
a2270 1
			mdoc_nmsg(mdoc, nn, MANDOCERR_ARCH_BAD);
@


1.215
log
@Start systematic improvements of error reporting.
So far, this covers all WARNINGs related to the prologue.

1) hierarchical naming of MANDOCERR_* constants
2) mention the macro name in messages where that adds clarity
3) add one missing MANDOCERR_DATE_MISSING msg
4) fix the wording of one message related to the man(7) prologue

Started on the plane back from Ottawa.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.214 2014/04/23 21:06:41 schwarze Exp $ */
d1648 1
a1648 1
	int		  erc;
d1651 1
a1651 1
	erc = 0;
d1656 1
a1656 1
		erc++;
d1665 5
a1669 9
	if (NULL == n->child) {
		erc++;
		mdoc_nmsg(mdoc, n, MANDOCERR_NODOCBODY);
	} else if (MDOC_BLOCK != n->child->type ||
	    MDOC_Sh != n->child->tok) {
		erc++;
		/* Can this be lifted?  See rxdebug.1 for example. */
		mdoc_nmsg(mdoc, n, MANDOCERR_NODOCBODY);
	}
d1671 1
a1671 1
	return(erc ? 0 : 1);
@


1.214
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.213 2014/04/23 16:08:33 schwarze Exp $ */
d938 1
a938 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO);
d941 1
a941 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP);
d951 1
a951 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO);
d954 1
a954 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP);
d964 1
a964 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO);
d967 1
a967 1
		mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP);
d2187 1
a2187 1
			mdoc_nmsg(mdoc, nn, MANDOCERR_UPPERCASE);
d2231 1
a2231 1
		mdoc_nmsg(mdoc, n, MANDOCERR_BADMSEC);
d2253 1
a2253 1
			mdoc_nmsg(mdoc, nn, MANDOCERR_BADVOLARCH);
@


1.213
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.212 2014/04/20 20:48:53 schwarze Exp $ */
d1463 2
a1464 2
	n->args->argv = mandoc_realloc(n->args->argv,
	    n->args->argc * sizeof(struct mdoc_argv));
d1524 2
a1525 2
	np->args->argv[j].value = mandoc_malloc(
	    (size_t)mdoc->last->nchild * sizeof(char *));
@


1.212
log
@strlen+malloc+snprintf is error prone;
rewrite post_lb() to use asprintf(3) instead
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.211 2014/04/20 19:40:13 schwarze Exp $ */
d1186 3
a1188 3
	const char	 *p, *q;
	char		 *buf;
	size_t		  sz;
d1196 1
a1196 1
	if (NULL == mdoc->last->child)
d1199 2
a1200 7
	assert(MDOC_TEXT == mdoc->last->child->type);
	p = mdoc_a2att(mdoc->last->child->string);

	if (p) {
		free(mdoc->last->child->string);
		mdoc->last->child->string = mandoc_strdup(p);
	} else {
d1202 3
a1204 9
		p = "AT&T UNIX ";
		q = mdoc->last->child->string;
		sz = strlen(p) + strlen(q) + 1;
		buf = mandoc_malloc(sz);
		strlcpy(buf, p, sz);
		strlcat(buf, q, sz);
		free(mdoc->last->child->string);
		mdoc->last->child->string = buf;
	}
d1206 2
@


1.211
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.210 2014/04/20 16:46:05 schwarze Exp $ */
d1047 3
a1049 3
	const char	*p;
	char		*buf;
	size_t		 sz;
d1053 1
a1053 2
	assert(mdoc->last->child);
	assert(MDOC_TEXT == mdoc->last->child->type);
d1055 2
a1056 1
	p = mdoc_a2lib(mdoc->last->child->string);
d1058 5
a1062 9
	/* If lookup ok, replace with table value. */

	if (p) {
		free(mdoc->last->child->string);
		mdoc->last->child->string = mandoc_strdup(p);
		return(1);
	}

	/* If not, use "library ``xxxx''. */
d1064 2
a1065 7
	sz = strlen(mdoc->last->child->string) + 2 +
	     strlen("\\(lqlibrary\\(rq");
	buf = mandoc_malloc(sz);
	snprintf(buf, sz, "library \\(lq%s\\(rq",
	    mdoc->last->child->string);
	free(mdoc->last->child->string);
	mdoc->last->child->string = buf;
@


1.210
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.209 2014/04/15 00:41:09 schwarze Exp $ */
a47 2
#define	NUMSIZ	  32

d1389 1
a1389 1
	char		  buf[NUMSIZ];
d1421 1
a1421 1
	snprintf(buf, NUMSIZ, "%un", (unsigned int)width);
d1436 1
a1436 1
	char		  buf[NUMSIZ];
d1471 1
a1471 1
	snprintf(buf, NUMSIZ, "%un", (unsigned int)sz);
@


1.209
log
@Using macros in .Sh header lines, or having .Sm off or .Bk -words open
while processing .Sh, is not at all recommended, but it's not strictly
a syntax violation either, and in any case, mandoc must not die in an
assertion.  I broke this in rev. 1.124.

Crash found while trying to read the (rather broken) original 4.3BSD-Reno
od(1) manual page.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.208 2014/03/31 01:05:32 schwarze Exp $ */
d69 1
a69 1
static	int	 check_count(struct mdoc *, enum mdoc_type, 
d73 1
a73 1
static	void	 check_argv(struct mdoc *, 
d189 3
a191 3
	{ pres_sh, posts_sh },			/* Sh */ 
	{ pres_ss, posts_ss },			/* Ss */ 
	{ pres_pp, posts_pp },			/* Pp */ 
d196 1
a196 1
	{ pres_bl, posts_bl },			/* Bl */ 
d199 2
a200 2
	{ NULL, NULL },				/* Ad */ 
	{ pres_an, posts_an },			/* An */ 
d202 1
a202 1
	{ NULL, NULL },				/* Cd */ 
d204 5
a208 5
	{ NULL, NULL },				/* Dv */ 
	{ NULL, NULL },				/* Er */ 
	{ NULL, NULL },				/* Ev */ 
	{ pres_std, posts_std },		/* Ex */ 
	{ NULL, NULL },				/* Fa */ 
d211 4
a214 4
	{ NULL, NULL },				/* Fn */ 
	{ NULL, NULL },				/* Ft */ 
	{ NULL, NULL },				/* Ic */ 
	{ NULL, posts_text1 },			/* In */ 
d222 1
a222 1
	{ NULL, posts_st },			/* St */ 
d224 2
a225 2
	{ NULL, posts_vt },			/* Vt */ 
	{ NULL, posts_text },			/* Xr */ 
d240 1
a240 1
	{ NULL, posts_at },			/* At */ 
d252 2
a253 2
	{ NULL, NULL },				/* Ef */ 
	{ NULL, NULL },				/* Em */ 
d256 1
a256 1
	{ NULL, NULL },				/* Ms */ 
d274 1
a274 1
	{ NULL, posts_bool },			/* Sm */ 
d281 2
a282 2
	{ NULL, posts_fo },			/* Fo */ 
	{ NULL, NULL },				/* Fc */ 
d292 6
a297 6
	{ pres_pp, posts_pp },			/* Lp */ 
	{ NULL, NULL },				/* Lk */ 
	{ NULL, posts_defaults },		/* Mt */ 
	{ NULL, NULL },				/* Brq */ 
	{ NULL, NULL },				/* Bro */ 
	{ NULL, NULL },				/* Brc */ 
d355 1
d364 1
a364 1
	case (MDOC_TEXT):
d370 1
a370 1
	case (MDOC_TBL):
d372 1
a372 1
	case (MDOC_EQN):
d374 1
a374 1
	case (MDOC_ROOT):
d385 1
a385 1
		if ( ! (*p)(mdoc, n)) 
a389 1

d400 1
a400 1
	case (MDOC_TEXT):
d402 1
a402 1
	case (MDOC_EQN):
d404 1
a404 1
	case (MDOC_TBL):
d406 1
a406 1
	case (MDOC_ROOT):
d415 1
a415 1
		if ( ! (*p)(mdoc)) 
d422 1
a422 1
check_count(struct mdoc *mdoc, enum mdoc_type type, 
d430 1
a430 1
	
d432 1
a432 1
	case (CHECK_LT):
d437 1
a437 1
	case (CHECK_GT):
d442 1
a442 1
	case (CHECK_EQ):
d453 3
a455 3
	mandoc_vmsg(t, mdoc->parse, mdoc->last->line, mdoc->last->pos,
			"want %s%d children (have %d)",
			p, val, mdoc->last->nchild);
d569 3
a571 3
	mandoc_vmsg(MANDOCERR_SYNTCHILD, mdoc->parse, n->line, 
			n->pos, "want parent %s", MDOC_ROOT == t ? 
			"<root>" : mdoc_macronames[tok]);
d584 1
a584 1
	for (node = mdoc->last->parent; node; node = node->parent) 
a594 1

d616 1
a616 1
	/* 
a621 1
	/* LINTED */
d628 1
a628 1
		case (MDOC_Bullet):
d631 1
a631 1
		case (MDOC_Dash):
d634 1
a634 1
		case (MDOC_Enum):
d637 1
a637 1
		case (MDOC_Hyphen):
d640 1
a640 1
		case (MDOC_Item):
d643 1
a643 1
		case (MDOC_Tag):
d646 1
a646 1
		case (MDOC_Diag):
d649 1
a649 1
		case (MDOC_Hang):
d652 1
a652 1
		case (MDOC_Ohang):
d655 1
a655 1
		case (MDOC_Inset):
d658 1
a658 1
		case (MDOC_Column):
d662 1
a662 1
		case (MDOC_Compact):
d666 1
a666 1
		case (MDOC_Width):
d675 1
a675 1
		case (MDOC_Offset):
d711 2
a712 2
				n->norm->Bl.ncols = 
					n->args->argv[i].sz;
d714 1
a714 1
					n->args->argv[i].value;
d721 3
a723 3
			if (n->norm->Bl.width || 
					n->norm->Bl.offs || 
					n->norm->Bl.comp)
d736 1
a736 1
	/* 
d744 1
a744 1
	case (LIST_tag):
d748 1
a748 1
	case (LIST_column):
d750 1
a750 1
	case (LIST_diag):
d752 1
a752 1
	case (LIST_ohang):
d754 1
a754 1
	case (LIST_inset):
d756 1
a756 1
	case (LIST_item):
d760 1
a760 1
	case (LIST_bullet):
d762 1
a762 1
	case (LIST_dash):
d764 1
a764 1
	case (LIST_hyphen):
d768 1
a768 1
	case (LIST_enum):
a778 1

d783 1
a783 1
	enum mdoc_disp 	  dt;
a799 1
	/* LINTED */
d806 1
a806 1
		case (MDOC_Centred):
d809 1
a809 1
		case (MDOC_Ragged):
d812 1
a812 1
		case (MDOC_Unfilled):
d815 1
a815 1
		case (MDOC_Filled):
d818 1
a818 1
		case (MDOC_Literal):
d821 1
a821 1
		case (MDOC_File):
d824 1
a824 1
		case (MDOC_Offset):
d833 1
a833 1
		case (MDOC_Compact):
a872 1

a881 1

a890 1

a900 1

d908 1
a908 1
	
d910 2
a911 2
		mdoc_pmsg(mdoc, n->args->argv[i].line, 
			n->args->argv[i].pos, MANDOCERR_IGNARGV);
a973 1

d991 1
a991 1
		} else 
d1004 1
a1004 1
	/* 
d1006 1
a1006 1
	 * If neither is specified, let it through with a warning. 
d1018 1
a1018 1
	
d1040 1
a1040 1
	else 
d1070 2
a1071 2
	sz = strlen(mdoc->last->child->string) +
		2 + strlen("\\(lqlibrary\\(rq");
d1073 2
a1074 2
	snprintf(buf, sz, "library \\(lq%s\\(rq", 
			mdoc->last->child->string);
a1088 1

d1104 1
a1104 1
	
d1106 1
a1106 1
		if (MDOC_TEXT != n->type) 
a1111 1

d1131 1
a1131 1
	
d1158 1
a1158 1
	
d1163 1
a1163 1
	case (MDOC_Ar):
d1169 1
a1169 1
	case (MDOC_At):
d1175 1
a1175 1
	case (MDOC_Li):
d1179 1
a1179 1
	case (MDOC_Pa):
d1181 1
a1181 1
	case (MDOC_Mt):
d1188 1
a1188 1
	} 
d1206 1
a1206 1
	
a1245 1

d1266 1
a1266 1
	case (LIST_tag):
d1272 1
a1272 1
	case (LIST_hang):
d1274 1
a1274 1
	case (LIST_ohang):
d1276 1
a1276 1
	case (LIST_inset):
d1278 1
a1278 1
	case (LIST_diag):
d1282 1
a1282 1
	case (LIST_bullet):
d1284 1
a1284 1
	case (LIST_dash):
d1286 1
a1286 1
	case (LIST_enum):
d1288 1
a1288 1
	case (LIST_hyphen):
d1292 1
a1292 1
	case (LIST_item):
d1296 1
a1296 1
	case (LIST_column):
d1315 3
a1317 3
		mandoc_vmsg(er, mdoc->parse, mdoc->last->line, 
				mdoc->last->pos, 
				"columns == %d (have %d)", cols, i);
d1327 1
a1327 1
post_bl_block(POST_ARGS) 
d1341 2
a1342 2
	if (LIST_tag == n->norm->Bl.type && 
			NULL == n->norm->Bl.width) {
d1358 1
a1358 1
			case (MDOC_Pp):
d1360 1
a1360 1
			case (MDOC_Lp):
d1362 1
a1362 1
			case (MDOC_br):
d1417 1
a1417 1
	for (i = 0; i < (int)n->args->argc; i++) 
d1469 1
a1469 1
	} 
d1483 2
a1484 2
	n->args->argv = mandoc_realloc(n->args->argv, 
			n->args->argc * sizeof(struct mdoc_argv));
a1497 1

d1499 1
a1499 1
post_bl_head(POST_ARGS) 
d1516 1
a1516 1
	/* 
d1530 1
a1530 1
	for (j = 0; j < (int)np->args->argc; j++) 
d1544 2
a1545 2
	np->args->argv[j].value = mandoc_malloc
		((size_t)mdoc->last->nchild * sizeof(char *));
d1573 1
a1573 1
	case (MDOC_BLOCK):
d1575 1
a1575 1
	case (MDOC_HEAD):
d1577 1
a1577 1
	case (MDOC_BODY):
d1682 1
a1682 1
	
d1688 2
a1689 2
	} else if (MDOC_BLOCK != n->child->type || 
			MDOC_Sh != n->child->tok) {
d1730 1
a1730 1
	case (MDOC_HEAD):
d1733 1
a1733 1
	case (MDOC_BODY):
d1787 1
a1787 1
		/* 
d1793 1
a1793 1
		
d1802 1
a1802 1
		/* 
d1851 1
a1851 1
	case (MDOC_HEAD):
d1855 1
a1855 1
	case (MDOC_BODY):
d1859 1
a1859 1
	case (MDOC_ELEM):
d2015 1
a2015 1
	case (SEC_ERRORS):
d2019 1
a2019 1
	case (SEC_RETURN_VALUES):
d2021 1
a2021 1
	case (SEC_LIBRARY):
d2027 1
a2027 1
	case (SEC_CONTEXT):
d2073 1
a2073 1
	/* 
d2133 1
a2133 1
	case (MDOC_Dl):
d2136 1
a2136 1
	case (MDOC_Bd):
d2146 1
a2146 1
	
d2203 1
a2203 1
			/* 
d2211 2
a2212 2
	/* Handles: `.Dt' 
	 *   --> title = unknown, volume = local, msec = 0, arch = NULL
d2224 2
a2225 2
	/* Handles: `.Dt TITLE' 
	 *   --> title = TITLE, volume = local, msec = 0, arch = NULL
d2228 2
a2229 2
	mdoc->meta.title = mandoc_strdup
		('\0' == nn->string[0] ? "UNKNOWN" : nn->string);
d2240 4
a2243 4
	 *   --> title = TITLE, volume = SEC is msec ? 
	 *           format(msec) : SEC,
	 *       msec = SEC is msec ? atoi(msec) : 0,
	 *       arch = NULL
d2254 1
a2254 1
	} 
d2260 4
a2263 4
	 *   --> title = TITLE, volume = VOL is vol ?
	 *       format(VOL) : 
	 *           VOL is arch ? format(arch) : 
	 *               VOL
d2276 1
a2276 1
		} else 
d2278 1
a2278 1
	}	
d2307 1
a2307 1
	/* 
d2315 1
a2315 2
		*n->string = (char)toupper
			((unsigned char)*n->string);
d2338 1
a2338 1
 	 */
d2357 2
a2358 2
                        defbuf = mandoc_strdup("UNKNOWN");
                } else
d2385 1
a2385 1
	
d2396 1
a2396 1
static enum mdoc_sec 
d2401 1
a2401 1
	for (i = 0; i < (int)SEC__MAX; i++) 
d2413 1
a2413 1
	case(MDOC_Ad):
d2415 1
a2415 1
	case(MDOC_Ao):
d2417 1
a2417 1
	case(MDOC_An):
d2419 1
a2419 1
	case(MDOC_Aq):
d2421 1
a2421 1
	case(MDOC_Ar):
d2423 1
a2423 1
	case(MDOC_Bo):
d2425 1
a2425 1
	case(MDOC_Bq):
d2427 1
a2427 1
	case(MDOC_Cd):
d2429 1
a2429 1
	case(MDOC_Cm):
d2431 1
a2431 1
	case(MDOC_Do):
d2433 1
a2433 1
	case(MDOC_Dq):
d2435 1
a2435 1
	case(MDOC_Dv):
d2437 1
a2437 1
	case(MDOC_Eo):
d2439 1
a2439 1
	case(MDOC_Em):
d2441 1
a2441 1
	case(MDOC_Er):
d2443 1
a2443 1
	case(MDOC_Ev):
d2445 1
a2445 1
	case(MDOC_Fa):
d2447 1
a2447 1
	case(MDOC_Fl):
d2449 1
a2449 1
	case(MDOC_Fo):
d2451 1
a2451 1
	case(MDOC_Fn):
d2453 1
a2453 1
	case(MDOC_Ic):
d2455 1
a2455 1
	case(MDOC_Li):
d2457 1
a2457 1
	case(MDOC_Ms):
d2459 1
a2459 1
	case(MDOC_Nm):
d2461 1
a2461 1
	case(MDOC_No):
d2463 1
a2463 1
	case(MDOC_Oo):
d2465 1
a2465 1
	case(MDOC_Op):
d2467 1
a2467 1
	case(MDOC_Pa):
d2469 1
a2469 1
	case(MDOC_Pf):
d2471 1
a2471 1
	case(MDOC_Po):
d2473 1
a2473 1
	case(MDOC_Pq):
d2475 1
a2475 1
	case(MDOC_Ql):
d2477 1
a2477 1
	case(MDOC_Qo):
d2479 1
a2479 1
	case(MDOC_So):
d2481 1
a2481 1
	case(MDOC_Sq):
d2483 1
a2483 1
	case(MDOC_Sy):
d2485 1
a2485 1
	case(MDOC_Sx):
d2487 1
a2487 1
	case(MDOC_Tn):
d2489 1
a2489 1
	case(MDOC_Va):
d2491 1
a2491 1
	case(MDOC_Vt):
d2493 1
a2493 1
	case(MDOC_Xr):
@


1.208
log
@Support the CONTEXT section for kernel manual pages found in Solaris and
OpenBSD manuals.  It describes which contexts you can call functions in.
from dlg@@, ok jmc@@ deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.207 2014/03/30 23:28:06 schwarze Exp $ */
d1953 1
a1953 1
	const char	*secname;
d1965 2
a1966 9
	n = mdoc->last;
	if (n->child) {
		assert(1 == n->nchild);
		n = n->child;
		assert(NULL != n);
		assert(MDOC_TEXT == n->type);
		secname = n->string;
		sec = a2sec(secname);
	}
d2003 2
a2004 1
	if (SEC_CUSTOM == sec)
d2006 1
d2050 1
@


1.207
log
@Allow ERRORS in section 4; OpenBSD rev. 1.121.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.121 2014/02/16 14:26:51 schwarze Exp $ */
d335 1
d2044 2
@


1.206
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.205 2014/03/23 15:14:50 schwarze Exp $ */
d2032 4
a2037 2
	case (SEC_ERRORS):
		/* FALLTHROUGH */
@


1.205
log
@Retire the old concat() function.
For .Sh, i wasn't even needed at all.
For .Dd, .Nm, and .Os, use the new mdoc_deroff() instead.
This gets rid of the last limited-size static buffers in this file,
hence eliminates the last explicit MANDOCERR_MEM throwers here,
and it shortens the code by 50 lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.204 2014/03/23 12:11:18 schwarze Exp $ */
d307 1
@


1.204
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.203 2014/03/23 11:25:26 schwarze Exp $ */
a48 1
#define	DATESIZE  32
a75 1
static	int	 concat(char *, const struct mdoc_node *, size_t);
a1123 2
	char		 buf[BUFSIZ];
	int		 c;
d1128 1
a1128 1
	/* Try to use our children for setting the meta name. */
d1130 1
a1130 11
	if (NULL != mdoc->last->child) {
		buf[0] = '\0';
		c = concat(buf, mdoc->last->child, BUFSIZ);
	} else
		c = 0;

	switch (c) {
	case (-1):
		mdoc_nmsg(mdoc, mdoc->last->child, MANDOCERR_MEM);
		return(0);
	case (0):
a1132 4
		break;
	default:
		mdoc->meta.name = mandoc_strdup(buf);
		break;
a1949 1
	char		 buf[BUFSIZ];
d1951 1
a1952 1
	int		 c;
d1961 1
d1963 9
a1971 6
	buf[0] = '\0';
	if (-1 == (c = concat(buf, mdoc->last->child, BUFSIZ))) {
		mdoc_nmsg(mdoc, mdoc->last->child, MANDOCERR_MEM);
		return(0);
	} else if (1 == c)
		sec = a2sec(buf);
d2043 1
a2043 1
				mdoc->last->line, mdoc->last->pos, buf);
a2163 1
	char		  buf[DATESIZE];
d2165 1
a2165 1
	int		  c;
d2177 8
a2184 4
	buf[0] = '\0';
	if (-1 == (c = concat(buf, n->child, DATESIZE))) {
		mdoc_nmsg(mdoc, n->child, MANDOCERR_MEM);
		return(0);
a2185 5

	assert(c);
	mdoc->meta.date = mdoc->quick ? mandoc_strdup(buf) :
	    mandoc_normdate(mdoc->parse, buf, n->line, n->pos);

a2334 1
	char		  buf[BUFSIZ];
a2339 1
	int		  c;
d2353 3
a2355 11

	buf[0] = '\0';
	if (-1 == (c = concat(buf, n->child, BUFSIZ))) {
		mdoc_nmsg(mdoc, n->child, MANDOCERR_MEM);
		return(0);
	}

	assert(c);

	if ('\0' != *buf) {
		mdoc->meta.os = mandoc_strdup(buf);
a2356 1
	}
a2407 23
/*
 * Concatenate a node, stopping at the first non-text.
 * Concatenation is separated by a single whitespace.  
 * Returns -1 on fatal (string overrun) error, 0 if child nodes were
 * encountered, 1 otherwise.
 */
static int
concat(char *p, const struct mdoc_node *n, size_t sz)
{

	for ( ; NULL != n; n = n->next) {
		if (MDOC_TEXT != n->type) 
			return(0);
		if ('\0' != p[0] && strlcat(p, " ", sz) >= sz)
			return(-1);
		if (strlcat(p, n->string, sz) >= sz)
			return(-1);
		concat(p, n->child, sz);
	}

	return(1);
}

@


1.203
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.202 2014/01/11 22:16:10 schwarze Exp $ */
d2398 3
a2400 5
                } else if (-1 == asprintf(&defbuf, "%s %s",
		    utsname.sysname, utsname.release)) {
			perror(NULL);
			exit((int)MANDOCLEVEL_SYSERR);
		}
@


1.202
log
@Remove useless use of strnlen(3).
Yuckiness pointed out by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.201 2014/01/07 09:10:45 schwarze Exp $ */
d39 1
@


1.201
log
@Cache the result of uname(3) such that we don't need to call it
over and over again for each manual; found with gprof(1).
Speeds up mandocdb(8) -Q by 3%, now at 39.5% of makewhatis(8).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.200 2014/01/06 22:39:25 schwarze Exp $ */
d1897 1
a1897 1
		if (3 > strnlen(cp, 3))
@


1.200
log
@Another 18% speedup for mandocdb(8) -Q, found by gprof(1).
In -Q mode, refrain form validating and normalizing the format
of the date given in .Dd or .TH, as it won't be used anyway.

For /usr/share/man, mandocdb -Q now takes 45% of the time of makewhatis(8).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.199 2014/01/06 00:53:33 schwarze Exp $ */
a2350 1
	struct mdoc_node *n;
a2351 1
	int		  c;
d2354 1
d2356 2
d2380 10
a2389 5
	if ('\0' == buf[0]) {
		if (mdoc->defos) {
			mdoc->meta.os = mandoc_strdup(mdoc->defos);
			return(1);
		}
d2391 1
a2391 4
		if (strlcat(buf, OSNAME, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
d2393 1
d2396 5
a2400 15
                        mdoc->meta.os = mandoc_strdup("UNKNOWN");
                        return(post_prol(mdoc));
                }

		if (strlcat(buf, utsname.sysname, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, " ", BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, utsname.release, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
d2402 2
a2404 3
	}

	mdoc->meta.os = mandoc_strdup(buf);
@


1.199
log
@Joerg Sonnenberger contributed copyrightable amounts of text to
some files.  To make it clear that he also put his contributions
under the ISC license, with his explicit permission, add his
Copyright notice to the relevant files.  No code change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.198 2013/12/15 21:23:52 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d2187 2
a2188 2
		mdoc->meta.date = mandoc_normdate
			(mdoc->parse, NULL, n->line, n->pos);
d2199 2
a2200 2
	mdoc->meta.date = mandoc_normdate
		(mdoc->parse, buf, n->line, n->pos);
@


1.198
log
@The "value" argument to the roff(7) .nr requests ends right before
the first non-digit character.  While here, implement and document
an optional sign, requesting increment or decrement, as documented
in the Ossanna/Kernighan/Ritter troff manual and supported by groff.

Reported by bentley@@ on discuss@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.197 2013/10/21 23:47:58 schwarze Exp $ */
d5 1
@


1.197
log
@There are three kinds of input lines: text lines, macros taking
positional arguments (like Dt Fn Xr) and macros taking text as
arguments (like Nd Sh Em %T An).  In the past, even the latter put
each word of their arguments into its own MDOC_TEXT node; instead,
concatenate arguments unless delimiters, keeps or spacing mode
prevent that.  Regarding mandoc(1), this is internal refactoring,
no output change intended.

Regarding mandocdb(8), this fixes yet another regression introduced
when switching from DB to SQLite: The ability to search for strings
crossing word boundaries was lost and is hereby restored.  At the
same time, database sizes and build times are both reduced by a bit
more than 5% each.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.196 2013/10/06 22:46:15 schwarze Exp $ */
d1994 1
a1994 1
		roff_setreg(mdoc->roff, "nS", 1);
d1997 1
a1997 1
		roff_setreg(mdoc->roff, "nS", 0);
@


1.196
log
@We don't do hyphenation, but we allow breaking the line at hyphens that are
already there in the middle of words.  So far, we only allowed this on text
lines.  Now it turns out some macros allow this for their arguments, too,
in particular .Nd and most of the .%? citation macros.

Issue found by Franco Fichtner <franco at lastsummer dot de> while doing
systematic groff-mandoc comparisons in the DragonFly base system, THANKS!

While here, garbage collect two empty prevalidator function pointer lists
and sort a couple of function declarations.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.195 2013/10/06 13:32:46 schwarze Exp $ */
d1677 3
a1679 1
	if (0 == strcmp(mdoc->last->child->string, "on"))
d1681 4
a1684 1
	if (0 == strcmp(mdoc->last->child->string, "off"))
d1686 1
@


1.195
log
@If there is random stuff inside a .Bl block body before the first .It,
do not throw a FATAL error and do not die, but just throw a WARNING
and move the stuff out of the .Bl block.

This bug felt completely 2008-ish; meanwhile, such bugs from the
Kristaps-doesnt-like-syntax-errors-so-lets-just-give-up--Era
are becoming rare, but this was one of the last survivors.

Thanks to bentley@@ for reminding me to finally fix this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.194 2013/10/05 22:08:12 schwarze Exp $ */
d22 1
a22 1
#ifndef	OSNAME
d100 1
a102 2
static	int	 post_defaults(POST_ARGS);
static	int	 post_literal(POST_ARGS);
d104 2
d108 1
a112 1
static	int	 post_ignpar(POST_ARGS);
d146 1
d151 2
d155 1
a155 1
static	v_post	 posts_nd[] = { berr_ge1, NULL };
d162 1
a162 1
static	v_post	 posts_sh[] = { post_ignpar, hwarn_ge1, post_sh, NULL };
d164 1
a164 1
static	v_post	 posts_ss[] = { post_ignpar, hwarn_ge1, NULL };
a169 1
static	v_post	 posts_wline[] = { bwarn_ge1, NULL };
a176 2
static	v_pre	 pres_er[] = { NULL, NULL };
static	v_pre	 pres_fd[] = { NULL, NULL };
d192 1
a192 1
	{ pres_d1, posts_wline },		/* D1 */
d205 1
a205 1
	{ pres_er, NULL },			/* Er */ 
d209 1
a209 1
	{ pres_fd, posts_text },		/* Fd */
d227 1
a227 1
	{ NULL, posts_text },			/* %B */ /* FIXME: can be used outside Rs/Re. */
d231 2
a232 2
	{ NULL, posts_text },			/* %N */
	{ NULL, posts_text },			/* %O */
d234 2
a235 2
	{ NULL, posts_text },			/* %R */
	{ NULL, posts_text },			/* %T */ /* FIXME: can be used outside Rs/Re. */
d275 1
a275 1
	{ NULL, NULL },				/* Sx */
d1860 41
@


1.194
log
@Support setting arbitrary roff(7) number registers,
preserving read support for the ".nr nS" SYNOPSIS state register.

Inspired by NetBSD roff.c rev. 1.18 (Christos Zoulas, March 21, 2013),
but implemented differently.  I don't want to have yet another different
implementation of a hash table in mandoc - it would be the second one
in roff.c alone and the fifth one in mandoc grand total.
Instead, i designed and implemented roff_setreg() and roff_getreg()
to be similar to roff_setstrn() and roff_getstrn().

Once we feel the need to optimize, we can introduce one common
hash table implementation for everything in mandoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.193 2013/09/16 00:25:07 schwarze Exp $ */
d1593 9
a1601 3
	struct mdoc_node	*n;

	if (MDOC_HEAD == mdoc->last->type) 
d1603 3
a1605 3
	if (MDOC_BLOCK == mdoc->last->type)
		return(post_bl_block(mdoc));
	if (MDOC_BODY != mdoc->last->type)
d1607 1
d1609 4
a1612 10
	for (n = mdoc->last->child; n; n = n->next) {
		switch (n->tok) {
		case (MDOC_Lp):
			/* FALLTHROUGH */
		case (MDOC_Pp):
			mdoc_nmsg(mdoc, n, MANDOCERR_CHILD);
			/* FALLTHROUGH */
		case (MDOC_It):
			/* FALLTHROUGH */
		case (MDOC_Sm):
a1613 2
		default:
			break;
d1616 42
a1657 2
		mdoc_nmsg(mdoc, n, MANDOCERR_SYNTCHILD);
		return(0);
@


1.193
log
@One of the WARNING messages has to use the word "section" twice in two
different meanings, that cannot be helped.  But we can make this less
confusing by stating that the second instance refers to stuff like (2),
(3), and (9), and by adding the sections header the first instance
refers to, for example ERRORS or RETURN VALUES.

Source for confusion noticed by Jan Stary <hans at stare dot cz>,
better wording suggested by jmc@@, tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.192 2013/08/05 14:36:01 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
a890 2

	roff_regunset(mdoc->roff, REG_nS);
d1906 2
a1907 1
	if (SEC_SYNOPSIS == sec)
d1909 2
a1910 1
	else
d1912 1
@


1.192
log
@Put .%C before .%D in .Rs output
because that's the usual order in formal citations.

My patch that was accepted into groff by Werner Lemberg
uses the same order, so keep groff and mandoc consistent.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.191 2012/11/17 00:26:33 schwarze Exp $ */
d1967 2
a1968 1
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECMSEC);
@


1.191
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.190 2012/11/16 22:21:05 schwarze Exp $ */
d322 1
d324 1
a324 2
	MDOC__O,
	MDOC__C
@


1.190
log
@Warn about unknown volume or arch in Dt macro arguments;
patch written by Nicolas Joly <njoly at pasteur dot fr>.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.189 2012/07/18 11:11:12 schwarze Exp $ */
d419 1
a419 1
check_count(struct mdoc *m, enum mdoc_type type, 
d425 1
a425 1
	if (m->last->type != type)
d431 1
a431 1
		if (m->last->nchild < val)
d436 1
a436 1
		if (m->last->nchild > val)
d441 1
a441 1
		if (val == m->last->nchild)
d450 1
a450 1
	mandoc_vmsg(t, m->parse, m->last->line, m->last->pos,
d452 1
a452 1
			p, val, m->last->nchild);
d518 1
a518 1
check_args(struct mdoc *m, struct mdoc_node *n)
d527 1
a527 1
		check_argv(m, n, &n->args->argv[i]);
d531 1
a531 1
check_argv(struct mdoc *m, struct mdoc_node *n, struct mdoc_argv *v)
d536 1
a536 1
		check_text(m, v->line, v->pos, v->value[i]);
d541 2
a542 2
		if ( ! (v->sz || m->meta.name))
			mdoc_nmsg(m, n, MANDOCERR_NONAME);
d546 1
a546 1
check_text(struct mdoc *m, int ln, int pos, char *p)
d550 1
a550 1
	if (MDOC_LITERAL & m->flags)
d554 1
a554 1
		mdoc_pmsg(m, ln, pos + (int)(p - cp), MANDOCERR_BADTAB);
@


1.189
log
@Fix handling of paragraph macros inside lists:
* When they are trailing the last item, move them outside the list.
* When they are trailing any other none-compact item, drop them.

OpenBSD rev. mdoc_validate.c 1.107, mdoc.c 1.91
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.188 2012/07/16 09:51:54 schwarze Exp $ */
a2207 1
		/* FIXME: warn about bad arch. */
d2210 1
@


1.188
log
@Several -mdoc parser improvements related to vertical spacing:
* So far, .Pp and .Lp were removed before paragraph type blocks.
* Now also remove .br before paragraph type blocks.
* Treat .Lp as a paragraph like .Pp, so remove .Pp, .Lp, .br before it.
* Do not treat .sp as a paragraph, don't remove anything before it.
* After .Sh, .Ss, .Pp, and .Lp, remove .Pp, .Lp, .sp, .br, and blank lines.
* After .sp and .br, remove .br.
OpenBSD rev. mdoc.c 1.89 and mdoc_validate.c 1.106
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.187 2012/07/12 15:11:14 schwarze Exp $ */
d1356 1
a1356 1
	struct mdoc_node *n;
d1372 1
d1376 2
a1377 2
	} else 
		return(1);
d1379 29
a1407 1
	assert(n->norm->Bl.width);
@


1.187
log
@The post_nm() validation function crashed when the first .Nm child node
was a non-text node.  Fix this by rewriting post_nm() to always set
the meta name to UNKNOWN when the name is missing or unusable.
While here, make MANDOCERR_NONAME an ERROR, as it usually renders
the page content unintelligible.

Bug reported by Maxim <Belooussov at gmail dot com>, thanks.
OpenBSD rev. 1.105
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.186 2012/07/11 16:57:43 schwarze Exp $ */
d110 1
d156 1
d159 1
a159 1
static	v_post	 posts_sp[] = { ewarn_le1, NULL };
d190 1
a190 1
	{ pres_pp, posts_notext },		/* Pp */ 
d291 1
a291 1
	{ NULL, posts_notext },			/* Lp */ 
d302 2
a303 2
	{ NULL, posts_notext },			/* br */
	{ pres_pp, posts_sp },			/* sp */
d1984 3
a1986 1
	if (MDOC_Pp != mdoc->last->tok && MDOC_Lp != mdoc->last->tok)
d2001 26
@


1.186
log
@fix position and formatting of %U;
OpenBSD rev. 1.104 and 1.145, respectively
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.185 2012/07/10 14:38:51 schwarze Exp $ */
d1126 2
a1127 1
	/* If no child specified, make sure we have the meta name. */
d1129 1
a1129 5
	if (NULL == mdoc->last->child && NULL == mdoc->meta.name) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NONAME);
		return(1);
	} else if (mdoc->meta.name)
		return(1);
d1131 5
a1135 1
	/* If no meta name, set it from the child. */
d1137 2
a1138 2
	buf[0] = '\0';
	if (-1 == (c = concat(buf, mdoc->last->child, BUFSIZ))) {
d1141 7
a1148 3

	assert(c);
	mdoc->meta.name = mandoc_strdup(buf);
@


1.185
log
@* implement -Tman .Bl -item -inset -diag -ohang -dash -hyphen -enum .It
* fix -Tman .Bl -bullet .It
* adjust the -Tascii .Bl -bullet -dash -hyphen .It
default and minimum width to new groff standards,
it changed from 4n (in groff 1.15) to 2n (in groff 1.21)
* same for -Tascii -enum, it changed from 5n to 2n
* use -hang formatting for -Tascii -enum -width 2n
* for -Tascii -enum, the default is -width 3n
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.184 2012/05/27 17:48:57 schwarze Exp $ */
d317 1
d322 1
a322 2
	MDOC__C,
	MDOC__U
@


1.184
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.183 2012/05/27 17:39:28 schwarze Exp $ */
d736 2
a737 1
	 * and must also be warned.
d742 2
a743 3
		if (n->norm->Bl.width)
			break;
		mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG);
d757 12
@


1.183
log
@update Copyright years according to the CVS logs; no code change
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.182 2012/03/23 05:50:25 kristaps Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d2195 6
a2200 4
	 * Set the operating system by way of the `Os' macro.  Note that
	 * if an argument isn't provided and -DOSNAME="\"foo\"" is
	 * provided during compilation, this value will be used instead
	 * of filling in "sysname release" from uname().
d2203 1
a2203 2
	if (mdoc->meta.os)
		free(mdoc->meta.os);
a2212 4
	/* XXX: yes, these can all be dynamically-adjusted buffers, but
	 * it's really not worth the extra hackery.
	 */

d2214 4
@


1.182
log
@Make the `-width' field to `Bl' not puke if it doesn't have an argument.
This makes mandoc work much, much nicer with Mac OSX manpages.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.181 2011/12/03 16:58:54 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.181
log
@When processing .Sh HEAD, as soon as we know which section this is,
fix up the section attributes of the HEAD, it's parent BLOCK, and
all its (text) children.  This is required because the section
attributes get set when each node is allocated, i.e. before processing
the content of the node itself.  Thus, the listed nodes got the section
attribute of the preceding section.  No need to fix up the BODY, all
is fine there already.
Found while implementing TYPE_Sh for mandocdb(8).
OK and comment requested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.180 2011/12/02 01:37:14 schwarze Exp $ */
d664 7
a670 2
			dup = (NULL != n->norm->Bl.width);
			width = n->args->argv[i].value[0];
@


1.180
log
@In man(7), when no explicit volume name is given, use the default
volume name for the respective manual section, just like in mdoc(7).
This gives us nicer page headers for cvs(1), lynx(1), tic(1),
mkhybrid(8), and many curses(3) manuals.

ok kristaps@@

To not break compatibility, i wrote a corresponding patch for GNU troff
which Werner Lemberg accepted upstream at rev. 1.65 of:
http://cvs.savannah.gnu.org/viewvc/groff/tmac/an-old.tmac?root=groff
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.179 2011/11/19 13:29:47 schwarze Exp $ */
d1829 1
d1864 14
@


1.179
log
@Improve misleading comment:
* Not sure there were any text nodes, might have been other stuff instead.
* Not sure it was just one node, maybe several were deleted.
* No problem if some nodes were deleted, as long as some valid ones are left.
* We do not leave early, but after cleaning out all the crap.
* We are not "bailing", but we consider the block valid after cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.178 2011/11/18 14:58:24 joerg Exp $ */
d2087 1
a2087 1
	cp = mdoc_a2msec(nn->string);
@


1.178
log
@Bail out explicitly on invalid .Rs content like:
.Rs
plain text
.Re

This avoids a crash on invalid.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.177 2011/10/16 12:20:34 schwarze Exp $ */
d1696 5
a1700 1
	/* Bail out early if a plain text node is found inside .Rs. */
@


1.177
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.176 2011/09/02 19:40:18 kristaps Exp $ */
d1696 4
@


1.176
log
@Make -man check for tabs correctly print the column.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.175 2011/08/19 13:59:23 kristaps Exp $ */
d548 4
a551 4
	cp = p;
	for (cp = p; NULL != (p = strchr(p, '\t')); p++) {
		if (MDOC_LITERAL & m->flags)
			continue;
a552 1
	}
@


1.175
log
@Avoid incorrect casting by using an implicit cast.  Reported by Thomas
Klausner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.174 2011/08/16 12:23:51 kristaps Exp $ */
d552 1
a552 1
		mdoc_pmsg(m, ln, (int)(p - cp), MANDOCERR_BADTAB);
@


1.174
log
@Fixed mingw compatibility where the "z" printf() modifier isn't
recognised.  It's easier to make these u_int than to jump through hoops
for a special formatter.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.173 2011/08/10 14:07:23 kristaps Exp $ */
d706 1
a706 1
				n->norm->Bl.cols = (const char **)
d1524 1
a1524 1
	mdoc->last->norm->Bl.cols = (const char **)np->args->argv[j].value;
@


1.173
log
@Allow `Sx' and `Ss' to have child nodes.  Fixes manuals in NetBSD.
Originally pointed out by joerg@@ then again by Thomas Klausner by way of
Nicolas Joy.  Note: don't use these constructions as you can't link to
the sections with `Sx'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.172 2011/07/26 14:09:01 kristaps Exp $ */
d1398 1
a1398 1
	snprintf(buf, NUMSIZ, "%zun", width);
d1448 1
a1448 1
	snprintf(buf, NUMSIZ, "%zun", sz);
@


1.172
log
@Move checking of escapes into roff.c, where we're already stepping
through looking for user-defined escapes.  This clears up a nice bit of
validation code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.171 2011/07/24 18:15:14 kristaps Exp $ */
d75 1
a75 3

static	int	 concat(struct mdoc *, char *, 
			const struct mdoc_node *, size_t);
d1108 1
d1120 3
a1122 1
	if ( ! concat(mdoc, buf, mdoc->last->child, BUFSIZ))
d1124 1
d1126 1
a1127 1

d1823 1
d1832 4
a1835 1
	if ( ! concat(mdoc, buf, mdoc->last->child, BUFSIZ))
d1837 2
a1838 2

	sec = a2sec(buf);
d1987 1
d1999 3
a2001 1
	if ( ! concat(mdoc, buf, n->child, DATESIZE))
d2003 1
d2005 1
d2160 1
d2177 3
a2179 1
	if ( ! concat(mdoc, buf, n->child, BUFSIZ))
d2181 3
d2250 6
d2257 1
a2257 1
concat(struct mdoc *m, char *p, const struct mdoc_node *n, size_t sz)
d2260 2
a2261 22
	p[0] = '\0';

	/*
	 * Concatenate sibling nodes together.  All siblings must be of
	 * type MDOC_TEXT or an assertion is raised.  Concatenation is
	 * separated by a single whitespace.  Returns 0 on fatal (string
	 * overrun) error.
	 */

	for ( ; n; n = n->next) {
		assert(MDOC_TEXT == n->type);

		if (strlcat(p, n->string, sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}

		if (NULL == n->next)
			continue;

		if (strlcat(p, " ", sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
d2263 5
a2267 1
		}
@


1.171
log
@Scary-looking but otherwise harmless changes allow me to build for Windows.
That is to say, with mingw32.  This amounts to the following:

 (1) break compat.c into compat_strlcpy.c and compat_strlcat.c
 (2) add compat_getsubopt.c (from OpenBSD) and test-getsubopt.c
 (3) add test-strptime.c for HAVE_STRPTIME
 (4) add ifdef bits here and there, where necessary
 (5) remove some harmless unportable stuff (u_char, localtime_r)

I've added the appropriate mdocml.zip target to the Makefile, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.170 2011/07/18 07:46:41 kristaps Exp $ */
d548 1
a548 8
	char		*cpp, *pp;
	size_t		 sz;

	while ('\0' != *p) {
		sz = strcspn(p, "\t\\");

		p += (int)sz;
		pos += (int)sz;
d550 3
a552 5
		if ('\t' == *p) {
			if ( ! (MDOC_LITERAL & m->flags))
				mdoc_pmsg(m, ln, pos, MANDOCERR_BADTAB);
			p++;
			pos++;
d554 1
a554 18
		} else if ('\0' == *p)
			break;

		pos++;
		pp = ++p;

		if (ESCAPE_ERROR == mandoc_escape
				((const char **)&pp, NULL, NULL)) {
			mdoc_pmsg(m, ln, pos, MANDOCERR_BADESCAPE);
			break;
		}

		cpp = p;
		while (NULL != (cpp = memchr(cpp, ASCII_HYPH, pp - cpp)))
			*cpp = '-';

		pos += pp - p;
		p = pp;
@


1.170
log
@Make `struct roff' be passed into libmdoc and libman upon creation.
This is required for supporting in-line equations.  While here, push
registers properly into roff and add an set/get/mod interface.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.169 2011/04/30 10:18:24 kristaps Exp $ */
d2049 1
a2049 1
			if (toupper((u_char)*p) == *p)
@


1.169
log
@No code change: fixing spelling errors.  From a patch by uqs@@.  Thanks!
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.168 2011/04/13 09:57:08 kristaps Exp $ */
d902 1
a902 1
	mdoc->regs->regs[(int)REG_nS].set = 0;
@


1.168
log
@Remove the warning for empty bodies of `Sh', `Ss', `SH', and `SS'.  This
prompted by a TODO by schwarze@@, originally from Gleydson Soares, that
an empty `SS' was raising an error (it hasn't for some time).  It makes
sense these shouldn't warn, as omitting their contents doesn't change
anything in the structure of the document (groff and mandoc specifically
account for the whitespace between empty sections).

This doesn't change any manuals, which only refer to the line arguments
(or possibly next-line, in the case of man(7) syntax).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.167 2011/04/09 15:29:40 kristaps Exp $ */
d1538 1
a1538 1
	 * Accomodate for new-style groff column syntax.  Shuffle the
@


1.167
log
@Remove a2roffdeco() and mandoc_special() functions and replace them with
a public (mandoc.h) function mandoc_escape(), which merges the
functionality of both prior functions.

Reason: code duplication.  The a2roffdeco() and mandoc_special()
functions were pretty much the same thing and both quite complex.  This
allows one function to receive improvements in (e.g.) subexpression
handling and performance, instead of having to replicate functionality.

As such, the mandoc_escape() function already handles a superset of the
escapes handled in previous versions and has improvements in performance
(using strcspn(), for example) and reliable handling of subexpressions.

This code Works For Me, but may need work to catch any regressions.
Since the benefits are great (leaner code, simpler API), I'd rather have
it in-tree than floating as a patch.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.166 2011/04/03 09:53:50 kristaps Exp $ */
d158 1
a158 1
static	v_post	 posts_sh[] = { post_ignpar, hwarn_ge1, bwarn_ge1, post_sh, NULL };
d160 1
a160 1
static	v_post	 posts_ss[] = { post_ignpar, hwarn_ge1, bwarn_ge1, NULL };
@


1.166
log
@Make uname have its return value checked for -1 (POSIX style), not
non-zero.  From a PR by Yuri Pankov, ok schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.165 2011/03/22 14:33:05 kristaps Exp $ */
d548 1
a548 1
	int		 c;
d551 1
a551 1
	for ( ; *p; p++, pos++) {
d553 1
a554 4

		if ('\0' == *p)
			break;

d560 2
d563 5
a567 1
		}
d569 2
a570 1
		if (0 == (c = mandoc_special(p))) {
d572 1
a572 1
			continue;
d575 6
a580 2
		p += c - 1;
		pos += c - 1;
@


1.165
log
@libmdoc.h and libman.h were including mdoc.h and man.h, respectively.
Don't have them do that (includes in header files = faugh), and have
individual files directly include these files.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.164 2011/03/20 16:02:05 kristaps Exp $ */
d2197 1
a2197 1
		if (uname(&utsname)) {
@


1.164
log
@Consolidate messages.  Have all parse-time messages (in libmdoc,
libroff, etc., etc.) route into mandoc_msg() and mandoc_vmsg(), for the
time being in libmandoc.h.  This requires struct mparse to be passed
into the allocation routines instead of mandocmsg and a void pointer.
Then, move some of the functionality of the old mmsg() into read.c's
mparse_mmsg() (check against wlevel and setting of file_status) and use
main.c's mmsg() as simply a printing tool.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.163 2011/03/17 12:14:19 kristaps Exp $ */
d36 1
@


1.163
log
@Note that mdoc_valids[] is static.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.162 2011/03/17 11:30:23 kristaps Exp $ */
d449 1
a449 1
	mdoc_vmsg(m, t, m->last->line, m->last->pos,
d584 3
a586 4
	mdoc_vmsg(mdoc, MANDOCERR_SYNTCHILD,
				n->line, n->pos, "want parent %s",
				MDOC_ROOT == t ? "<root>" : 
					mdoc_macronames[tok]);
d1334 2
a1335 1
		mdoc_vmsg(mdoc, er, mdoc->last->line, mdoc->last->pos, 
d2004 2
a2005 2
		mdoc->meta.date = mandoc_normdate(NULL,
		    mdoc->msg, mdoc->data, n->line, n->pos);
d2012 2
a2013 2
	mdoc->meta.date = mandoc_normdate(buf,
	    mdoc->msg, mdoc->data, n->line, n->pos);
@


1.162
log
@Clean-up in libmdoc: fix last checks for mdoc_*msg return value, then
make mdoc_vmsg not return an int.  libmdoc is now completely clean of
return-value checks from the message subsystem.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.161 2011/03/17 09:24:51 kristaps Exp $ */
d182 1
a182 1
const	struct valids mdoc_valids[MDOC_MAX] = {
@


1.161
log
@Move mdoc_macro2len() into mdoc_validate.c as macro2len(), as that's the
only place that it's being used.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.160 2011/03/17 09:22:39 kristaps Exp $ */
d449 1
a449 2

	return(mdoc_vmsg(m, t, m->last->line, m->last->pos,
d451 2
a452 1
			p, val, m->last->nchild));
d1269 1
a1269 1
	int		  i, cols, rc;
d1335 1
a1335 2
		rc = mdoc_vmsg(mdoc, er, 
				mdoc->last->line, mdoc->last->pos, 
d1337 1
a1337 1
		return(rc);
@


1.160
log
@Move mdoc_str2sec() into mdoc_validate.c as a2sec(), as that's the only
place that it's being used.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.159 2011/03/15 16:23:51 kristaps Exp $ */
d77 2
a78 1
static	enum mdoc_sec a2sec(const char *);
d1399 1
a1399 1
	else if (0 == (width = mdoc_macro2len(tok)))  {
d1456 1
a1456 1
		if (0 != (ssz = mdoc_macro2len(nn->tok)))
d2296 92
@


1.159
log
@Make lint shut up a little bit.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.158 2011/03/07 01:35:51 schwarze Exp $ */
d77 1
d325 24
d1849 1
a1849 1
	sec = mdoc_str2sec(buf);
d2283 12
@


1.158
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.157 2011/02/09 09:18:15 kristaps Exp $ */
d2130 2
a2131 1
		*n->string = toupper((unsigned char)*n->string);
@


1.157
log
@Allow -man to process EQN as well.  Also fix a segfault in missing case
statements in the post-handler for EQN in -mdoc and -man.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.156 2011/02/06 21:44:36 kristaps Exp $ */
d143 1
a143 1
static	v_post	 posts_dd[] = { ewarn_ge1, post_dd, post_prol, NULL };
d224 1
a224 1
	{ NULL, posts_text },			/* %D */ /* FIXME: check date with mandoc_a2time(). */
d922 1
a922 1
	if (0 == mdoc->meta.date || mdoc->meta.os)
d935 1
a935 1
	if (NULL == mdoc->meta.title || 0 == mdoc->meta.date)
d1974 3
d1978 3
a1980 3

	if (NULL == n->child) {
		mdoc->meta.date = time(NULL);
d1987 2
a1988 7
	mdoc->meta.date = mandoc_a2time
		(MTIME_MDOCDATE | MTIME_CANONICAL, buf);

	if (0 == mdoc->meta.date) {
		mdoc_nmsg(mdoc, n, MANDOCERR_BADDATE);
		mdoc->meta.date = time(NULL);
	}
@


1.156
log
@Add initial libmdoc and libman top-most machinery for accepting TBL
directives.  For now this will just ignore them (except for -Ttree,
which just notes that an EQN's been accepted).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.155 2011/02/02 21:40:45 kristaps Exp $ */
d372 2
@


1.155
log
@If `Ns' is specified on its own line, it should be ignored.  This is
shitty groff behaviour.  Do the same, but raise a warning to this
effect.  This from a TODO noted by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.154 2011/01/25 15:46:05 kristaps Exp $ */
d341 2
@


1.154
log
@Push capitalisation of `Bx' second argument into validator, where it belongs.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.153 2011/01/25 10:37:49 kristaps Exp $ */
d107 1
d152 1
d254 1
a254 1
	{ NULL, posts_notext },			/* Ns */
d1749 9
@


1.153
log
@If %B is specified, quote %T.  Noted by schwarze@@ in the TODO.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.152 2011/01/22 14:00:52 schwarze Exp $ */
d98 1
d138 1
d240 1
a240 1
	{ NULL, NULL },				/* Bx */
d2105 18
@


1.152
log
@Check argument count validation for all in_line() macros.
Most empty in_line() macros are already removed by the parser,
so there is no need to check again in mdoc_validate.c.
This also downgrades almost all remaining argument count issues
from ERROR to WARNING.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.85 2011/01/22 13:55:50 schwarze Exp $ */
d1668 2
a1669 2
			if (MDOC__J == rsord[i])
				mdoc->last->norm->Rs.child_J = nn;
@


1.151
log
@Partial cleanup of argument count validation in mdoc(7):

* Do not segfault on empty .Db, .Rs, .Sm, and .St.
* Let check_count() really throw the requested level, not always ERROR.
* Downgrade most bad argument counts from ERROR to WARNING.
* And some related internal cleanup.

Looks fine to kristaps@@.

Note that the macros using eerr_ge1() still need to be checked at a later
time; but as all the others are done, let's use what we already have.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.150 2011/01/01 12:18:37 kristaps Exp $ */
a80 1
static	int	 eerr_ge1(POST_ARGS);
d156 1
a156 1
static	v_post	 posts_text[] = { eerr_ge1, NULL };
a159 1
static	v_post	 posts_wtext[] = { ewarn_ge1, NULL };
d191 1
a191 1
	{ NULL, posts_text },			/* Ad */ 
d194 1
a194 1
	{ NULL, posts_text },			/* Cd */ 
d197 1
a197 1
	{ pres_er, posts_text },		/* Er */ 
d201 1
a201 1
	{ pres_fd, posts_wtext },		/* Fd */
d203 3
a205 3
	{ NULL, posts_text },			/* Fn */ 
	{ NULL, posts_wtext },			/* Ft */ 
	{ NULL, posts_text },			/* Ic */ 
d217 1
a217 1
	{ NULL, posts_wtext },			/* Xr */ 
d248 1
a248 1
	{ NULL, posts_text },			/* Ms */ 
d267 3
a269 3
	{ NULL, posts_text },			/* Sx */
	{ NULL, posts_text },			/* Sy */
	{ NULL, posts_text },			/* Tn */
d285 1
a285 1
	{ NULL, posts_text },			/* Lk */ 
a434 6
eerr_ge1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_ERROR, CHECK_GT, 0));
}

static int
d1074 2
a1075 1
	 * behaviour).  ELEM types must have a child; BLOCK types,
a1078 2
	if (MDOC_ELEM == mdoc->last->type)
		return(eerr_ge1(mdoc));
d1222 4
a1225 1
	if (AUTH__NONE != np->norm->An.auth && np->child) {
a1226 9
		return(1);
	}

	/* 
	 * FIXME: make this ewarn and make sure that the front-ends
	 * don't print the arguments.
	 */
	if (AUTH__NONE != np->norm->An.auth || np->child)
		return(1);
a1227 1
	mdoc_nmsg(mdoc, np, MANDOCERR_NOARGS);
@


1.150
log
@Add table processing structures to -mdoc.  This consists of an
external-facing function mdoc_addspan(), then various bits to prohibit
printing and scanning (this requires some if's to be converted into
switch's).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.149 2010/12/25 23:25:53 kristaps Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a56 1
	CHECK_FATAL
a80 2
static	int	 eerr_eq0(POST_ARGS);
static	int	 eerr_eq1(POST_ARGS);
a81 1
static	int	 eerr_le1(POST_ARGS);
d83 1
d85 1
a85 2
static	int	 herr_eq0(POST_ARGS);
static	int	 herr_ge1(POST_ARGS);
d88 1
d138 1
a138 1
static	v_post	 posts_bool[] = { eerr_eq1, ebool, NULL };
d142 1
a142 1
static	v_post	 posts_dl[] = { post_literal, bwarn_ge1, herr_eq0, NULL };
d146 1
a146 1
static	v_post	 posts_lb[] = { eerr_eq1, post_lb, NULL };
d151 5
a155 5
static	v_post	 posts_rs[] = { berr_ge1, herr_eq0, post_rs, NULL };
static	v_post	 posts_sh[] = { post_ignpar, herr_ge1, bwarn_ge1, post_sh, NULL };
static	v_post	 posts_sp[] = { eerr_le1, NULL };
static	v_post	 posts_ss[] = { post_ignpar, herr_ge1, bwarn_ge1, NULL };
static	v_post	 posts_st[] = { eerr_eq1, post_st, NULL };
d158 1
a158 1
static	v_post	 posts_text1[] = { eerr_eq1, NULL };
d160 1
a160 1
static	v_post	 posts_wline[] = { bwarn_ge1, herr_eq0, NULL };
d390 1
d402 1
a402 1
		p = "greater than ";
d416 1
a416 6
	if (CHECK_WARN == lvl) {
		return(mdoc_vmsg(m, MANDOCERR_ARGCOUNT,
				m->last->line, m->last->pos,
				"want %s%d children (have %d)",
				p, val, m->last->nchild));
	}
d418 2
a419 5
	/* FIXME: THIS IS THE SAME AS THE ABOVE. */

	return(mdoc_vmsg(m, MANDOCERR_ARGCOUNT,
			m->last->line, m->last->pos,
			"require %s%d children (have %d)",
d427 1
a427 1
	return(check_count(mdoc, MDOC_BODY, CHECK_FATAL, CHECK_GT, 0));
a436 12
eerr_eq0(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_EQ, 0));
}

static int
eerr_eq1(POST_ARGS)
{
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_EQ, 1));
}

static int
d439 1
a439 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_GT, 0));
d443 1
a443 1
eerr_le1(POST_ARGS)
d445 1
a445 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_FATAL, CHECK_LT, 2));
d449 1
a449 1
ewarn_eq0(POST_ARGS)
d451 1
a451 1
	return(check_count(mdoc, MDOC_ELEM, CHECK_WARN, CHECK_EQ, 0));
d461 1
a461 1
herr_eq0(POST_ARGS)
d463 1
a463 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_FATAL, CHECK_EQ, 0));
d467 1
a467 1
herr_ge1(POST_ARGS)
d469 1
a469 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_FATAL, CHECK_GT, 0));
d473 1
a473 1
hwarn_eq0(POST_ARGS)
d475 1
a475 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 0));
d479 1
a479 1
hwarn_eq1(POST_ARGS)
d481 1
a481 1
	return(check_count(mdoc, MDOC_HEAD, CHECK_WARN, CHECK_EQ, 1));
d1037 2
d1231 4
a1234 2
	if (AUTH__NONE != np->norm->An.auth && np->child)
		return(eerr_eq0(mdoc));
d1576 3
a1578 1
	if (NULL == mdoc->last->child)
d1580 2
d1630 2
a1631 1
	const char	*p;
d1633 5
a1637 1
	assert(MDOC_TEXT == mdoc->last->child->type);
d1639 1
a1639 1
	p = mdoc_a2st(mdoc->last->child->string);
d1641 1
a1641 1
	if (p == NULL) {
d1645 2
a1646 2
		free(mdoc->last->child->string);
		mdoc->last->child->string = mandoc_strdup(p);
d1658 10
a1667 1
	if (MDOC_BODY != mdoc->last->type)
d1669 1
@


1.149
log
@Implement schwarze@@'s much more elegant version of my %T/%J fix.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.148 2010/12/25 13:50:37 kristaps Exp $ */
d332 2
a333 1
	if (MDOC_TEXT == n->type) {
d338 4
d343 2
d367 4
a370 1
	if (MDOC_TEXT == mdoc->last->type)
d372 1
a372 1
	if (MDOC_ROOT == mdoc->last->type)
d374 3
@


1.148
log
@Specifying both %T and %J in an `Rs' block causes the title to be quoted
instead of underlined.  This only happens in -Tascii, as -T[x]html both
underlines and italicises.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.147 2010/12/24 14:00:40 kristaps Exp $ */
a1651 3
	int		 *tj;
#define	RS_JOURNAL	 (1 << 0)
#define	RS_TITLE	 (1 << 1)
d1653 1
a1653 9
	/* Mark whether we're carrying both a %T and %J. */

	tj = &mdoc->last->norm->Rs.titlejournal;

	if (MDOC_BLOCK == mdoc->last->type) {
		if ( ! (RS_JOURNAL & *tj && RS_TITLE & *tj))
			*tj = 0;
		return(1);
	} else if (MDOC_BODY != mdoc->last->type)
d1669 2
a1670 4
			if (MDOC__T == rsord[i])
				*tj |= RS_TITLE;
			else if (MDOC__J == rsord[i])
				*tj |= RS_JOURNAL;
@


1.147
log
@As per schwarze@@'s suggestions, roll back the refcount structure in
favour of a simpler shim for normalised data in the node allocation and
free routines.  This removes the need to bump and copy references within
validator handlers, removes a pointer redirect, and also kills the
refcount structure itself.  Data is assumed to "live" either in a
MDOC_BLOCK or MDOC_ELEM and is copied accordingly.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.146 2010/12/22 22:05:38 schwarze Exp $ */
d1652 3
d1656 9
a1664 1
	if (MDOC_BODY != mdoc->last->type)
d1680 4
@


1.146
log
@At the beginning of .Bl, .Sm is allowed,
and .Lp should cause a warning, not an error.
"I don't suppose I mind this." kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.145 2010/12/22 11:15:16 kristaps Exp $ */
a43 10
#define	NORM_BUMP(dst, src) do { \
		(dst)->norm = (src)->norm; \
		((dst)->norm->refcnt)++; \
	} while (/* CONSTCOND */ 0)
#define	NORM_ALLOC(dst) do { \
		(dst)->norm = \
			mandoc_calloc(1, sizeof(struct mdoc_norm)); \
		(dst)->norm->refcnt = 1; \
	} while (/* CONSTCOND */ 0)

a611 1
		NORM_BUMP(n, np);
a614 2
	NORM_ALLOC(n);

d663 1
a663 1
			dup = n->norm->d.Bl.comp;
d667 1
a667 1
			dup = (NULL != n->norm->d.Bl.width);
d674 1
a674 1
				dup = (NULL != n->norm->d.Bl.offs);
d689 1
a689 1
			n->norm->d.Bl.comp = comp;
d691 1
a691 1
			n->norm->d.Bl.offs = offs;
d693 1
a693 1
			n->norm->d.Bl.width = width;
d697 1
a697 1
		if (LIST__NONE != lt && n->norm->d.Bl.type != LIST__NONE)
d702 2
a703 2
		if (LIST__NONE != lt && n->norm->d.Bl.type == LIST__NONE) {
			n->norm->d.Bl.type = lt;
d706 1
a706 1
				n->norm->d.Bl.ncols = 
d708 1
a708 1
				n->norm->d.Bl.cols = (const char **)
d715 4
a718 4
		if (n->norm->d.Bl.type == LIST__NONE)
			if (n->norm->d.Bl.width || 
					n->norm->d.Bl.offs || 
					n->norm->d.Bl.comp)
d726 1
a726 1
	if (LIST__NONE == n->norm->d.Bl.type) {
d728 1
a728 1
		n->norm->d.Bl.type = LIST_item;
d737 1
a737 1
	switch (n->norm->d.Bl.type) {
d739 1
a739 1
		if (n->norm->d.Bl.width)
d752 1
a752 1
		if (n->norm->d.Bl.width)
a780 1
		NORM_BUMP(n, np);
a783 2
	NORM_ALLOC(n);

d813 1
a813 1
				dup = (NULL != n->norm->d.Bd.offs);
d820 1
a820 1
			dup = n->norm->d.Bd.comp;
d835 1
a835 1
			n->norm->d.Bd.offs = offs;
d837 1
a837 1
			n->norm->d.Bd.comp = comp;
d841 1
a841 1
		if (DISP__NONE != dt && n->norm->d.Bd.type != DISP__NONE)
d846 2
a847 2
		if (DISP__NONE != dt && n->norm->d.Bd.type == DISP__NONE)
			n->norm->d.Bd.type = dt;
d850 1
a850 1
	if (DISP__NONE == n->norm->d.Bd.type) {
d852 1
a852 1
		n->norm->d.Bd.type = DISP_ragged;
a896 2
	NORM_ALLOC(n);

d905 1
a905 1
		n->norm->d.An.auth = AUTH_split;
d907 1
a907 1
		n->norm->d.An.auth = AUTH_nosplit;
a988 1
		NORM_BUMP(mdoc->last, np);
a994 1
	NORM_ALLOC(np);
d1014 1
a1014 1
			np->norm->d.Bf.font = FONT_Em;
d1016 1
a1016 1
			np->norm->d.Bf.font = FONT_Li;
d1018 1
a1018 1
			np->norm->d.Bf.font = FONT_Sy;
d1027 1
a1027 1
		np->norm->d.Bf.font = FONT_Em;
d1029 1
a1029 1
		np->norm->d.Bf.font = FONT_Li;
d1031 1
a1031 1
		np->norm->d.Bf.font = FONT_Sy;
d1237 1
a1237 1
	if (AUTH__NONE != np->norm->d.An.auth && np->child)
d1244 1
a1244 1
	if (AUTH__NONE != np->norm->d.An.auth || np->child)
d1264 1
a1264 1
	lt = n->norm->d.Bl.type;
d1303 1
a1303 1
		cols = (int)n->norm->d.Bl.ncols;
d1347 2
a1348 2
	if (LIST_tag == n->norm->d.Bl.type && 
			NULL == n->norm->d.Bl.width) {
d1351 1
a1351 1
	} else if (NULL != n->norm->d.Bl.width) {
d1357 1
a1357 1
	assert(n->norm->d.Bl.width);
d1381 1
a1381 1
	if (0 == strcmp(n->norm->d.Bl.width, "Ds"))
d1383 1
a1383 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->norm->d.Bl.width)))
d1405 1
a1405 1
	n->norm->d.Bl.width = n->args->argv[i].value[0];
d1471 1
a1471 1
	n->norm->d.Bl.width = n->args->argv[i].value[0];
d1482 1
a1482 1
	if (LIST_column != mdoc->last->norm->d.Bl.type)
d1499 1
a1499 1
	if (mdoc->last->norm->d.Bl.ncols && mdoc->last->nchild) {
d1525 2
a1526 2
	mdoc->last->norm->d.Bl.ncols = np->args->argv[j].sz;
	mdoc->last->norm->d.Bl.cols = (const char **)np->args->argv[j].value;
d1908 1
a1908 1
	if (MDOC_Bl == n->tok && n->norm->d.Bl.comp)
d1910 1
a1910 1
	if (MDOC_Bd == n->tok && n->norm->d.Bd.comp)
d1912 1
a1912 1
	if (MDOC_It == n->tok && n->parent->norm->d.Bl.comp)
d1937 1
a1937 1
		if (DISP_literal == n->norm->d.Bd.type)
d1939 1
a1939 1
		if (DISP_unfilled == n->norm->d.Bd.type)
@


1.145
log
@Implement reference-counted version of original union mdoc_data.  This
simplifies clean-up and allows for more types without extra hassle.

Also made in-line literal types in -T[x]html use CODE instead of SPAN to
match how literal blocks use PRE.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.144 2010/12/16 17:14:48 kristaps Exp $ */
d1576 1
a1576 3
		case (MDOC_It):
			continue;
		case (MDOC_Sm):
d1580 4
@


1.144
log
@Migrate `An' to use a pointer in its data, like everybody else.  This is
the first step to having a simpler ref-counted system for "data"
associated with a node.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.143 2010/12/16 00:57:50 kristaps Exp $ */
d44 10
d622 1
a622 2
		assert(np->data.Bl);
		n->data.Bl = np->data.Bl;
d626 2
a633 3
	assert(NULL == n->data.Bl);
	n->data.Bl = mandoc_calloc(1, sizeof(struct mdoc_bl));

d676 1
a676 1
			dup = n->data.Bl->comp;
d680 1
a680 1
			dup = (NULL != n->data.Bl->width);
d687 1
a687 1
				dup = (NULL != n->data.Bl->offs);
d702 1
a702 1
			n->data.Bl->comp = comp;
d704 1
a704 1
			n->data.Bl->offs = offs;
d706 1
a706 1
			n->data.Bl->width = width;
d710 1
a710 1
		if (LIST__NONE != lt && n->data.Bl->type != LIST__NONE)
d715 2
a716 2
		if (LIST__NONE != lt && n->data.Bl->type == LIST__NONE) {
			n->data.Bl->type = lt;
d719 1
a719 1
				n->data.Bl->ncols = 
d721 1
a721 1
				n->data.Bl->cols = (const char **)
d728 4
a731 4
		if (n->data.Bl->type == LIST__NONE)
			if (n->data.Bl->width || 
					n->data.Bl->offs || 
					n->data.Bl->comp)
d739 1
a739 1
	if (LIST__NONE == n->data.Bl->type) {
d741 1
a741 1
		n->data.Bl->type = LIST_item;
d750 1
a750 1
	switch (n->data.Bl->type) {
d752 1
a752 1
		if (n->data.Bl->width)
d765 1
a765 1
		if (n->data.Bl->width)
d794 1
a794 2
		assert(np->data.Bd);
		n->data.Bd = np->data.Bd;
d798 1
a798 2
	assert(NULL == n->data.Bd);
	n->data.Bd = mandoc_calloc(1, sizeof(struct mdoc_bd));
d829 1
a829 1
				dup = (NULL != n->data.Bd->offs);
d836 1
a836 1
			dup = n->data.Bd->comp;
d851 1
a851 1
			n->data.Bd->offs = offs;
d853 1
a853 1
			n->data.Bd->comp = comp;
d857 1
a857 1
		if (DISP__NONE != dt && n->data.Bd->type != DISP__NONE)
d862 2
a863 2
		if (DISP__NONE != dt && n->data.Bd->type == DISP__NONE)
			n->data.Bd->type = dt;
d866 1
a866 1
	if (DISP__NONE == n->data.Bd->type) {
d868 1
a868 1
		n->data.Bd->type = DISP_ragged;
d913 1
a913 2
	assert(NULL == n->data.An);
	n->data.An = mandoc_calloc(1, sizeof(struct mdoc_an));
d923 1
a923 1
		n->data.An->auth = AUTH_split;
d925 1
a925 1
		n->data.An->auth = AUTH_nosplit;
d1007 1
a1007 2
		assert(np->data.Bf);
		mdoc->last->data.Bf = np->data.Bf;
d1014 1
a1014 1
	np->data.Bf = mandoc_calloc(1, sizeof(struct mdoc_bf));
d1034 1
a1034 1
			np->data.Bf->font = FONT_Em;
d1036 1
a1036 1
			np->data.Bf->font = FONT_Li;
d1038 1
a1038 1
			np->data.Bf->font = FONT_Sy;
d1047 1
a1047 1
		np->data.Bf->font = FONT_Em;
d1049 1
a1049 1
		np->data.Bf->font = FONT_Li;
d1051 1
a1051 1
		np->data.Bf->font = FONT_Sy;
d1257 1
a1257 1
	if (AUTH__NONE != np->data.An->auth && np->child)
d1264 1
a1264 1
	if (AUTH__NONE != np->data.An->auth || np->child)
d1284 1
a1284 2
	assert(n->data.Bl);
	lt = n->data.Bl->type;
d1323 1
a1323 1
		cols = (int)n->data.Bl->ncols;
d1367 2
a1368 2
	if (LIST_tag == n->data.Bl->type && 
			NULL == n->data.Bl->width) {
d1371 1
a1371 1
	} else if (NULL != n->data.Bl->width) {
d1377 1
a1377 1
	assert(n->data.Bl->width);
d1401 1
a1401 1
	if (0 == strcmp(n->data.Bl->width, "Ds"))
d1403 1
a1403 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->data.Bl->width)))
d1425 1
a1425 1
	n->data.Bl->width = n->args->argv[i].value[0];
d1491 1
a1491 1
	n->data.Bl->width = n->args->argv[i].value[0];
d1502 1
a1502 1
	if (LIST_column != mdoc->last->data.Bl->type)
d1519 1
a1519 1
	if (mdoc->last->data.Bl->ncols && mdoc->last->nchild) {
d1545 2
a1546 2
	mdoc->last->data.Bl->ncols = np->args->argv[j].sz;
	mdoc->last->data.Bl->cols = (const char **)np->args->argv[j].value;
d1926 1
a1926 1
	if (MDOC_Bl == n->tok && n->data.Bl->comp)
d1928 1
a1928 1
	if (MDOC_Bd == n->tok && n->data.Bd->comp)
d1930 1
a1930 1
	if (MDOC_It == n->tok && n->parent->data.Bl->comp)
d1955 1
a1955 2
		assert(n->data.Bd);
		if (DISP_literal == n->data.Bd->type)
d1957 1
a1957 1
		if (DISP_unfilled == n->data.Bd->type)
@


1.143
log
@Back out last: apparently `Bl', `It', and `Pp' need a little bit more
study to see exactly what's legal and what's not.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.142 2010/12/16 00:53:04 kristaps Exp $ */
d907 3
d918 1
a918 1
		n->data.An.auth = AUTH_split;
d920 1
a920 1
		n->data.An.auth = AUTH_nosplit;
d1253 1
a1253 1
	if (AUTH__NONE != np->data.An.auth && np->child)
d1260 1
a1260 1
	if (AUTH__NONE != np->data.An.auth || np->child)
@


1.142
log
@Allow `It' to have a trailing paragraph if the surrounding list is in
compact mode.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.141 2010/12/16 00:25:35 kristaps Exp $ */
d147 1
a147 1
static	v_post	 posts_it[] = { post_ignpar, post_it, NULL };
d1889 1
a1889 7
	/*
	 * Lists are allowed to have paragraphs as the first macro (I
	 * have no idea why: it really uglifies things).
	 */

	np = mdoc->last->child;
	if (NULL != np && MDOC_It != mdoc->last->tok)
a1894 9
	/*
	 * Compact lists are allowed to have trailing paragraph macros;
	 * however, nobody else is (including non-compact lists).
	 */

	np = mdoc->last;
	if (MDOC_It == np->tok && ! np->parent->parent->data.Bl->comp)
		return(1);

@


1.141
log
@First, make `Pp' (next to `Sm') be allowed as the first element of a
`Bl' (before any `It' have been invoked).  Next, have the existence of
either macro raise a warning, as it's technically not legal according to
mdoc.7.

Second, delete any `Pp' as the first element of a `Bl' (i.e., before an
`It') ONLY when -compact has not been specified.  This matches with the
latest version of groff.  This deletion happens prior to the above
check, so double-warnings will not be issued.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.140 2010/12/15 23:39:40 kristaps Exp $ */
d147 1
a147 1
static	v_post	 posts_it[] = { post_it, NULL };
d1889 7
a1895 1
	if (NULL != (np = mdoc->last->child))
d1901 9
@


1.140
log
@Add a "last child" member of struct mdoc_node.

Remove `Pp' or `Lp' if it is the FIRST or LAST child of an `Sh' or `Sh' body.

Make "skipping paragraph" be an error, not a warning, as information (an
invoked macro) is ignored.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.139 2010/12/09 10:32:22 kristaps Exp $ */
d173 1
a173 1
static	v_pre	 pres_it[] = { pre_it, NULL };
a1566 2
	if (NULL == mdoc->last->child)
		return(1);
a1567 7
	/*
	 * We only allow certain children of `Bl'.  This is usually on
	 * `It', but apparently `Sm' occurs here and there, so we let
	 * that one through, too.
	 */

	/* LINTED */
d1569 2
a1570 1
		if (MDOC_BLOCK == n->type && MDOC_It == n->tok)
d1572 4
a1575 1
		if (MDOC_Sm == n->tok)
d1577 4
d1910 2
a1919 1

d1924 2
@


1.139
log
@Allow quote macros (`Op', `Aq', `Bq', `Dq', `Pq', `Ql', `Qq', `Sq', and
`Brq') to have zero arguments without warning.  This makes sense because
the multi-line quote macros (`Oo/Oc' etc.) allow zero children anyway.
Furthermore, the documentation doesn't state that they're required to
have children.

Originally reported by Alex Kozlov, thanks!
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.138 2010/12/05 15:59:27 kristaps Exp $ */
d110 1
d154 1
a154 1
static	v_post	 posts_sh[] = { herr_ge1, bwarn_ge1, post_sh, NULL };
d156 1
a156 1
static	v_post	 posts_ss[] = { herr_ge1, NULL };
a897 4
	/* 
	 * FIXME: this can probably be lifted if we make the It into
	 * something else on-the-fly?
	 */
d1883 23
@


1.138
log
@Remove repeat notification of -width omission.  From a patch by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.137 2010/12/05 15:55:01 kristaps Exp $ */
d213 1
a213 1
	{ NULL, posts_wline },			/* Op */
d234 1
a234 1
	{ NULL, posts_wline },			/* Aq */
d239 1
a239 1
	{ NULL, posts_wline },			/* Bq */
d245 1
a245 1
	{ NULL, posts_wline },			/* Dq */
d259 1
a259 1
	{ NULL, posts_wline },			/* Pq */
d261 1
a261 1
	{ NULL, posts_wline },			/* Ql */
d263 1
a263 1
	{ NULL, posts_wline },			/* Qq */
d268 1
a268 1
	{ NULL, posts_wline },			/* Sq */
d290 1
a290 1
	{ NULL, posts_wline },			/* Brq */ 
@


1.137
log
@Remove long-standing FIXME regarding the consolidation of WIDTHARG and
NOARGV warnings.  From patch by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.136 2010/12/05 15:49:37 kristaps Exp $ */
d1451 1
a1451 3
		if (nn == NULL) {
			/* No -width for .Bl and first .It is emtpy */
			mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG);
a1452 1
		}
a1460 2
		else 
			mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG);
@


1.136
log
@Merge schwarze@@'s patch to allow uname() to fail without causing an exit.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.135 2010/12/05 15:37:30 kristaps Exp $ */
d756 2
a757 3
		if (NULL == n->data.Bl->width)
			break;
		mdoc_nmsg(mdoc, n, MANDOCERR_WIDTHARG);
@


1.135
log
@Merge schwarze@@'s changes allowing nested displays.  Tweak the patch by
making sure output doesn't add a superfluous newline with the nested displays.
Also add a COMPATIBILITY note.

Rename a macro (DATESIZ) to be in line with OpenBSD (DATESIZE).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.134 2010/12/01 13:05:13 kristaps Exp $ */
d2133 5
a2137 2
		if (-1 == uname(&utsname))
			return(mdoc_nmsg(mdoc, n, MANDOCERR_UTSNAME));
d2143 1
a2143 1
		if (strlcat(buf, " ", 64) >= BUFSIZ) {
@


1.134
log
@Fixed a goddamn subtle error causing MDOC_LITERAL to remain set after a
call to `Dl' or `Bd -literal' or unfilled.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.133 2010/11/30 14:27:37 kristaps Exp $ */
d45 1
a45 1
#define	DATESIZ	  32
a577 2
	/* Display elements (`Bd', `D1'...) cannot be nested. */

a580 1
	/* LINTED */
d586 2
a587 2
	if (NULL == node)
		return(1);
d589 1
a589 2
	mdoc_nmsg(mdoc, n, MANDOCERR_NESTEDDISP);
	return(0);
d1950 1
a1950 1
	char		  buf[DATESIZ];
d1960 1
a1960 1
	if ( ! concat(mdoc, buf, n->child, DATESIZ))
@


1.133
log
@Simplify the many if ( ! mdoc_nmsg()) return(0) etc. calls with just the
error printing, as this is superseded by exit_status in main.c.

Make check_argv() and check_text() return void.

Make MDOC_Std test in check_argv() to pre_std().

Re-write post_root() to check more conditions before returning.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.132 2010/11/30 12:59:20 kristaps Exp $ */
d1161 1
a1161 1
		mdoc->last->flags &= ~MDOC_LITERAL;
@


1.132
log
@Moved all prologue actions from mdoc_action.c into mdoc_validate.c.  The
file is now ready for removal.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.131 2010/11/30 12:35:10 kristaps Exp $ */
d70 2
a71 3
static	int	 check_stdarg(PRE_ARGS);
static	int	 check_text(struct mdoc *, int, int, char *);
static	int	 check_argv(struct mdoc *, 
d73 1
a73 1
static	int	 check_args(struct mdoc *, struct mdoc_node *);
a128 1
static	int	 pre_rv(PRE_ARGS);
d131 1
a170 1
static	v_pre	 pres_ex[] = { NULL, NULL };
a174 1
static	v_pre	 pres_rv[] = { pre_rv, NULL };
d177 1
d202 1
a202 1
	{ pres_ex, posts_std },			/* Ex */ 
d216 1
a216 1
	{ pres_rv, posts_std },			/* Rv */
d335 2
a336 1
		return(check_text(mdoc, line, pos, tp));
d339 2
a340 2
	if ( ! check_args(mdoc, n))
		return(0);
d398 3
d410 2
d497 1
a497 13

static int
check_stdarg(PRE_ARGS)
{

	if (n->args && 1 == n->args->argc)
		if (MDOC_Std == n->args->argv[0].arg)
			return(1);
	return(mdoc_nmsg(mdoc, n, MANDOCERR_NOARGV));
}


static int
d503 1
a503 1
		return(1);
d507 1
a507 4
		if ( ! check_argv(m, n, &n->args->argv[i]))
			return(0);

	return(1);
d510 1
a510 2

static int
d516 1
a516 2
		if ( ! check_text(m, v->line, v->pos, v->value[i]))
			return(0);
d518 1
a518 6
	if (MDOC_Std == v->arg) {
		if (v->sz || m->meta.name)
			return(1);
		if ( ! mdoc_nmsg(m, n, MANDOCERR_NONAME))
			return(0);
	}
d520 3
a522 1
	return(1);
d525 1
a525 2

static int
d541 3
a543 5
			if (MDOC_LITERAL & m->flags)
				continue;
			if (mdoc_pmsg(m, ln, pos, MANDOCERR_BADTAB))
				continue;
			return(0);
d546 4
a549 1
		/* Check the special character. */
d551 2
a552 6
		c = mandoc_special(p);
		if (c) {
			p += c - 1;
			pos += c - 1;
		} else
			mdoc_pmsg(m, ln, pos, MANDOCERR_BADESCAPE);
a553 2

	return(1);
a555 1

d685 1
a685 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV))
				return(0);
d693 2
a694 2
		if (dup && ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
			return(0);
d706 1
a706 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP))
				return(0);
d727 1
a727 2
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
					return(0);
d735 1
a735 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE))
			return(0);
d749 2
a750 3
		if (mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG))
			break;
		return(0);
d762 2
a763 3
		if (mdoc_nmsg(mdoc, n, MANDOCERR_WIDTHARG))
			break;
		return(0);
d830 1
a830 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_IGNARGV))
				return(0);
d843 2
a844 2
		if (dup && ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
			return(0);
d856 1
a856 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_DISPREP))
				return(0);
d865 1
a865 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE))
			return(0);
d901 1
d919 2
a920 3
		if ( ! mdoc_pmsg(mdoc, n->args->argv[i].line,
			n->args->argv[i].pos, MANDOCERR_IGNARGV))
			return(0);
d933 1
a933 1
pre_rv(PRE_ARGS)
d936 6
a941 1
	return(check_stdarg(mdoc, n));
d949 2
a950 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO))
			return(0);
d952 2
a953 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP))
			return(0);
d962 2
a963 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO))
			return(0);
d965 2
a966 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP))
			return(0);
d975 2
a976 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGOOO))
			return(0);
d978 2
a979 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_PROLOGREP))
			return(0);
d1025 4
a1028 2
	} else if (NULL == np->parent->args && NULL == np->child)
		return(mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE));
d1053 2
a1054 2
	else if ( ! mdoc_nmsg(mdoc, np, MANDOCERR_FONTTYPE))
		return(0);
d1095 3
a1097 3
	if (NULL == mdoc->last->child)
		return(1);
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST));
d1120 1
a1120 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_CHILD))
				return(0);
d1260 1
d1267 3
a1269 1
	return(mdoc_nmsg(mdoc, np, MANDOCERR_NOARGS));
d1290 1
a1290 1
		return(0);
d1298 1
a1298 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
			return(0);
d1308 1
a1308 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
				return(0);
d1318 1
a1318 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
				return(0);
d1322 1
a1322 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGSLOST))
				return(0);
d1330 1
a1330 2
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
				return(0);
d1407 4
a1410 2
	else if (0 == (width = mdoc_macro2len(tok))) 
		return(mdoc_nmsg(mdoc, n, MANDOCERR_BADWIDTH));
d1458 1
a1458 2
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG))
				return(0);
d1469 2
a1470 2
		else if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG))
			return(0);
a1601 1

a1604 1
	struct mdoc_node *n;
d1606 4
a1609 10
	/* LINTED */
	for (n = mdoc->last->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
			break;
		if (0 == strcmp(n->string, "on"))
			continue;
		if (0 == strcmp(n->string, "off"))
			continue;
		break;
	}
d1611 1
a1611 1
	if (NULL == n)
d1613 5
a1617 1
	return(mdoc_nmsg(mdoc, n, MANDOCERR_BADBOOL));
a1619 1

d1623 2
d1626 6
a1631 3
	if (NULL == mdoc->first->child)
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCBODY);
	else if ( ! (MDOC_PBODY & mdoc->flags))
d1633 16
a1648 6
	else if (MDOC_BLOCK != mdoc->first->child->type)
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCBODY);
	else if (MDOC_Sh != mdoc->first->child->tok)
		mdoc_nmsg(mdoc, mdoc->first, MANDOCERR_NODOCBODY);
	else
		return(1);
d1650 1
a1650 1
	return(0);
a1768 1

a1780 1

d1795 4
a1798 2
	if (NULL == (n = mdoc->last->child))
		return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC));
d1805 1
a1805 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC))
			return(0);
d1811 3
a1813 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADNAMESEC));
a1815 1

d1961 1
a1961 1
		return(post_prol(mdoc));
d1971 1
a1971 2
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_BADDATE))
			return(0);
d2002 6
a2007 2
			if ( ! mdoc_nmsg(mdoc, nn, MANDOCERR_UPPERCASE))
				return(0);
d2050 2
a2051 1
	} else if (mdoc_nmsg(mdoc, n, MANDOCERR_BADMSEC)) {
d2054 1
a2054 2
	} else
		return(0);
d2174 1
d2183 1
d2197 2
a2198 1
	 * separated by a single whitespace.
@


1.131
log
@Move post_bl() and subfunctions from mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.130 2010/11/30 10:32:05 kristaps Exp $ */
d21 4
d33 1
d76 3
d102 2
a106 1
static	int	 post_dt(POST_ARGS);
d110 2
d118 1
d143 1
d145 1
a145 1
static	v_post	 posts_dt[] = { post_dt, NULL };
d152 1
d158 1
d183 1
a183 1
	{ pres_dd, posts_wtext },		/* Dd */
d185 1
a185 1
	{ pres_os, NULL },			/* Os */
d204 1
a204 1
	{ pres_ex, NULL },			/* Ex */ 
d218 1
a218 1
	{ pres_rv, NULL },			/* Rv */
a963 1

a970 20

static int
post_dt(POST_ARGS)
{
	const struct mdoc_node *nn;
	const char	*p;

	if (NULL != (nn = mdoc->last->child))
		for (p = nn->string; *p; p++) {
			if (toupper((u_char)*p) == *p)
				continue;
			if ( ! mdoc_nmsg(mdoc, nn, MANDOCERR_UPPERCASE))
				return(0);
			break;
		}

	return(1);
}


a983 1

a996 1

d1155 1
a1155 2
	struct mdoc_node *nn;
	char		  buf[BUFSIZ];
d1167 2
a1168 1
	buf[0] = '\0';
d1170 1
a1170 17
	for (nn = mdoc->last->child; nn; nn = nn->next) {
		/* XXX - copied from concat(). */
		assert(MDOC_TEXT == nn->type);

		if (strlcat(buf, nn->string, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, nn, MANDOCERR_MEM);
			return(0);
		}

		if (NULL == nn->next)
			continue;

		if (strlcat(buf, " ", BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, nn, MANDOCERR_MEM);
			return(0);
		}
	}
a1171 1
	mdoc->meta.name = mandoc_strdup(buf);
d1836 2
a1837 3
	char		  buf[BUFSIZ];
	enum mdoc_sec	  sec;
	struct mdoc_node *n;
d1846 2
a1847 21
	buf[0] = '\0';

	/* FIXME: use dynamic buffer... */

	for (n = mdoc->last->child; n; n = n->next) {
		/* XXX - copied from concat(). */
		assert(MDOC_TEXT == n->type);

		if (strlcat(buf, n->string, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}

		if (NULL == n->next)
			continue;

		if (strlcat(buf, " ", BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(mdoc, n, MANDOCERR_MEM);
			return(0);
		}
	}
d1967 265
@


1.130
log
@Move -column list validation and normal-formisation from mdoc_action.c
into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.129 2010/11/29 16:06:46 kristaps Exp $ */
d39 3
d90 3
d1407 147
d1628 2
@


1.129
log
@Migrate `Nm' and `Pa' handling from mdoc_action.c into mdoc_validate.c.

Document that `Pa' is replaced by a tilde, just like `Mt'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.128 2010/11/29 15:45:15 kristaps Exp $ */
d1405 14
a1418 1
	struct mdoc_node *n;
d1420 4
a1423 2
	assert(mdoc->last->parent);
	n = mdoc->last->parent;
d1425 4
a1428 5
	if (LIST_column == n->data.Bl->type) {
		if (n->data.Bl->ncols && mdoc->last->nchild) {
			mdoc_nmsg(mdoc, n, MANDOCERR_COLUMNS);
			return(0);
		}
d1430 30
d1462 4
a1465 2
	/* FIXME: should be ERROR class. */
	return(hwarn_eq0(mdoc));
a1467 1

@


1.128
log
@Remove left-over rsord[] in mdoc_actions.c.

Remove MANDOCERR_BADLIB (not used).

Moved `St' handling from mdoc_action.c into mdoc_validate.c.

Moved relevant MDOC_LITERAL macros (`Dl', `Bd' subtypes) from
mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.127 2010/11/29 14:56:43 kristaps Exp $ */
d196 1
a196 1
	{ NULL, NULL },				/* Pa */
d1157 4
d1162 2
a1163 1
	if (mdoc->last->child)
d1165 1
a1165 1
	if (mdoc->meta.name)
d1167 25
a1191 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NONAME));
d1218 2
a1219 2
	 * argument; the `Mt' macro uses "~"; the `Li' just gets an
	 * empty string.
d1245 2
@


1.127
log
@Move `Lb' handling from mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.126 2010/11/29 14:50:33 kristaps Exp $ */
d89 1
d109 1
d118 1
a118 1
static	v_post	 posts_bd_bk[] = { hwarn_eq0, bwarn_ge1, NULL };
d120 1
d125 1
d144 1
a144 1
static	v_pre	 pres_bd[] = { pre_display, pre_bd, pre_par, NULL };
d147 1
d169 2
a170 2
	{ pres_d1, posts_wline },		/* Dl */
	{ pres_bd, posts_bd_bk },		/* Bd */
d261 1
a261 1
	{ NULL, posts_bd_bk },			/* Bk */
d590 1
d1166 17
a1463 1

d1467 13
d1481 1
a1481 3
	if (mdoc_a2st(mdoc->last->child->string))
		return(1);
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADSTANDARD));
a1483 1

d1750 31
@


1.126
log
@Move `At' handling from mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.125 2010/11/29 13:51:03 kristaps Exp $ */
a1079 1

d1083 8
d1092 5
a1096 1
	if (mdoc_a2lib(mdoc->last->child->string))
d1098 12
a1109 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADLIB));
a1111 1

@


1.125
log
@Move `Sh' validation from mdoc_action.c. into mdoc_validate.c.
Surprisingly, both functions were doing pretty much the same thing.
Make sure that the changes incorporate the union of both.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.124 2010/11/29 13:12:24 kristaps Exp $ */
d115 1
a115 1
static	v_post	 posts_at[] = { post_at, NULL };
d1162 6
d1188 3
d1192 6
d1200 1
d1202 18
a1219 3
	if (mdoc_a2att(mdoc->last->child->string))
		return(1);
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BADATT));
a1221 1

@


1.124
log
@Clarifying role of pre_pp (now pre_par), which was confusing me due to
its name.  Added some more documentation just for clarity's sake.  No
functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.123 2010/11/29 13:02:47 kristaps Exp $ */
d1547 3
a1549 3
	char		        buf[BUFSIZ];
	enum mdoc_sec	        sec;
	const struct mdoc_node *n;
d1553 3
a1555 3
	 * "custom"; custom sections are user-defined, while named ones
	 * usually follow a conventional order and may only appear in
	 * certain manual sections.
d1560 1
a1560 4
	/*
	 * FIXME: yes, these can use a dynamic buffer, but I don't do so
	 * in the interests of simplicity.
	 */
d1563 1
a1563 1
		/* XXX - copied from compact(). */
d1570 1
d1573 1
d1582 1
a1582 4
	/* 
	 * Check: NAME should always be first, CUSTOM has no roles,
	 * non-CUSTOM has a conventional order to be followed.
	 */
d1585 14
a1598 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NAMESECFIRST))
			return(0);
d1603 5
d1609 1
a1609 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECREP))
			return(0);
d1612 7
a1618 2
		if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECOOO))
			return(0);
d1620 1
a1620 4
	/* 
	 * Check particular section/manual conventions.  LIBRARY can
	 * only occur in manual section 2, 3, and 9.
	 */
d1623 4
a1627 1
		assert(mdoc->meta.msec);
d1634 2
a1635 1
		return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SECMSEC));
@


1.123
log
@Move `Mt', `Ar', and `Li' handling from mdoc_action.c into mdoc_validate.c.

Clarify that `Mt' gets a default `~' (as per groff 1.20) and document it
in mdoc.7.

Made `Lk' be removed in mdoc_macro.c if it has no arguments.  This fixes
segfaults in mdoc_{term,html}.c that nobody's managed to raise yet.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.122 2010/11/29 12:22:28 kristaps Exp $ */
d109 1
a109 1
static	int	 pre_pp(PRE_ARGS);
d140 2
a141 2
static	v_pre	 pres_bd[] = { pre_display, pre_bd, pre_pp, NULL };
static	v_pre	 pres_bl[] = { pre_bl, pre_pp, NULL };
d150 1
a150 1
static	v_pre	 pres_pp[] = { pre_pp, NULL };
a1624 1

d1626 1
a1626 1
pre_pp(PRE_ARGS)
d1632 4
a1635 1
	/* Don't allow prior `Lp' or `Pp'. */
@


1.122
log
@Migrate action for `Rs' into mdoc_validate.c.
Remove superfluous in-line order_rs function.
Merge `Rs' validations {BLOCK, BODY} -> {BODY}.
Make invalid children of `Rs' raise an error but otherwise be allowed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.121 2010/10/11 15:46:19 kristaps Exp $ */
d88 2
a99 1
static	int	 post_eoln(POST_ARGS);
d121 1
d172 1
a172 1
	{ NULL, NULL },				/* Ar */
d186 1
a186 1
	{ NULL, NULL },				/* Li */
d265 1
a265 1
	{ NULL, posts_text },			/* Mt */ 
d1138 40
@


1.121
log
@Use proper error for `An' multiple arguments.

Making IGNARGV be an ERROR, not a WARNING, as information is lost.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.120 2010/10/11 13:24:33 kristaps Exp $ */
d278 19
d1362 2
a1363 1
	struct mdoc_node	*nn;
d1368 81
a1448 33
	for (nn = mdoc->last->child; nn; nn = nn->next)
		switch (nn->tok) {
		case(MDOC__U):
			/* FALLTHROUGH */
		case(MDOC__Q):
			/* FALLTHROUGH */
		case(MDOC__C):
			/* FALLTHROUGH */
		case(MDOC__A):
			/* FALLTHROUGH */
		case(MDOC__B):
			/* FALLTHROUGH */
		case(MDOC__D):
			/* FALLTHROUGH */
		case(MDOC__I):
			/* FALLTHROUGH */
		case(MDOC__J):
			/* FALLTHROUGH */
		case(MDOC__N):
			/* FALLTHROUGH */
		case(MDOC__O):
			/* FALLTHROUGH */
		case(MDOC__P):
			/* FALLTHROUGH */
		case(MDOC__R):
			/* FALLTHROUGH */
		case(MDOC__T):
			/* FALLTHROUGH */
		case(MDOC__V):
			break;
		default:
			mdoc_nmsg(mdoc, nn, MANDOCERR_SYNTCHILD);
			return(0);
d1450 1
@


1.120
log
@Initial commit of cleaned-up validation code for -mdoc.  Remove those
ugly CPP macros in favour of real functions.  Enumerate areas of short-
term future cleanup, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.119 2010/09/27 23:03:44 schwarze Exp $ */
d896 1
d900 4
a903 2
	if (n->args->argc > 1)
		if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGCOUNT))
a905 2
	/* FIXME: this should use a different error message. */

@


1.119
log
@Merge from OpenBSD right after 1.10.6; now back to full sync.
* mdoc.c: blank lines outside literal mode are more similar to .sp than .Pp
* backslashes do not terminate macros; partial revert of mdoc.c 1.164;
  the intention of that commit is fully achieved in roff.c
* mdoc_term.c: no need to list the same prototype twice
* mdoc_validate.c: drop .Pp before .sp just like .Pp before .Pp
* fix off-by-one found by jsg@@ with parfait, OpenBSD term_ps.c 1.12
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.118 2010/09/27 11:25:03 kristaps Exp $ */
d39 12
d59 2
a66 10
static	int	 err_child_lt(struct mdoc *, const char *, int);
static	int	 warn_child_lt(struct mdoc *, const char *, int);
static	int	 err_child_gt(struct mdoc *, const char *, int);
static	int	 warn_child_gt(struct mdoc *, const char *, int);
static	int	 err_child_eq(struct mdoc *, const char *, int);
static	int	 warn_child_eq(struct mdoc *, const char *, int);
static	int	 warn_count(struct mdoc *, const char *, 
			int, const char *, int);
static	int	 err_count(struct mdoc *, const char *, 
			int, const char *, int);
d68 1
d71 1
a71 1
static	int	 ebool(POST_ARGS);
d79 1
a80 1
static	int	 hwarn_eq0(POST_ARGS);
d327 58
d386 2
a387 3
static inline int
warn_count(struct mdoc *m, const char *k, 
		int want, const char *v, int has)
d389 2
d392 4
a395 3
	return(mdoc_vmsg(m, MANDOCERR_ARGCOUNT, 
				m->last->line, m->last->pos, 
				"%s %s %d (have %d)", v, k, want, has));
d398 5
d404 2
a405 3
static inline int
err_count(struct mdoc *m, const char *k,
		int want, const char *v, int has)
d407 2
d410 4
a413 5
	mdoc_vmsg(m, MANDOCERR_SYNTARGCOUNT, 
			m->last->line, m->last->pos, 
			"%s %s %d (have %d)", 
			v, k, want, has);
	return(0);
d416 5
d422 5
a426 5
/*
 * Build these up with macros because they're basically the same check
 * for different inequalities.  Yes, this could be done with functions,
 * but this is reasonable for now.
 */
d428 4
a431 33
#define CHECK_CHILD_DEFN(lvl, name, ineq) 			\
static int 							\
lvl##_child_##name(struct mdoc *mdoc, const char *p, int sz) 	\
{ 								\
	if (mdoc->last->nchild ineq sz)				\
		return(1); 					\
	return(lvl##_count(mdoc, #ineq, sz, p, mdoc->last->nchild)); \
}

#define CHECK_BODY_DEFN(name, lvl, func, num) 			\
static int 							\
b##lvl##_##name(POST_ARGS) 					\
{ 								\
	if (MDOC_BODY != mdoc->last->type) 			\
		return(1); 					\
	return(func(mdoc, "multi-line arguments", (num))); 	\
}

#define CHECK_ELEM_DEFN(name, lvl, func, num) 			\
static int							\
e##lvl##_##name(POST_ARGS) 					\
{ 								\
	assert(MDOC_ELEM == mdoc->last->type); 			\
	return(func(mdoc, "line arguments", (num))); 		\
}

#define CHECK_HEAD_DEFN(name, lvl, func, num)			\
static int 							\
h##lvl##_##name(POST_ARGS) 					\
{ 								\
	if (MDOC_HEAD != mdoc->last->type) 			\
		return(1); 					\
	return(func(mdoc, "line arguments", (num)));	 	\
d434 5
d440 5
a444 18
CHECK_CHILD_DEFN(warn, gt, >)			/* warn_child_gt() */
CHECK_CHILD_DEFN(err, gt, >)			/* err_child_gt() */
CHECK_CHILD_DEFN(warn, eq, ==)			/* warn_child_eq() */
CHECK_CHILD_DEFN(err, eq, ==)			/* err_child_eq() */
CHECK_CHILD_DEFN(err, lt, <)			/* err_child_lt() */
CHECK_CHILD_DEFN(warn, lt, <)			/* warn_child_lt() */
CHECK_BODY_DEFN(ge1, warn, warn_child_gt, 0)	/* bwarn_ge1() */
CHECK_BODY_DEFN(ge1, err, err_child_gt, 0)	/* berr_ge1() */
CHECK_ELEM_DEFN(eq0, warn, warn_child_eq, 0)	/* ewarn_eq0() */
CHECK_ELEM_DEFN(ge1, warn, warn_child_gt, 0)	/* ewarn_ge1() */
CHECK_ELEM_DEFN(eq1, err, err_child_eq, 1)	/* eerr_eq1() */
CHECK_ELEM_DEFN(le1, err, err_child_lt, 2)	/* eerr_le1() */
CHECK_ELEM_DEFN(ge1, err, err_child_gt, 0)	/* eerr_ge1() */
CHECK_HEAD_DEFN(eq0, err, err_child_eq, 0)	/* herr_eq0() */
CHECK_HEAD_DEFN(le1, warn, warn_child_lt, 2)	/* hwarn_le1() */
CHECK_HEAD_DEFN(ge1, err, err_child_gt, 0)	/* herr_ge1() */
CHECK_HEAD_DEFN(eq1, warn, warn_child_eq, 1)	/* hwarn_eq1() */
CHECK_HEAD_DEFN(eq0, warn, warn_child_eq, 0)	/* hwarn_eq0() */
d903 2
d1137 5
a1141 1
		return(mdoc_nmsg(mdoc, np, MANDOCERR_ARGCOUNT));
a1237 1
	int		  i;
d1251 2
a1252 3
	if (0 == (i = mdoc->last->nchild))
		return(1);
	return(warn_count(mdoc, "==", 0, "line arguments", i));
@


1.118
log
@Consider both `Lp' and `Pp' when stripping prior paragraph marks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.117 2010/09/27 09:26:27 kristaps Exp $ */
d268 1
a268 1
	{ NULL, posts_sp },			/* sp */
@


1.117
log
@Ignore double-`Pp' and `Pp' before `Bd' and `Bl' (unless -compact is
specified).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.116 2010/08/29 10:30:58 kristaps Exp $ */
d1476 6
a1481 1
	if (NULL == mdoc->last || MDOC_Pp != mdoc->last->tok)
@


1.116
log
@Made -mdoc `Pp', `Lp', and `br' not FATAL when having arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.115 2010/08/20 01:02:07 schwarze Exp $ */
d103 1
d133 2
a134 2
static	v_pre	 pres_bd[] = { pre_display, pre_bd, NULL };
static	v_pre	 pres_bl[] = { pre_bl, NULL };
d143 1
d155 1
a155 1
	{ NULL, posts_notext },			/* Pp */ 
d1470 18
@


1.115
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.114 2010/07/26 13:45:49 kristaps Exp $ */
a66 1
static	int	 eerr_eq0(POST_ARGS);
d70 1
d120 1
a120 1
static	v_post	 posts_notext[] = { eerr_eq0, NULL };
d395 1
a398 1
CHECK_ELEM_DEFN(eq0, err, err_child_eq, 0)	/* eerr_eq0() */
@


1.114
log
@Note that `Dd' can be empty.  This found following a thread on discuss@@
started by Sascha Wildner, 07/25/2010 06:30 AM.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.113 2010/07/21 09:08:26 kristaps Exp $ */
d484 2
a485 6
			continue;
		}

		c = mdoc_pmsg(m, ln, pos, MANDOCERR_BADESCAPE);
		if ( ! (MDOC_IGN_ESCAPE & m->pflags) && ! c)
			return(c);
@


1.113
log
@Finally make mdoc argv CPP-defines into a proper enum.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.112 2010/07/20 14:56:42 kristaps Exp $ */
d148 1
a148 1
	{ pres_dd, posts_text },		/* Dd */
@


1.112
log
@Strip non-graphable input characters from input.  The manuals
specifically say that this is not allowed, and were it allowed, output
would be inconsistent across output media (-Tps will puke,
non-your-charset terminals will puke, etc.).

With this done, simplify check_text() to only check escapes and for
tabs.  Add in a new tab warning, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.111 2010/07/19 11:11:54 kristaps Exp $ */
d627 2
d951 1
a951 1
	int		  arg;
@


1.111
log
@Remove some FIXMEs: `Ms' accepts arbitrary text, so it can't/shouldn't
be converted into a symbol.

The `Pp' issue has also been fixed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.110 2010/07/13 23:53:20 schwarze Exp $ */
d456 1
a456 1
check_text(struct mdoc *mdoc, int line, int pos, char *p)
d459 1
d461 8
a468 4
	/* 
	 * FIXME: we absolutely cannot let \b get through or it will
	 * destroy some assumptions in terms of format.
	 */
a469 1
	for ( ; *p; p++, pos++) {
d471 6
a476 6
			if ( ! (MDOC_LITERAL & mdoc->flags))
				if ( ! mdoc_pmsg(mdoc, line, pos, MANDOCERR_BADCHAR))
					return(0);
		} else if ( ! isprint((u_char)*p) && ASCII_HYPH != *p)
			if ( ! mdoc_pmsg(mdoc, line, pos, MANDOCERR_BADCHAR))
				return(0);
d478 1
a478 2
		if ('\\' != *p)
			continue;
d487 2
a488 2
		c = mdoc_pmsg(mdoc, line, pos, MANDOCERR_BADESCAPE);
		if ( ! (MDOC_IGN_ESCAPE & mdoc->pflags) && ! c)
a495 2


a512 1

@


1.110
log
@correct lots of copyright notices;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.109 2010/07/04 21:59:30 kristaps Exp $ */
a34 1
/* TODO: ignoring Pp (it's superfluous in some invocations). */
@


1.109
log
@Cache column sizes and char pointer into mdoc_bl.  Finally get rid of
the loops here and there to track down the MDOC_Column arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.108 2010/07/02 17:42:23 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.108
log
@Not only for -tag lists, but for -hang, -ohang, -inset, -diag,
and -item list as well, empty bodies are OK, they do not even
warrant a warning, much less the error they were throwing.
According to kristaps, joerg@@ also brought this up some time ago.
ok kristaps@@ jmc@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.107 2010/07/02 15:03:14 kristaps Exp $ */
d650 1
a650 1
		if (LIST__NONE != lt && n->data.Bl->type == LIST__NONE)
d652 8
d1161 1
a1161 6
		cols = -1;
		for (i = 0; i < (int)n->args->argc; i++)
			if (MDOC_Column == n->args->argv[i].arg) {
				cols = (int)n->args->argv[i].sz;
				break;
			}
a1162 1
		assert(-1 != cols);
d1202 1
a1202 6
		for (i = 0; i < (int)n->args->argc; i++)
			if (MDOC_Column == n->args->argv[i].arg)
				break;
		assert(i < (int)n->args->argc);

		if (n->args->argv[i].sz && mdoc->last->nchild) {
@


1.107
log
@Cached `An' arguments in struct mdoc_an.  Note that this isn't a
pointer like the other data members, as there's no need to copy it around.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.106 2010/07/02 13:12:47 kristaps Exp $ */
a1134 3
		if (NULL == mdoc->last->body->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
				return(0);
d1143 3
a1150 3
		if (NULL == mdoc->last->body->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOBODY))
				return(0);
@


1.106
log
@Fix: was checking HEAD for arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.105 2010/07/02 12:54:33 kristaps Exp $ */
d852 1
a852 1
	if (NULL == n->args || 1 == n->args->argc)
d854 12
a865 5
	mdoc_vmsg(mdoc, MANDOCERR_SYNTARGCOUNT, 
				n->line, n->pos,
				"line arguments == 1 (have %d)",
				n->args->argc);
	return(0);
d1086 1
d1088 4
a1091 7
	if (mdoc->last->args) {
		if (NULL == mdoc->last->child)
			return(1);
		return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_ARGCOUNT));
	}

	if (mdoc->last->child)
d1093 1
a1093 1
	return(mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS));
@


1.105
log
@Stash `Bf' parameters into struct mdoc_bf.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.104 2010/07/01 22:56:17 kristaps Exp $ */
d960 2
d969 1
a969 1
	if (np->args && np->child) {
d972 1
a972 1
	} else if (NULL == np->args && NULL == np->child)
d977 2
a978 2
	if (np->args) {
		arg = np->args->argv[0].arg;
@


1.104
log
@Make struct_bl and struct_bd into pointers.  This removes the need to do
copying on internals after modification.  Even more importantly, if an
ENDBODY token is provided, it would have been impossible for post-change
copying of the data to take place in the BLOCK.  This allows it to
happen by dint of pointers.

Also did some bikeshedding in mdoc_term.c: checking against enum type
and explicitly casting to the "post" function to void.  This is for my
own readability.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.103 2010/07/01 21:44:47 kristaps Exp $ */
d934 16
a949 2
	char		 *p;
	struct mdoc_node *head;
d951 5
a955 1
	if (MDOC_BLOCK != mdoc->last->type)
d957 4
d962 4
a965 1
	head = mdoc->last->head;
d967 2
a968 3
	if (mdoc->last->args && head->child) {
		/* FIXME: this should provide a default. */
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SYNTARGVCOUNT);
d970 15
a984 1
	} else if (mdoc->last->args)
a985 5

	if (NULL == head->child || MDOC_TEXT != head->child->type) {
		/* FIXME: this should provide a default. */
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_SYNTARGVCOUNT);
		return(0);
d988 1
a988 1
	p = head->child->string;
d990 8
a997 6
	if (0 == strcmp(p, "Em"))
		return(1);
	else if (0 == strcmp(p, "Li"))
		return(1);
	else if (0 == strcmp(p, "Sy"))
		return(1);
d999 1
a999 2
	mdoc_nmsg(mdoc, head, MANDOCERR_FONTTYPE);
	return(0);
@


1.103
log
@Prevent validator from puking on ENDBODY `Bl' nodes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.102 2010/06/28 14:39:17 kristaps Exp $ */
d157 1
a157 1
	{ pres_bd, posts_bd_bk },			/* Bd */
d540 4
a543 3
	int		 i, comp, dup;
	const char	*offs, *width;
	enum mdoc_list	 lt;
d546 11
a556 8
		assert(n->parent);
		if (ENDBODY_NOT != n->end)
			return(1);
		assert(MDOC_BLOCK == n->parent->type);
		assert(MDOC_Bl == n->parent->tok);
		assert(LIST__NONE != n->parent->data.Bl.type);
		memcpy(&n->data.Bl, &n->parent->data.Bl,
				sizeof(struct mdoc_bl));
d566 2
a567 1
	assert(LIST__NONE == n->data.Bl.type);
d611 1
a611 1
			dup = n->data.Bl.comp;
d615 1
a615 1
			dup = (NULL != n->data.Bl.width);
d622 1
a622 1
				dup = (NULL != n->data.Bl.offs);
d636 1
a636 1
			n->data.Bl.comp = comp;
d638 1
a638 1
			n->data.Bl.offs = offs;
d640 1
a640 1
			n->data.Bl.width = width;
d644 1
a644 1
		if (LIST__NONE != lt && n->data.Bl.type != LIST__NONE)
d650 2
a651 2
		if (LIST__NONE != lt && n->data.Bl.type == LIST__NONE)
			n->data.Bl.type = lt;
d655 4
a658 4
		if (n->data.Bl.type == LIST__NONE)
			if (n->data.Bl.width || 
					n->data.Bl.offs || 
					n->data.Bl.comp)
d667 1
a667 1
	if (LIST__NONE == n->data.Bl.type) {
d670 1
a670 1
		n->data.Bl.type = LIST_item;
d679 1
a679 1
	switch (n->data.Bl.type) {
d681 1
a681 1
		if (n->data.Bl.width)
d695 1
a695 1
		if (NULL == n->data.Bl.width)
d711 4
a714 3
	int		 i, dup, comp;
	enum mdoc_disp 	 dt;
	const char	*offs;
d717 11
a727 6
		assert(n->parent);
		assert(MDOC_BLOCK == n->parent->type);
		assert(MDOC_Bd == n->parent->tok);
		assert(DISP__NONE != n->parent->data.Bd.type);
		memcpy(&n->data.Bd, &n->parent->data.Bd, 
				sizeof(struct mdoc_bd));
d731 2
a732 1
	assert(DISP__NONE == n->data.Bd.type);
d763 1
a763 1
				dup = (NULL != n->data.Bd.offs);
d771 1
a771 1
			dup = n->data.Bd.comp;
d786 1
a786 1
			n->data.Bd.offs = offs;
d788 1
a788 1
			n->data.Bd.comp = comp;
d792 1
a792 1
		if (DISP__NONE != dt && n->data.Bd.type != DISP__NONE)
d798 2
a799 2
		if (DISP__NONE != dt && n->data.Bd.type == DISP__NONE)
			n->data.Bd.type = dt;
d802 1
a802 1
	if (DISP__NONE == n->data.Bd.type) {
d805 1
a805 1
		n->data.Bd.type = DISP_ragged;
d1068 2
a1069 1
	lt = n->data.Bl.type;
d1161 1
a1161 1
	if (LIST_column == n->data.Bl.type) {
@


1.102
log
@Notes: this must be done later.  \b in the input will cause havoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.101 2010/06/27 17:53:27 schwarze Exp $ */
d546 2
@


1.101
log
@minor .Bk fixes:
* do not print invalid arguments verbatim (no groffs prints them, either)
* do not trigger TERMP_PREKEEP twice
* do not die from invlid arguments (groff won't die, either)
* continue to ignore even valid arguments (just like groff)
ok kristaps@@ on the previous version, before removing my last bug ;)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.100 2010/06/27 16:36:22 kristaps Exp $ */
d461 5
@


1.100
log
@Allow registers to be unset.  Implement and document the `.nr nS val'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.99 2010/06/13 21:02:49 kristaps Exp $ */
d110 1
a110 1
static	v_post	 posts_bd[] = { hwarn_eq0, bwarn_ge1, NULL };
d157 1
a157 1
	{ pres_bd, posts_bd },			/* Bd */
d248 1
a248 1
	{ NULL, posts_wline },			/* Bk */
@


1.99
log
@Allow -width for lists to be cached in mdoc_bl.  This requires some
trickery because widths may be on-the-fly recalculated.  I don't like
how these are split between mdoc_action.c and mdoc_validate.c, but for
the time being, it'll do.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.98 2010/06/12 12:38:01 kristaps Exp $ */
d809 2
@


1.98
log
@Cached `Bl -offset' into mdoc_bl.  Removed erroneous "-offset defaults
to 6n if no value is specified" and added regression tests for `Bl'
testing against the empty -offset argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.97 2010/06/12 12:10:55 kristaps Exp $ */
d535 2
a536 2
	int		 i, width, comp, dup;
	const char	*offs;
a555 1
	width = -1;
d561 1
a561 1
		offs = NULL;
d603 2
a604 3
			if (width >= 0)
				dup++;
			width = i;
d610 1
a610 1
				dup = (NULL != n->data.Bd.offs);
d627 2
d644 3
a646 1
			if (width >= 0 || n->data.Bl.offs || n->data.Bl.comp)
d669 1
a669 1
		if (width >= 0)
d683 1
a683 1
		if (width < 0)
@


1.97
log
@Moved `Bl -compact' into cached data.  This allowed the removal of
scanning the argv list in print_bvspace(), and thus the parent pointer.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.96 2010/06/12 11:58:22 kristaps Exp $ */
d535 2
a536 1
	int		 i, width, offs, comp, dup;
d556 1
a556 1
	offs = width = -1;
d562 1
d609 8
a616 3
			if (offs >= 0)
				dup++;
			offs = i;
d627 2
d644 1
a644 1
			if (width >= 0 || offs >= 0 || n->data.Bl.comp)
@


1.96
log
@`Bl' is now using a struct instead of a single enum mdoc_list for its
cached values.  You can probably guess where this is going.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.95 2010/06/12 11:41:50 kristaps Exp $ */
d535 1
a535 1
	int		 i, width, offs, cmpt, dupl;
d555 1
a555 1
	offs = width = cmpt = -1;
d560 1
a560 1
		dupl = 0;
d598 2
a599 3
			if (cmpt >= 0) 
				dupl++;
			cmpt = i;
d603 1
a603 1
				dupl++;
d608 1
a608 1
				dupl++;
d615 5
a619 3
		if (dupl)
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
				return(0);
d635 1
a635 1
			if (width >= 0 || offs >= 0 || cmpt >= 0)
@


1.95
log
@Removed stipulation that an empty `Bd -offset' will default to 6n.  Not
sure where this came about.  Added regression tests to convince myself
that this is so.  Also consolidated COMPATIBILITY notes regarding `Bd'.
Added COMPATIBILITY note to the effect that old groff pukes on `Bd
-compact -ragged' (regression test will fail on old groff).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.94 2010/06/12 11:21:44 kristaps Exp $ */
d542 3
a544 2
		assert(LIST__NONE != n->parent->data.list);
		n->data.list = n->parent->data.list;
d554 1
a554 1
	assert(LIST__NONE == n->data.list);
d622 1
a622 1
		if (LIST__NONE != lt && n->data.list != LIST__NONE)
d628 2
a629 2
		if (LIST__NONE != lt && n->data.list == LIST__NONE)
			n->data.list = lt;
d633 1
a633 1
		if (n->data.list == LIST__NONE)
d643 1
a643 1
	if (LIST__NONE == n->data.list) {
d646 1
a646 1
		n->data.list = LIST_item;
d655 1
a655 1
	switch (n->data.list) {
d1035 1
a1035 1
	lt = n->data.list;
d1127 1
a1127 1
	if (LIST_column == n->data.list) {
@


1.94
log
@Cache all of `Bd's resolved arguments into mdoc_bd, which is stashed in
the "data" union in mdoc_node.  Allows me to remove some ugly loops in
the front-end and duplicate tests in mdoc_action.c.  Add a regression
test to make sure we're not doing anything bad (more to come).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.93 2010/06/12 10:09:19 kristaps Exp $ */
d734 2
a735 17
			/*
			 * If empty, assign it to a sane default, which
			 * groff stipulates is about 8n.
			 */
			/*
			 * FIXME: remove this.
			 *
			 * Where the hell did I get the idea that this
			 * happens?
			 */
			assert(1 == n->args->refcnt);
			n->args->argv[i].sz++;
			n->args->argv[i].value = 
				mandoc_malloc(sizeof(char *));
			n->args->argv[i].value[0] = 
				mandoc_strdup("8n");
			offs = n->args->argv[i].value[0];
@


1.93
log
@Added enum mdoc_disp (similar to enum mdoc_list).  Display types are now
only calculated once in mdoc_validate.c.

Noted that `Bd -file xxx' is not supported:  it now raises a fatal
warning.  This is noted in mdoc.7.

Empty `Bd' now defaults to LIST_ragged, which is not quite what groff
does, but close enough (gross just throws away the `Bd' and gets upset
when it encounters an `Ed').
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.92 2010/06/09 19:22:56 kristaps Exp $ */
d686 1
a686 1
	int		 i;
d688 1
d694 3
a696 2
		assert(DISP__NONE != n->parent->data.disp);
		n->data.disp = n->parent->data.disp;
d700 1
a700 1
	assert(DISP__NONE == n->data.disp);
d705 3
d728 24
a751 1
			/* FALLTHROUGH */
d753 3
a755 1
			/* FALLTHROUGH */
d757 2
a758 1
			break;
d761 15
a775 1
		if (DISP__NONE != dt && n->data.disp != DISP__NONE)
d779 4
a782 2
		if (DISP__NONE != dt && n->data.disp == DISP__NONE)
			n->data.disp = dt;
d785 1
a785 1
	if (DISP__NONE == n->data.disp) {
d788 1
a788 1
		n->data.disp = DISP_ragged;
@


1.92
log
@Squash bug noted by Ulrich Spoerlein where "-" were being converted to
ASCII_HYPH, as per normal, but were screwing up mandoc_special().  Fixed
by making mandoc_special() first check isspace() instead of ! isgraph(),
then normalise its string as it passes out.  This require de-constifying
some validation routines not already de-constified (those in libman),
but that's ok, because I'd like to be pushing actions into validation
routines to save on space and redundant calculations.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.91 2010/06/03 13:44:36 kristaps Exp $ */
d686 2
a687 1
	int		 i, type, err;
d689 6
a694 1
	if (MDOC_BLOCK != n->type)
a695 3
	if (NULL == n->args) {
		mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE);
		return(0);
d698 1
a698 1
	/* Make sure that only one type of display is specified.  */
d701 2
a702 2
	for (i = 0, err = type = 0; ! err && 
			i < (int)n->args->argc; i++)
d705 2
a706 1
			/* FALLTHROUGH */
d708 2
a709 1
			/* FALLTHROUGH */
d711 2
a712 1
			/* FALLTHROUGH */
d714 2
a715 1
			/* FALLTHROUGH */
d717 1
a717 4
			if (0 == type++) 
				break;
			if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_DISPREP))
				return(0);
d719 7
d730 15
a744 4
	if (type)
		return(1);
	mdoc_nmsg(mdoc, n, MANDOCERR_DISPTYPE);
	return(0);
@


1.91
log
@Consolidated list processing to a single loop in mdoc_validate.c.  This
relieves having to repeat running over the argument list in
mdoc_action.c and mdoc_validate.c.

Default to LIST_item for type-less lists (groff technically doesn't do
this: it just ignores the `It' lines altogether).

Make MANDOC_LISTTYPE be a recoverable error.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.90 2010/05/31 23:40:25 kristaps Exp $ */
d50 1
a50 1
static	int	 check_text(struct mdoc *, int, int, const char *);
d52 2
a53 4
			const struct mdoc_node *,
			const struct mdoc_argv *);
static	int	 check_args(struct mdoc *, 
			const struct mdoc_node *);
d278 1
a278 1
	const char	*tp;
d420 1
a420 1
check_args(struct mdoc *m, const struct mdoc_node *n)
d437 1
a437 2
check_argv(struct mdoc *m, const struct mdoc_node *n, 
		const struct mdoc_argv *v)
d457 1
a457 1
check_text(struct mdoc *mdoc, int line, int pos, const char *p)
@


1.90
log
@Cleanup post_bl_head() to use enum mdoc_list (avoid traversing that
list).

Reverted MANDOC_COLUMNS to be a bad-bad syntax error: we don't, and
apparently never have, allowed mixing of -column syntaxes.  This would
have segfaulted if encountered.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.89 2010/05/31 23:10:51 kristaps Exp $ */
d37 1
a37 1
#define	PRE_ARGS  struct mdoc *mdoc, const struct mdoc_node *n
d276 1
a276 1
mdoc_valid_pre(struct mdoc *mdoc, const struct mdoc_node *n)
d538 2
a539 1
	int		 pos, type, width, offset;
d541 6
a546 1
	if (MDOC_BLOCK != n->type)
a547 3
	if (NULL == n->args) {
		mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE);
		return(0);
d550 5
a554 1
	/* Make sure that only one type of list is specified.  */
d556 2
a557 1
	type = offset = width = -1;
d560 5
a564 2
	for (pos = 0; pos < (int)n->args->argc; pos++)
		switch (n->args->argv[pos].arg) {
d566 2
a567 1
			/* FALLTHROUGH */
d569 2
a570 1
			/* FALLTHROUGH */
d572 2
a573 1
			/* FALLTHROUGH */
d575 2
a576 1
			/* FALLTHROUGH */
d578 2
a579 1
			/* FALLTHROUGH */
d581 2
a582 1
			/* FALLTHROUGH */
d584 2
a585 1
			/* FALLTHROUGH */
d587 2
a588 1
			/* FALLTHROUGH */
d590 2
a591 1
			/* FALLTHROUGH */
d593 2
a594 1
			/* FALLTHROUGH */
d596 3
a598 7
			if (type < 0) {
				type = n->args->argv[pos].arg;
				break;
			}
			if (mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP))
				break;
			return(0);
d600 4
a603 5
			if (type >= 0)
				break;
			if (mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				break;
			return(0);
d606 2
a607 5
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
					return(0);
			if (type < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				return(0);
			width = n->args->argv[pos].arg;
d610 3
a612 8
			if (offset >= 0)
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_ARGVREP))
					return(0);
			if (type < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				return(0);
			offset = n->args->argv[pos].arg;
			break;
		default:
d616 33
a648 3
	if (type < 0) {
		mdoc_nmsg(mdoc, n, MANDOCERR_LISTTYPE);
		return(0);
d657 8
a664 6
	switch (type) {
	case (MDOC_Tag):
		if (width < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_NOWIDTHARG))
			return(0);
		break;
	case (MDOC_Column):
d666 1
a666 1
	case (MDOC_Diag):
d668 1
a668 1
	case (MDOC_Ohang):
d670 1
a670 1
	case (MDOC_Inset):
d672 6
a677 4
	case (MDOC_Item):
		if (width >= 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_WIDTHARG))
			return(0);
		break;
@


1.89
log
@Clean up the validation code for `It' macros:  use enum mdoc_list
instead of iterating over arguments and only scan with `-column', which
needs the count of arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.88 2010/05/31 10:28:04 kristaps Exp $ */
d1027 2
a1028 3
	int			i;
	const struct mdoc_node *n;
	const struct mdoc_argv *a;
d1030 1
a1031 1
	assert(n->args);
d1033 9
a1041 6
	for (i = 0; i < (int)n->args->argc; i++) {
		a = &n->args->argv[i];
		if (a->arg == MDOC_Column) {
			if (a->sz && mdoc->last->nchild)
				return(mdoc_nmsg(mdoc, n, MANDOCERR_COLUMNS));
			return(1);
d1043 1
@


1.88
log
@Remove enum mdocargerr from phrase() (unused).

Add `Ta' macro, which is basically a NULL case everywhere but in
mdoc_macro.c, where it closes out an existing `It' body scope and opens
a new one, then continues parsing as in phrase() (TODO: merge these
two?).

Fix where scope-breaking was silently just dying instead of printing an
error.

Fix where trailing `Ta' or tab weren't creating a new MDOC_BODY context.

We now support arbitrarily complex `It' contents for `Bl -column'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.87 2010/05/30 22:56:02 kristaps Exp $ */
d932 2
a933 2
	/* FIXME: use mdoc_list! */
	int		  type, i, cols;
d935 1
d941 3
a943 1
	if (NULL == n->args) {
d948 3
a950 26
	/* Some types require block-head, some not. */

	/* LINTED */
	for (cols = type = -1, i = 0; -1 == type && 
			i < (int)n->args->argc; i++)
		switch (n->args->argv[i].arg) {
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Item):
			type = n->args->argv[i].arg;
d952 3
a954 18
		case (MDOC_Column):
			type = n->args->argv[i].arg;
			cols = (int)n->args->argv[i].sz;
			break;
		default:
			break;
		}

	if (-1 == type) {
		mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_LISTTYPE);
		return(0);
	}

	switch (type) {
	case (MDOC_Tag):
		if (NULL == mdoc->last->head->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
				return(0);
d956 1
a956 1
	case (MDOC_Hang):
d958 1
a958 1
	case (MDOC_Ohang):
d960 1
a960 1
	case (MDOC_Inset):
d962 1
a962 1
	case (MDOC_Diag):
d970 1
a970 1
	case (MDOC_Bullet):
d972 1
a972 1
	case (MDOC_Dash):
d974 1
a974 1
	case (MDOC_Enum):
d976 1
a976 1
	case (MDOC_Hyphen):
d978 1
a978 1
	case (MDOC_Item):
d986 9
a994 1
	case (MDOC_Column):
d996 1
d1001 1
a1001 3
		/* Count up the number of columns.  */
		c = mdoc->last->child;
		for (i = 0; c; c = c->next)
d1005 3
a1007 9
		if (i < cols) {
			if ( ! mdoc_vmsg(mdoc, MANDOCERR_ARGCOUNT,
					mdoc->last->line, 
					mdoc->last->pos, 
					"columns == %d (have %d)",
					cols, i))
				return(0);
			break;
		} else if (i == cols || i == cols + 1)
d1009 2
d1012 1
a1012 1
		mdoc_vmsg(mdoc, MANDOCERR_SYNTARGCOUNT,
d1015 1
a1015 1
		return(0);
@


1.87
log
@Migrate `Bl -column' phrases to be MDOC_BODY instead of MDOC_HEAD.  This
will make it easy for re-entrant parsing of `Ta' macros to fit in with
standard closure rules.

Added some more regressions for `Bl -column'.  Note that one should
fail, as documented in the TODO file.

Recorded change of AST BNF in mdoc.3.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.86 2010/05/30 11:47:44 kristaps Exp $ */
d271 1
@


1.86
log
@Make check for case a little more intuitive (suggested by joerg@@).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.85 2010/05/30 11:00:53 kristaps Exp $ */
d931 1
d1021 3
a1023 5
		if (NULL == mdoc->last->head->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_NOARGS))
				return(0);
		if (mdoc->last->body->child)
			if ( ! mdoc_nmsg(mdoc, mdoc->last, MANDOCERR_BODYLOST))
d1025 2
d1028 3
a1030 2
		for (i = 0; c && MDOC_HEAD == c->type; c = c->next)
			i++;
@


1.85
log
@Made `Dt' default to LOCAL and UNKNOWN instead of local and unknown (note case).

Have `Dt' default to UNKNOWN if it's an empty string.

Raise a warning if `Dt' title isn't capitalised.

Sync'd `Dt' documentation with reality.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.84 2010/05/26 10:39:35 kristaps Exp $ */
d750 1
a750 3
			if ( ! isalpha((u_char)*p))
				continue;
			if (isupper((u_char)*p))
@


1.84
log
@Documented `Ud'.

Proper EOS handling for `Rv', `Ex', `Ud', and `Bt'.

Both `Bt' and `Ud' now warn about and discard line arguments (reported
by Ulrich Spoerlein).

Collapsed posts_xr into posts_wtext (harmless: they're the same thing).

Added regressions for `Ud' and `Bt'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.83 2010/05/26 09:35:35 kristaps Exp $ */
d86 1
d117 1
d152 1
a152 1
	{ pres_dt, NULL },			/* Dt */
d743 21
a766 2
	/* FIXME: make sure is capitalised. */

@


1.83
log
@Fixed `Lb' to be in_line (reported by Ulrich Spoerlein).

Added `Lb' documentation to mdoc.7.

Removed harmless but superfluous pre_lb check (was just NULL entries).

Added regressions for `Lb' (NOTE that these will only run on new groff,
as old groff doesn't support `Lb' at all).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.82 2010/05/25 12:44:53 kristaps Exp $ */
d95 1
d115 1
a131 1
static	v_post	 posts_xr[] = { ewarn_ge1, NULL };
d188 1
a188 1
	{ NULL, posts_xr },			/* Xr */ 
d250 1
a250 1
	{ NULL, posts_notext },			/* Bt */
d253 1
a253 1
	{ NULL, posts_notext },			/* Ud */
d395 1
a395 1
CHECK_ELEM_DEFN(ge1, warn, warn_child_gt, 0)	/* ewarn_gt1() */
d833 10
@


1.82
log
@Smarten BADCHAR check to allow ASCII_HYPH.
Fix index.sgml not to puke (the relevant section will be re-written for the release anyway, but I hate seeing errors).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.81 2010/05/24 12:31:16 kristaps Exp $ */
a140 1
static	v_pre	 pres_lb[] = { NULL, NULL };
d253 1
a253 1
	{ pres_lb, posts_lb },			/* Lb */
@


1.81
log
@Lifted 64-byte max width for Sh (now BUFSIZ).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.80 2010/05/17 23:57:06 kristaps Exp $ */
d466 1
a466 1
		} else if ( ! isprint((u_char)*p))
@


1.80
log
@Increase performance by stashing the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can known whether to
dump list line arguments into the body (`Bl -column' overflowing).

Remove a2list() and arg_listtype() because of this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.79 2010/05/17 22:11:42 kristaps Exp $ */
d26 1
d1228 1
a1228 1
	char		        buf[64];
d1250 1
a1250 1
		if (strlcat(buf, n->string, 64) >= 64) {
d1256 1
a1256 1
		if (strlcat(buf, " ", 64) >= 64) {
@


1.79
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.78 2010/05/15 16:24:38 kristaps Exp $ */
d571 2
a572 13
			/*
			 * Note that if a duplicate is detected, we
			 * remove the duplicate instead of passing it
			 * over.  If we don't do this, mdoc_action will
			 * become confused when it scans over multiple
			 * types whilst setting its bitmasks.
			 *
			 * FIXME: this should occur in mdoc_action.c.
			 */
			if (type >= 0) {
				if ( ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTREP))
					return(0);
				mdoc_argn_free(n->args, pos);
d575 3
a577 2
			type = n->args->argv[pos].arg;
			break;
d579 5
a583 3
			if (type < 0 && ! mdoc_nmsg(mdoc, n, MANDOCERR_LISTFIRST))
				return(0);
			break;
@


1.78
log
@LIBRARY can also occur in section 9.
All manual sections (unknown, 3p, 3f, etc.) correctly handled by -mdoc.
Useful warning printed if unknown manual section.
Checking for manual sections (e.g., LIBRARY) checks only first character, so 3p, 3f, etc. are free.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.77 2010/05/14 17:54:26 kristaps Exp $ */
d29 1
d325 3
a327 2
	return(mdoc_vwarn(m, m->last->line, m->last->pos, 
		"suggests %s %s %d (has %d)", v, k, want, has));
d336 5
a340 2
	return(mdoc_verr(m, m->last->line, m->last->pos,
		"requires %s %s %d (has %d)", v, k, want, has));
d413 1
a413 1
	return(mdoc_nwarn(mdoc, n, EARGVAL));
a444 1
		/* `Nm' name must be set. */
d447 2
a448 1
		return(mdoc_nerr(m, n, ENAME));
d463 1
a463 1
				if ( ! mdoc_pwarn(mdoc, line, pos, EPRINT))
d466 1
a466 1
			if ( ! mdoc_pwarn(mdoc, line, pos, EPRINT))
d478 4
a481 4
		if ( ! (MDOC_IGN_ESCAPE & mdoc->pflags))
			return(mdoc_perr(mdoc, line, pos, EESCAPE));
		if ( ! mdoc_pwarn(mdoc, line, pos, EESCAPE))
			return(0);
d499 5
a503 2
	return(mdoc_verr(mdoc, n->line, n->pos, "require parent %s",
		MDOC_ROOT == t ? "<root>" : mdoc_macronames[tok]));
d526 2
a527 1
	return(mdoc_nerr(mdoc, n, ENESTDISP));
d538 4
a541 2
	if (NULL == n->args)
		return(mdoc_nerr(mdoc, n, ELISTTYPE));
d581 1
a581 1
				if ( ! mdoc_nwarn(mdoc, n, EMULTILIST))
d589 1
a589 1
			if (type < 0 && ! mdoc_nwarn(mdoc, n, ENOTYPE))
d594 3
a596 2
				return(mdoc_nerr(mdoc, n, EARGREP));
			if (type < 0 && ! mdoc_nwarn(mdoc, n, ENOTYPE))
d602 3
a604 2
				return(mdoc_nerr(mdoc, n, EARGREP));
			if (type < 0 && ! mdoc_nwarn(mdoc, n, ENOTYPE))
d612 4
a615 2
	if (type < 0)
		return(mdoc_nerr(mdoc, n, ELISTTYPE));
d625 1
a625 1
		if (width < 0 && ! mdoc_nwarn(mdoc, n, EMISSWIDTH))
d637 1
a637 1
		if (width >= 0 && ! mdoc_nwarn(mdoc, n, ENOWIDTH))
d655 4
a658 2
	if (NULL == n->args) 
		return(mdoc_nerr(mdoc, n, EDISPTYPE));
d677 3
a679 1
			return(mdoc_nerr(mdoc, n, EMULTIDISP));
d686 2
a687 1
	return(mdoc_nerr(mdoc, n, EDISPTYPE));
d717 4
d731 5
a735 2
	return(mdoc_verr(mdoc, n->line, n->pos, 
				"only one argument allowed"));
d754 1
a754 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLOOO))
d757 1
a757 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLREP))
d768 1
a768 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLOOO))
d771 1
a771 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLREP))
d782 1
a782 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLOOO))
d785 1
a785 1
		if ( ! mdoc_nwarn(mdoc, n, EPROLREP))
d802 5
a806 3
	if (mdoc->last->args && head->child)
		return(mdoc_nerr(mdoc, mdoc->last, ELINE));
	else if (mdoc->last->args)
d809 5
a813 2
	if (NULL == head->child || MDOC_TEXT != head->child->type)
		return(mdoc_nerr(mdoc, mdoc->last, ELINE));
d824 2
a825 1
	return(mdoc_nerr(mdoc, head, EFONT));
d835 1
a835 1
	return(mdoc_nwarn(mdoc, mdoc->last, ELIB));
d858 1
a858 1
			if ( ! mdoc_nwarn(mdoc, n, EBADCHILD))
d873 1
a873 1
	return(mdoc_nerr(mdoc, mdoc->last, ENAME));
d883 1
a883 2
	if (MDOC_TEXT != mdoc->last->child->type)
		return(mdoc_nerr(mdoc, mdoc->last, EATT));
d886 1
a886 1
	return(mdoc_nwarn(mdoc, mdoc->last, EATT));
d897 1
a897 1
		return(mdoc_nerr(mdoc, mdoc->last, ENOLINE));
d902 1
a902 1
	return(mdoc_nerr(mdoc, mdoc->last, ELINE));
d916 4
a919 2
	if (NULL == n->args)
		return(mdoc_nerr(mdoc, mdoc->last, ELISTTYPE));
d956 4
a959 2
	if (-1 == type)
		return(mdoc_nerr(mdoc, mdoc->last, ELISTTYPE));
d964 1
a964 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ELINE))
d975 1
a975 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ELINE))
d978 1
a978 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, EMULTILINE))
d991 1
a991 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ENOLINE))
d994 1
a994 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, EMULTILINE))
d999 1
a999 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ELINE))
d1002 1
a1002 1
			if ( ! mdoc_nwarn(mdoc, mdoc->last, ENOMULTILINE))
d1009 5
a1013 4
			if ( ! mdoc_vwarn(mdoc, mdoc->last->line, 
					mdoc->last->pos, "column "
					"mismatch: have %d, want %d", 
					i, cols))
d1019 4
a1022 3
		return(mdoc_verr(mdoc, mdoc->last->line, 
				mdoc->last->pos, "column mismatch: "
				"have %d, want %d", i, cols));
d1045 1
a1045 1
				return(mdoc_nerr(mdoc, n, ECOLMIS));
d1080 2
a1081 1
		return(mdoc_nerr(mdoc, n, EBADCHILD));
d1106 1
a1106 1
	return(mdoc_nerr(mdoc, n, EBOOL));
d1115 9
a1123 8
		return(mdoc_nerr(mdoc, mdoc->first, ENODAT));
	if ( ! (MDOC_PBODY & mdoc->flags))
		return(mdoc_nerr(mdoc, mdoc->first, ENOPROLOGUE));

	if (MDOC_BLOCK != mdoc->first->child->type)
		return(mdoc_nerr(mdoc, mdoc->first, ENODAT));
	if (MDOC_Sh != mdoc->first->child->tok)
		return(mdoc_nerr(mdoc, mdoc->first, ENODAT));
d1125 1
a1125 1
	return(1);
d1135 1
a1135 1
	return(mdoc_nwarn(mdoc, mdoc->last, EBADSTAND));
d1178 2
a1179 1
			return(mdoc_nerr(mdoc, nn, EBADCHILD));
d1214 1
a1214 1
		return(mdoc_nwarn(mdoc, mdoc->last, ENAMESECINC));
d1221 1
a1221 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ENAMESECINC))
d1228 1
a1228 1
	return(mdoc_nwarn(mdoc, mdoc->last, ENAMESECINC));
d1246 6
a1251 1
	buf[0] = 0;
d1257 4
a1260 2
		if (strlcat(buf, n->string, 64) >= 64)
			return(mdoc_nerr(mdoc, n, ETOOLONG));
d1263 4
a1266 2
		if (strlcat(buf, " ", 64) >= 64)
			return(mdoc_nerr(mdoc, n, ETOOLONG));
d1277 1
a1277 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ESECNAME))
d1284 1
a1284 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ESECREP))
d1288 1
a1288 1
		if ( ! mdoc_nwarn(mdoc, mdoc->last, ESECOOO))
d1305 1
a1305 1
		return(mdoc_nwarn(mdoc, mdoc->last, EWRONGMSEC));
@


1.77
log
@Remove in-manual-section warnings for Fd and Lb (ok joerg@@, schwarze@@).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.76 2010/05/14 17:31:25 kristaps Exp $ */
d1243 1
a1243 1
	 * only occur in msec 2, 3 (TODO: are there more of these?).
d1248 6
a1253 4
		switch (mdoc->meta.msec) {
		case (2):
			/* FALLTHROUGH */
		case (3):
d1255 1
a1255 4
		default:
			return(mdoc_nwarn(mdoc, mdoc->last, EWRONGMSEC));
		}
		break;
@


1.76
log
@Backed out check for `Ex' manual sec (ok schwarze@@, joerg@@), in turn backing out check_msec() and deps.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.75 2010/05/14 16:02:29 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
a25 1
#include <stdarg.h>
a46 1
static	int	 check_sec(PRE_ARGS, ...);
a99 1
static	int	 pre_fd(PRE_ARGS);
a100 1
static	int	 pre_lb(PRE_ARGS);
d137 1
a137 1
static	v_pre	 pres_fd[] = { pre_fd, NULL };
d139 1
a139 1
static	v_pre	 pres_lb[] = { pre_lb, NULL };
a412 24
check_sec(PRE_ARGS, ...)
{
	enum mdoc_sec	 sec;
	va_list		 ap;

	va_start(ap, n);

	for (;;) {
		/* LINTED */
		sec = (enum mdoc_sec)va_arg(ap, int);
		if (SEC_CUSTOM == sec)
			break;
		if (sec != mdoc->lastsec)
			continue;
		va_end(ap);
		return(1);
	}

	va_end(ap);
	return(mdoc_nwarn(mdoc, n, EBADSEC));
}


static int
a712 8
pre_lb(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_LIBRARY, SEC_CUSTOM));
}


static int
a1262 8


static int
pre_fd(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_SYNOPSIS, SEC_CUSTOM));
}
@


1.75
log
@"Warn on unknown argument for .At and print it like [new] groff." (patch by Joerg Sonnenberger, ed. Kristaps)
Keep short-log of commits in index.sgml.
Document compatibility with new/old groff in mdoc.7.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.74 2010/05/14 15:26:39 kristaps Exp $ */
a47 1
static	int	 check_msec(PRE_ARGS, ...);
a101 1
static	int	 pre_ex(PRE_ARGS);
d140 1
a140 1
static	v_pre	 pres_ex[] = { pre_ex, NULL };
a440 22
check_msec(PRE_ARGS, ...)
{
	va_list		 ap;
	int		 msec;

	va_start(ap, n);
	for (;;) {
		/* LINTED */
		if (0 == (msec = va_arg(ap, int)))
			break;
		if (msec != mdoc->meta.msec)
			continue;
		va_end(ap);
		return(1);
	}

	va_end(ap);
	return(mdoc_nwarn(mdoc, n, EBADMSEC));
}


static int
a756 10
pre_ex(PRE_ARGS)
{

	if ( ! check_msec(mdoc, n, 1, 6, 8, 0))
		return(0);
	return(check_stdarg(mdoc, n));
}


static int
@


1.74
log
@"Invalid standard argument should be a warning. Just leak it into the
output." (patch by Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.73 2010/05/14 14:34:29 kristaps Exp $ */
d924 1
a924 1
	return(mdoc_nerr(mdoc, mdoc->last, EATT));
@


1.73
log
@"If the last column wasn't specified, it is auto-sized." (patch by Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.72 2010/05/12 08:41:17 kristaps Exp $ */
d1165 1
a1165 1
	return(mdoc_nerr(mdoc, mdoc->last, EBADSTAND));
@


1.72
log
@mdoc_atosec -> mdoc_str2sec (consistent with str2 being different from a2).
Changed ordering of sections (EXIT STATUS moved around), argued for by Ulrich Sporlein.
Fixed mdoc_str2sec not to use weird structure.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.71 2010/05/09 21:19:42 kristaps Exp $ */
d1042 1
a1042 1
		if (i < cols || i == (cols + 1)) {
d1049 1
a1049 1
		} else if (i == cols)
@


1.71
log
@Remove -fno-ign-chars as well-argued by Ingo Schwarze.  Patch by Ingo Schwarze, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.70 2010/05/08 07:30:19 kristaps Exp $ */
d1289 1
a1289 1
	sec = mdoc_atosec(buf);
d1296 4
a1299 3
	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed && 
			! mdoc_nwarn(mdoc, mdoc->last, ESECNAME))
		return(0);
d1302 1
d1306 1
@


1.70
log
@Lint fixes (type-safety for enums via -cefuh).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.69 2010/04/07 19:35:42 kristaps Exp $ */
a62 1
static	int	 warn_print(struct mdoc *, int, int);
a324 10
static int
warn_print(struct mdoc *m, int ln, int pos)
{

	if (MDOC_IGN_CHARS & m->pflags)
		return(mdoc_pwarn(m, ln, pos, EPRINT));
	return(mdoc_perr(m, ln, pos, EPRINT));
}


d510 1
a510 1
				if ( ! warn_print(mdoc, line, pos))
d513 1
a513 1
			if ( ! warn_print(mdoc, line, pos))
@


1.69
log
@Removed manual-section-calling restrictions for `Cd' and and `Ex' (requested by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.68 2010/04/07 18:50:35 kristaps Exp $ */
d750 1
a750 1
	return(check_parent(mdoc, n, -1, MDOC_ROOT));
@


1.68
log
@Allowing `Cd' to be in section 9 (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.67 2010/04/06 17:01:27 kristaps Exp $ */
a100 1
static	int	 pre_cd(PRE_ARGS);
a138 1
static	v_pre	 pres_cd[] = { pre_cd, NULL };
d170 1
a170 1
	{ pres_cd, posts_text },		/* Cd */ 
a786 2
	if ( ! check_msec(mdoc, n, 2, 3, 0))
		return(0);
a801 8
pre_cd(PRE_ARGS)
{

	return(check_msec(mdoc, n, 4, 9, 0));
}


static int
@


1.67
log
@Removed warning for `Er' when not used in certain sections (pointed out by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.66 2010/04/06 16:27:53 kristaps Exp $ */
d809 1
a809 1
	return(check_msec(mdoc, n, 4, 0));
@


1.66
log
@Allow `Bd' to accept (warn about then ignore) in-line arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.65 2010/04/06 11:52:25 kristaps Exp $ */
a104 1
static	int	 pre_er(PRE_ARGS);
d144 1
a144 1
static	v_pre	 pres_er[] = { pre_er, NULL };
a805 8
pre_er(PRE_ARGS)
{

	return(check_msec(mdoc, n, 2, 3, 9, 0));
}


static int
@


1.65
log
@Cleaned up post_bl_head() and fixed erroneous reporting of child nodes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.64 2010/04/06 11:28:17 kristaps Exp $ */
d80 1
d117 1
a117 1
static	v_post	 posts_bd[] = { herr_eq0, bwarn_ge1, NULL };
d418 1
@


1.64
log
@Let `Bl' accept arguments on the head line with a warning (these are ignored in the front-end device) (noted by Theo de Raadt).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.63 2010/04/03 14:25:12 kristaps Exp $ */
d1098 1
d1103 8
a1110 3
	for (i = 0; i < (int)n->args->argc; i++)
		if (n->args->argv[i].arg == MDOC_Column)
			break;
d1112 3
a1114 8
	if (i == (int)n->args->argc && n->nchild)
		return(warn_count(mdoc, "==", 0, 
				"line arguments", n->nchild));

	if (n->args->argv[i].sz && mdoc->last->child)
		return(mdoc_nerr(mdoc, n, ECOLMIS));

	return(1);
@


1.63
log
@Merged patch by Ingo Schwarze allowing `Xr' to pass through with no arguments (emits warning of course).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.62 2010/04/03 14:12:48 kristaps Exp $ */
d1106 3
a1108 2
	if (i == (int)n->args->argc)
		return(1);
@


1.62
log
@Modified version of Ingo Schwarze's patch so that -man doesn't puke when a TH isn't specified.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.61 2010/04/03 14:02:10 kristaps Exp $ */
d136 1
a136 1
static	v_post	 posts_xr[] = { eerr_ge1, NULL };
@


1.61
log
@Merged Ingo Schwarze's patch (plus documentation) for removing extraneous list types, which happens fairly often.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.60 2010/04/03 13:02:35 kristaps Exp $ */
d630 2
@


1.60
log
@Merging patch by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.59 2010/03/31 07:13:53 kristaps Exp $ */
d624 13
a636 2
			if (type >= 0) 
				return(mdoc_nerr(mdoc, n, EMULTILIST));
@


1.59
log
@Macro types enum-ated (enum mdoct) (for easier debugging in gdb of "tok" values).
Initial check-in of Ingo Schwarze's patch for Xo/Xc handling (in blocks ifdef'd "UGLY").
Put Oc-close-Op parts into UGLY ifdef blocks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.58 2010/02/17 19:28:11 kristaps Exp $ */
d1311 3
a1313 2
	if (SEC_NAME != sec && SEC_NONE == mdoc->lastnamed)
		return(mdoc_nerr(mdoc, mdoc->last, ESECNAME));
@


1.58
log
@Made `Xr' compatible with groff calling conventions where arguments following the
trailing section are implicitly `Ns'd.  Based on a patch submitted by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.57 2010/01/30 08:42:21 kristaps Exp $ */
d47 1
a47 1
static	int	 check_parent(PRE_ARGS, int, enum mdoc_type);
d550 1
a550 1
check_parent(PRE_ARGS, int tok, enum mdoc_type t)
@


1.57
log
@Fix in handling Vt in SYNOPSIS with trailing punctuation.  Spotted by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.56 2010/01/01 17:14:30 kristaps Exp $ */
a74 1
static	int	 eerr_le2(POST_ARGS);
d136 1
a136 1
static	v_post	 posts_xr[] = { eerr_ge1, eerr_le2, NULL };
a409 1
CHECK_ELEM_DEFN(le2, err, err_child_lt, 3)	/* eerr_le2() */
@


1.56
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.55 2010/01/01 15:14:03 kristaps Exp $ */
d97 1
d134 1
d195 1
a195 1
	{ NULL, posts_text },			/* Vt */ 
d896 26
@


1.55
log
@`Bl' lets `Sm' slip by as a child.  Noted by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.54 2009/11/02 06:22:46 kristaps Exp $ */
d17 4
a68 4
#ifdef __linux__
extern	size_t	 strlcat(char *, const char *, size_t);
#endif

@


1.54
log
@Added mandoc_a2time() for proper date conversion.
Fitted TH and Dd handlers to use mandoc_a2time().
Documented date syntax for -man, fixed documentation for -mdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.53 2009/10/31 08:34:12 kristaps Exp $ */
d1089 6
d1097 4
a1100 3
		if (MDOC_BLOCK == n->type) 
			if (MDOC_It == n->tok)
				continue;
@


1.53
log
@Fixed -Thtml printing of -ohang lists (-mdoc).
Fixed validation of -ohang lists as having no widths.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.52 2009/10/31 06:10:58 kristaps Exp $ */
d197 1
a197 1
	{ NULL, posts_text },			/* %D */
d811 2
@


1.52
log
@Using perror() instead of fprintf for failure from library functions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.51 2009/10/26 04:09:46 kristaps Exp $ */
d668 2
@


1.51
log
@Full `%U' support.
`Lk' display fixed.
Renamed arg2xxxx as a2xxxx for consistency.
Renamed print_foot to print_man_foot for consistency.
Removed default printing of `~' when `Lk' not provided (not sure where I got that from).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.50 2009/10/24 05:52:14 kristaps Exp $ */
a20 1
#include <errno.h>
@


1.50
log
@Added `%U' to -mdoc (doesn't render in a nice way yet).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.49 2009/10/22 10:35:33 kristaps Exp $ */
a121 1
static	v_post	 posts_in[] = { eerr_eq1, NULL };
a126 1
static	v_post	 posts_pf[] = { eerr_eq1, NULL };
d133 1
d184 1
a184 1
	{ NULL, posts_in },			/* In */ 
d232 1
a232 1
	{ NULL, posts_pf },			/* Pf */
d263 1
a263 1
	{ NULL, NULL },				/* Lk */ 
d275 1
a275 1
	{ NULL, posts_text },			/* %U */
@


1.49
log
@Fix adding -centred to `Bd' types (thanks to Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.48 2009/10/19 09:40:23 kristaps Exp $ */
d276 1
d1159 2
@


1.48
log
@Fixed `-file' argument to `Bd', which is NOT a type, but instead just an argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.47 2009/10/19 07:34:44 kristaps Exp $ */
d699 2
@


1.47
log
@Beginning of mdoc.7 full-reference in place.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.46 2009/10/18 13:26:16 kristaps Exp $ */
a705 2
			/* FALLTHROUGH */
		case (MDOC_File):
@


1.46
log
@Removed restrictions on `sp' (maybe a warning, someday, but for now be simple).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.45 2009/10/15 02:56:51 kristaps Exp $ */
d198 1
a198 1
	{ NULL, posts_text },			/* %B */
d206 1
a206 1
	{ NULL, posts_text },			/* %T */
@


1.45
log
@Added warning about specifying list arguments before type (suggested by Joerg Sonnenberg).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.44 2009/09/24 15:08:41 kristaps Exp $ */
d77 1
a96 1
static	int	 post_sp(POST_ARGS);
d131 1
a131 1
static	v_post	 posts_sp[] = { post_sp, NULL };
d411 1
a1138 31
post_sp(POST_ARGS)
{
	long		 lval;
	char		*ep, *buf;

	if (NULL == mdoc->last->child)
		return(1);
	else if ( ! eerr_eq1(mdoc))
		return(0);

	assert(MDOC_TEXT == mdoc->last->child->type);
	buf = mdoc->last->child->string;
	assert(buf);
	
	/* From OpenBSD's strtol(3). */
	errno = 0;
	lval = strtol(buf, &ep, 10);
	if (buf[0] == '\0' || *ep != '\0')
		return(mdoc_nerr(mdoc, mdoc->last->child, ENUMFMT));

	if ((errno == ERANGE && (lval == LONG_MAX || lval == LONG_MIN)) ||
			(lval > INT_MAX || lval < 0))
		return(mdoc_nerr(mdoc, mdoc->last->child, ENUMFMT));

	return(1);
}




static int
@


1.44
log
@Fixed segfault in `Rs' empty block.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.43 2009/09/24 15:01:06 kristaps Exp $ */
d624 1
a624 1
			if (-1 != type) 
d628 4
d633 1
a633 1
			if (-1 != width)
d635 2
d640 1
a640 1
			if (-1 != offset)
d642 2
d650 1
a650 1
	if (-1 == type)
d661 1
a661 1
		if (-1 == width && ! mdoc_nwarn(mdoc, n, EMISSWIDTH))
d671 1
a671 1
		if (-1 != width && ! mdoc_nwarn(mdoc, n, ENOWIDTH))
@


1.43
log
@Added EBADCHILD error (bad child of parent context).
`Rs' post-checks that all children are proper bibliographic elements.
`Rs' correctly re-orders its children as per groff's output (including %C).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.42 2009/08/20 13:22:48 kristaps Exp $ */
d129 1
a129 1
static	v_post	 posts_rs[] = { bwarn_ge1, herr_eq0, post_rs, NULL };
@


1.42
log
@Updated manual structure in mdoc.7.
Synchronised mdoc.template and mdoc.7 manual structure.
`Rv' and `Ex' now accept multiple arguments (-std made standalone, terms as children).
`Rv' and `Ex' format correctly in -Tascii (plurals, commas, etc.).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.41 2009/07/25 16:03:03 kristaps Exp $ */
d92 1
d129 1
d241 1
a241 1
	{ NULL, posts_wline },			/* Rs */
d1082 1
a1082 3
		return(mdoc_verr(mdoc, n->line, n->pos, 
				"bad child of parent %s",
				mdoc_macronames[mdoc->last->tok]));
d1171 44
@


1.41
log
@Patches and results of LLVM static analysis (thanks uqs@@sporlein.net).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.40 2009/07/24 12:09:37 kristaps Exp $ */
a83 1
static	int	 post_args(POST_ARGS);
a119 1
static	v_post	 posts_ex[] = { eerr_eq0, post_args, NULL };
a127 1
static	v_post	 posts_rv[] = { eerr_eq0, post_args, NULL };
d176 1
a176 1
	{ pres_ex, posts_ex },			/* Ex */ 
d190 1
a190 1
	{ pres_rv, posts_rv },			/* Rv */
a921 10
post_args(POST_ARGS)
{

	if (mdoc->last->args)
		return(1);
	return(mdoc_nerr(mdoc, mdoc->last, ELINE));
}


static int
@


1.40
log
@`An' gives correct error message in encountering arguments/parameters.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.39 2009/07/23 08:36:32 kristaps Exp $ */
d1222 1
@


1.39
log
@Bl -column now accepts columns = (1 + stated columns), which covers all remaining column usage/abuse I can see.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.38 2009/07/20 15:05:34 kristaps Exp $ */
d915 1
a915 1
		return(mdoc_nerr(mdoc, mdoc->last, ELINE));
@


1.38
log
@Undocumented behaviour in groff: `Bl -column' implies `-compact'.
mandoc now allows fewer columns than the -width specifies.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.37 2009/07/18 23:31:04 kristaps Exp $ */
d1032 1
a1032 1
		if (i < cols) {
@


1.37
log
@More clarity fixes in mdoc.7.
Sm/Sy argument to `Bf' fixed (schwarze@@openbsd).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.36 2009/07/17 12:40:48 kristaps Exp $ */
d1031 7
a1037 1
		if (i == cols)
d1039 6
a1044 3
		return(mdoc_verr(mdoc, mdoc->last->line, mdoc->last->pos,
				"column mismatch (have %d, want %d)", 
				i, cols));
@


1.36
log
@`sp' documented: validates & produces correct output.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.35 2009/07/17 12:27:49 kristaps Exp $ */
d865 1
a865 1
	else if (0 == strcmp(p, "Sm"))
@


1.35
log
@Removed EARGVPARM (superfluous, overly error-generating).
Added `sp' handler.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.34 2009/07/17 12:08:08 kristaps Exp $ */
d1141 2
d1155 1
a1155 1
			(lval > INT_MAX || lval < INT_MIN))
@


1.34
log
@Documented `br' macro in mdoc.7.
Made `Pp' and `Lp' be inline_eoln() (not sure why they weren't before).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.33 2009/07/17 10:56:57 kristaps Exp $ */
d21 2
a76 1
static	int	 ewarn_eq0(POST_ARGS);
d96 1
d132 1
d276 1
a276 1
	{ NULL, NULL },				/* sp */
a408 1
CHECK_ELEM_DEFN(eq0, warn, warn_child_eq, 0)	/* ewarn_eq0() */
d1134 29
@


1.33
log
@Added `br' and `sp' macros (requested by joerg@@netbsd.org, jmc@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.32 2009/07/13 07:23:07 kristaps Exp $ */
a127 1
static	v_post	 posts_pp[] = { ewarn_eq0, NULL };
d160 1
a160 1
	{ NULL, posts_pp },			/* Pp */ 
d261 1
a261 1
	{ NULL, posts_pp },			/* Lp */ 
@


1.32
log
@Err/warn fix (schwarze@@openbsd.org).
Lots of whitespace churn in getting functions aligned nicely.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.31 2009/07/12 20:50:08 kristaps Exp $ */
d273 2
@


1.31
log
@Replacement of `Lb' in mdoc_action.c.
Added warning against bogus `Lb' (like groff does).
Added proper quotes around `Lb' in mdoc_term.c.
Moved mdoc_a2lib -> libmdoc (where it belongs).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.30 2009/07/12 20:30:35 kristaps Exp $ */
d31 2
a32 3
#define	PRE_ARGS	struct mdoc *mdoc, const struct mdoc_node *n
#define	POST_ARGS	struct mdoc *mdoc

d42 6
a47 6
static	int	check_parent(PRE_ARGS, int, enum mdoc_type);
static	int	check_msec(PRE_ARGS, ...);
static	int	check_sec(PRE_ARGS, ...);
static	int	check_stdarg(PRE_ARGS);
static	int	check_text(struct mdoc *, int, int, const char *);
static	int	check_argv(struct mdoc *, 
d50 1
a50 1
static	int	check_args(struct mdoc *, 
d52 8
a59 8
static	int	err_child_lt(struct mdoc *, const char *, int);
static	int	warn_child_lt(struct mdoc *, const char *, int);
static	int	err_child_gt(struct mdoc *, const char *, int);
static	int	warn_child_gt(struct mdoc *, const char *, int);
static	int	err_child_eq(struct mdoc *, const char *, int);
static	int	warn_child_eq(struct mdoc *, const char *, int);
static	int	warn_print(struct mdoc *, int, int);
static	int	warn_count(struct mdoc *, const char *, 
d61 1
a61 1
static	int	err_count(struct mdoc *, const char *, 
d63 90
a152 85
static	int	pre_an(PRE_ARGS);
static	int	pre_bd(PRE_ARGS);
static	int	pre_bl(PRE_ARGS);
static	int	pre_cd(PRE_ARGS);
static	int	pre_dd(PRE_ARGS);
static	int	pre_display(PRE_ARGS);
static	int	pre_dt(PRE_ARGS);
static	int	pre_er(PRE_ARGS);
static	int	pre_ex(PRE_ARGS);
static	int	pre_fd(PRE_ARGS);
static	int	pre_it(PRE_ARGS);
static	int	pre_lb(PRE_ARGS);
static	int	pre_os(PRE_ARGS);
static	int	pre_rv(PRE_ARGS);
static	int	pre_sh(PRE_ARGS);
static	int	pre_ss(PRE_ARGS);
static	int	herr_ge1(POST_ARGS);
static	int	hwarn_le1(POST_ARGS);
static	int	herr_eq0(POST_ARGS);
static	int	eerr_eq0(POST_ARGS);
static	int	eerr_le2(POST_ARGS);
static	int	eerr_eq1(POST_ARGS);
static	int	eerr_ge1(POST_ARGS);
static	int	ewarn_eq0(POST_ARGS);
static	int	bwarn_ge1(POST_ARGS);
static	int	berr_ge1(POST_ARGS);
static	int	hwarn_eq1(POST_ARGS);
static	int	ewarn_ge1(POST_ARGS);
static	int	ebool(POST_ARGS);

static	int	post_an(POST_ARGS);
static	int	post_args(POST_ARGS);
static	int	post_at(POST_ARGS);
static	int	post_bf(POST_ARGS);
static	int	post_bl(POST_ARGS);
static	int	post_bl_head(POST_ARGS);
static	int	post_it(POST_ARGS);
static	int	post_lb(POST_ARGS);
static	int	post_nm(POST_ARGS);
static	int	post_root(POST_ARGS);
static	int	post_sh(POST_ARGS);
static	int	post_sh_body(POST_ARGS);
static	int	post_sh_head(POST_ARGS);
static	int	post_st(POST_ARGS);

static	v_pre	pres_an[] = { pre_an, NULL };
static	v_pre	pres_bd[] = { pre_display, pre_bd, NULL };
static	v_pre	pres_bl[] = { pre_bl, NULL };
static	v_pre	pres_cd[] = { pre_cd, NULL };
static	v_pre	pres_dd[] = { pre_dd, NULL };
static	v_pre	pres_d1[] = { pre_display, NULL };
static	v_pre	pres_dt[] = { pre_dt, NULL };
static	v_pre	pres_er[] = { pre_er, NULL };
static	v_pre	pres_ex[] = { pre_ex, NULL };
static	v_pre	pres_fd[] = { pre_fd, NULL };
static	v_pre	pres_it[] = { pre_it, NULL };
static	v_pre	pres_lb[] = { pre_lb, NULL };
static	v_pre	pres_os[] = { pre_os, NULL };
static	v_pre	pres_rv[] = { pre_rv, NULL };
static	v_pre	pres_sh[] = { pre_sh, NULL };
static	v_pre	pres_ss[] = { pre_ss, NULL };
static	v_post	posts_bool[] = { eerr_eq1, ebool, NULL };
static	v_post	posts_bd[] = { herr_eq0, bwarn_ge1, NULL };
static	v_post	posts_text[] = { eerr_ge1, NULL };
static	v_post	posts_wtext[] = { ewarn_ge1, NULL };
static	v_post	posts_notext[] = { eerr_eq0, NULL };
static	v_post	posts_wline[] = { bwarn_ge1, herr_eq0, NULL };
static	v_post	posts_sh[] = { herr_ge1, bwarn_ge1, post_sh, NULL };
static	v_post	posts_bl[] = { bwarn_ge1, post_bl, NULL };
static	v_post	posts_it[] = { post_it, NULL };
static	v_post	posts_in[] = { eerr_eq1, NULL };
static	v_post	posts_ss[] = { herr_ge1, NULL };
static	v_post	posts_nd[] = { berr_ge1, NULL };
static	v_post	posts_pf[] = { eerr_eq1, NULL };
static	v_post	posts_lb[] = { eerr_eq1, post_lb, NULL };
static	v_post	posts_st[] = { eerr_eq1, post_st, NULL };
static	v_post	posts_pp[] = { ewarn_eq0, NULL };
static	v_post	posts_ex[] = { eerr_eq0, post_args, NULL };
static	v_post	posts_rv[] = { eerr_eq0, post_args, NULL };
static	v_post	posts_an[] = { post_an, NULL };
static	v_post	posts_at[] = { post_at, NULL };
static	v_post	posts_xr[] = { eerr_ge1, eerr_le2, NULL };
static	v_post	posts_nm[] = { post_nm, NULL };
static	v_post	posts_bf[] = { hwarn_le1, post_bf, NULL };
static	v_post	posts_fo[] = { hwarn_eq1, bwarn_ge1, NULL };
a275 5
#ifdef __linux__
extern	size_t	strlcat(char *, const char *, size_t);
#endif


d277 1
a277 2
mdoc_valid_pre(struct mdoc *mdoc, 
		const struct mdoc_node *n)
a305 8
	/*
	 * This check occurs after the macro's children have been filled
	 * in: postfix validation.  Since this happens when we're
	 * rewinding the scope tree, it's possible to have multiple
	 * invocations (as by design, for now), we set bit MDOC_VALID to
	 * indicate that we've validated.
	 */

d537 1
a537 1
		if ( ! mdoc_perr(mdoc, line, pos, EESCAPE))
@


1.30
log
@Moved mdoc_a2st() out of mdoc.h -> libmdoc.h (replacement in mdoc_action.c).
Made bad standards into an error (were a warning).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.29 2009/07/12 16:41:33 kristaps Exp $ */
d93 1
d101 1
d138 1
a138 1
static	v_post	posts_lb[] = { eerr_eq1, NULL };
d880 10
@


1.29
log
@Check for NAME sanity fixed (last named section -> last section).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.28 2009/07/12 16:38:15 kristaps Exp $ */
d1134 1
a1134 1
	return(mdoc_nwarn(mdoc, mdoc->last, EBADSTAND));
@


1.28
log
@Added back in MDOC_TEXT stipulation in NAME check (post-Nm punctuation, duh).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.27 2009/07/12 16:34:16 kristaps Exp $ */
d1156 1
a1156 1
	if (SEC_NAME != mdoc->lastnamed)
@


1.27
log
@`Nd' is now a BFI (was an ELEM).  Noted by joerg@@netbsd.org, behaviour ok jmc@@openbsd.org, etc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.26 2009/07/12 09:13:21 kristaps Exp $ */
d1171 2
@


1.26
log
@Fixed mdoc_nwarn/mdoc_nerr considering themselves err/warn instead of warn/err (BIG mistake).  From suggestion by <joerg@@netbsd.org>.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.25 2009/07/07 11:47:17 kristaps Exp $ */
d89 1
d134 1
d180 1
a180 1
	{ NULL, posts_wtext },			/* Nd */
d412 1
a1170 2
		if (MDOC_TEXT == n->type)
			continue;
d1175 1
a1175 1
	if (MDOC_ELEM == n->type && MDOC_Nd == n->tok)
@


1.25
log
@Made `In' handling work in new-groff style (see mdoc.samples).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.24 2009/07/07 09:52:08 kristaps Exp $ */
d1220 2
a1221 1
		return(mdoc_nwarn(mdoc, mdoc->last, ESECREP));
d1223 2
a1224 1
		return(mdoc_nwarn(mdoc, mdoc->last, ESECOOO));
@


1.24
log
@Small clean-ups in error message usage.
Version.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.23 2009/07/06 13:04:52 kristaps Exp $ */
a87 1
static	int	ewarn_eq1(POST_ARGS);
d131 1
a131 1
static	v_post	posts_in[] = { ewarn_eq1, NULL };
a409 1
CHECK_ELEM_DEFN(eq1, warn, warn_child_eq, 1)	/* ewarn_eq1() */
@


1.23
log
@Consolidated all err/warnings into mdoc.c via libmdoc.h.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.22 2009/07/06 11:05:29 kristaps Exp $ */
d856 1
a856 2
		return(mdoc_verr(mdoc, mdoc->last->line, 
			mdoc->last->pos, "one argument expected"));
d861 1
a861 2
		return(mdoc_verr(mdoc, mdoc->last->line, 
			mdoc->last->pos, "text argument expected"));
@


1.22
log
@Fix in MDOC_IGN_CHARS ref.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.21 2009/07/06 11:00:05 kristaps Exp $ */
a33 34
enum	merr {
	ETOOLONG,
	EESCAPE,
	EPRINT,
	ENODATA,
	ENOPROLOGUE,
	ELINE,
	EATT,
	ENAME,
	ELISTTYPE,
	EDISPTYPE,
	EMULTIDISP,
	ESECNAME,
	EMULTILIST,
	EARGREP,
	EBOOL,
	ECOLMIS,
	ENESTDISP,
	ENOWIDTH,
	EMISSWIDTH,
	EWRONGMSEC,
	ESECOOO,
	ESECREP,
	EBADSTAND,
	ENAMESECINC,
	ENOMULTILINE,
	EMULTILINE,
	ENOLINE,
	EPROLOOO,
	EPROLREP,
	EARGVAL,
	EBADSEC,
	EBADMSEC
};
a42 1
static	int	perr(struct mdoc *, int, int, enum merr, int);
a106 5
#define	vwarn(m, t) nwarn((m), (m)->last, (t))
#define	verr(m, t) nerr((m), (m)->last, (t))
#define	nwarn(m, n, t) perr((m), (n)->line, (n)->pos, (t), 0)
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t), 1)

a332 115
perr(struct mdoc *m, int line, int pos, enum merr type, int iserr)
{
	char		 *p;
	
	p = NULL;

	switch (type) {
	case (ETOOLONG):
		p = "text argument too long";
		break;
	case (EESCAPE):
		p = "invalid escape sequence";
		break;
	case (EPRINT):
		p = "invalid character";
		break;
	case (ENESTDISP):
		p = "displays may not be nested";
		break;
	case (EBOOL):
		p = "expected boolean value";
		break;
	case (EARGREP):
		p = "argument repeated";
		break;
	case (EMULTIDISP):
		p = "multiple display types specified";
		break;
	case (EMULTILIST):
		p = "multiple list types specified";
		break;
	case (ELISTTYPE):
		p = "missing list type";
		break;
	case (EDISPTYPE):
		p = "missing display type";
		break;
	case (ESECNAME):
		p = "the NAME section must come first";
		break;
	case (ELINE):
		p = "expected line arguments";
		break;
	case (ENOPROLOGUE):
		p = "document has no prologue";
		break;
	case (ENODATA):
		p = "document has no data";
		break;
	case (ECOLMIS):
		p = "column syntax style mismatch";
		break;
	case (EATT):
		p = "expected valid AT&T symbol";
		break;
	case (ENAME):
		p = "default name not yet set";
		break;
	case (ENOWIDTH):
		p = "superfluous width argument";
		break;
	case (EMISSWIDTH):
		p = "missing width argument";
		break;
	case (EWRONGMSEC):
		p = "document section in wrong manual section";
		break;
	case (ESECOOO):
		p = "document section out of conventional order";
		break;
	case (ESECREP):
		p = "document section repeated";
		break;
	case (EBADSTAND):
		p = "unknown standard";
		break;
	case (ENAMESECINC):
		p = "NAME section contents incomplete/badly-ordered";
		break;
	case (ENOMULTILINE):
		p = "suggested no multi-line arguments";
		break;
	case (EMULTILINE):
		p = "suggested multi-line arguments";
		break;
	case (ENOLINE):
		p = "suggested no line arguments";
		break;
	case (EPROLOOO):
		p = "prologue macros out-of-order";
		break;
	case (EPROLREP):
		p = "prologue macros repeated";
		break;
	case (EARGVAL):
		p = "argument value suggested";
		break;
	case (EBADMSEC):
		p = "inappropriate manual section";
		break;
	case (EBADSEC):
		p = "inappropriate document section";
		break;
	}

	assert(p);

	if (iserr)
		return(mdoc_perr(m, line, pos, p));

	return(mdoc_pwarn(m, line, pos, p));
}


static int
d336 3
a338 1
	return(perr(m, ln, pos, EPRINT, ! (MDOC_IGN_CHARS & m->pflags)));
d347 2
a348 2
	return(mdoc_warn(m, "suggests %s %s %d (has %d)", 
				v, k, want, has));
d357 1
a357 1
	return(mdoc_err(m, 
d431 1
a431 1
	return(nwarn(mdoc, n, EARGVAL));
d455 1
a455 1
	return(nwarn(mdoc, n, EBADSEC));
d477 1
a477 1
	return(nwarn(mdoc, n, EBADMSEC));
d512 1
a512 1
		return(nerr(m, n, ENAME));
d543 2
a544 2
			return(perr(mdoc, line, pos, EESCAPE, 1));
		if ( ! perr(mdoc, line, pos, EESCAPE, 0))
d563 1
a563 1
	return(mdoc_nerr(mdoc, n, "require parent %s",
d587 1
a587 1
	return(nerr(mdoc, n, ENESTDISP));
d599 1
a599 1
		return(nerr(mdoc, n, ELISTTYPE));
d630 1
a630 1
				return(nerr(mdoc, n, EMULTILIST));
d635 1
a635 1
				return(nerr(mdoc, n, EARGREP));
d640 1
a640 1
				return(nerr(mdoc, n, EARGREP));
d648 1
a648 1
		return(nerr(mdoc, n, ELISTTYPE));
d658 1
a658 1
		if (-1 == width && ! nwarn(mdoc, n, EMISSWIDTH))
d668 1
a668 1
		if (-1 != width && ! nwarn(mdoc, n, ENOWIDTH))
d687 1
a687 1
		return(nerr(mdoc, n, EDISPTYPE));
d706 1
a706 1
			return(nerr(mdoc, n, EMULTIDISP));
d713 1
a713 1
	return(nerr(mdoc, n, EDISPTYPE));
d753 2
a754 1
	return(mdoc_nerr(mdoc, n, "only one argument allowed"));
d807 1
a807 1
		if ( ! nwarn(mdoc, n, EPROLOOO))
d810 1
a810 1
		if ( ! nwarn(mdoc, n, EPROLREP))
d821 1
a821 1
		if ( ! nwarn(mdoc, n, EPROLOOO))
d824 1
a824 1
		if ( ! nwarn(mdoc, n, EPROLREP))
d835 1
a835 1
		if ( ! nwarn(mdoc, n, EPROLOOO))
d838 1
a838 1
		if ( ! nwarn(mdoc, n, EPROLREP))
d856 2
a857 1
		return(mdoc_err(mdoc, "one argument expected"));
d862 2
a863 1
		return(mdoc_err(mdoc, "text argument expected"));
d874 1
a874 1
	return(mdoc_nerr(mdoc, head->child, "invalid font mode"));
d886 1
a886 1
	return(verr(mdoc, ENAME));
d897 1
a897 1
		return(verr(mdoc, EATT));
d900 1
a900 1
	return(verr(mdoc, EATT));
d911 1
a911 1
		return(verr(mdoc, ELINE));
d916 1
a916 1
	return(verr(mdoc, ELINE));
d926 1
a926 1
	return(verr(mdoc, ELINE));
d941 1
a941 1
		return(verr(mdoc, ELISTTYPE));
d979 1
a979 1
		return(verr(mdoc, ELISTTYPE));
d984 1
a984 1
			if ( ! vwarn(mdoc, ELINE))
d995 1
a995 1
			if ( ! vwarn(mdoc, ELINE))
d998 1
a998 1
			if ( ! vwarn(mdoc, EMULTILINE))
d1011 1
a1011 1
			if ( ! vwarn(mdoc, ENOLINE))
d1014 1
a1014 1
			if ( ! vwarn(mdoc, EMULTILINE))
d1019 1
a1019 1
			if ( ! vwarn(mdoc, ELINE))
d1022 1
a1022 1
			if ( ! vwarn(mdoc, ENOMULTILINE))
d1029 3
a1031 2
		return(mdoc_err(mdoc, "column mismatch (have "
					"%d, want %d)", i, cols));
d1057 1
a1057 1
		return(nerr(mdoc, n, ECOLMIS));
d1080 2
a1081 1
		return(mdoc_nerr(mdoc, n, "bad child of parent %s",
d1107 1
a1107 1
	return(nerr(mdoc, n, EBOOL));
d1116 1
a1116 1
		return(verr(mdoc, ENODATA));
d1118 1
a1118 1
		return(verr(mdoc, ENOPROLOGUE));
d1121 1
a1121 1
		return(verr(mdoc, ENODATA));
d1123 1
a1123 1
		return(verr(mdoc, ENODATA));
d1135 1
a1135 1
	return(vwarn(mdoc, EBADSTAND));
d1167 1
a1167 1
		return(vwarn(mdoc, ENAMESECINC));
d1174 1
a1174 1
		if ( ! vwarn(mdoc, ENAMESECINC))
d1180 1
a1180 1
	return(vwarn(mdoc, ENAMESECINC));
d1205 1
a1205 1
			return(nerr(mdoc, n, ETOOLONG));
d1209 1
a1209 1
			return(nerr(mdoc, n, ETOOLONG));
d1220 1
a1220 1
		return(verr(mdoc, ESECNAME));
d1224 1
a1224 1
		return(vwarn(mdoc, ESECREP));
d1226 1
a1226 1
		return(vwarn(mdoc, ESECOOO));
d1241 1
a1241 1
			return(vwarn(mdoc, EWRONGMSEC));
@


1.21
log
@Consolidated mdoc_validate.c pwarn into perr (slowly phasing out per-file pre-formatted error strings).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.20 2009/07/06 09:21:24 kristaps Exp $ */
d491 1
a491 1
	return(perr(m, ln, pos, EPRINT, ! (MDOC_IGN_CHARS & m->flags)));
@


1.20
log
@Initial removal of enum mdoc_warn from mdoc warnings (unnecessary complication).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.19 2009/07/04 10:41:29 kristaps Exp $ */
d51 16
a66 22
	ENESTDISP
};

enum	mwarn {
	WPRINT,
	WNOWIDTH,
	WMISSWIDTH,
	WESCAPE,
	WWRONGMSEC,
	WSECOOO,
	WSECREP,
	WBADSTAND,
	WNAMESECINC,
	WNOMULTILINE,
	WMULTILINE,
	WLINE,
	WNOLINE,
	WPROLOOO,
	WPROLREP,
	WARGVAL,
	WBADSEC,
	WBADMSEC
d77 1
a77 2
static	int	pwarn(struct mdoc *, int, int, enum mwarn);
static	int	perr(struct mdoc *, int, int, enum merr);
d144 2
a145 2
#define	nwarn(m, n, t) pwarn((m), (n)->line, (n)->pos, (t))
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t))
d373 1
a373 1
perr(struct mdoc *m, int line, int pos, enum merr type)
d378 1
d431 2
a432 16
	}
	assert(p);
	return(mdoc_perr(m, line, pos, p));
}


static int
pwarn(struct mdoc *m, int line, int pos, enum mwarn type)
{
	char		 *p;

	p = NULL;

	switch (type) {
	case (WBADMSEC):
		p = "inappropriate manual section";
d434 2
a435 2
	case (WBADSEC):
		p = "inappropriate document section";
d437 2
a438 2
	case (WARGVAL):
		p = "argument value suggested";
d440 2
a441 2
	case (WPROLREP):
		p = "prologue macros repeated";
d443 2
a444 2
	case (WPROLOOO):
		p = "prologue macros out-of-order";
d446 2
a447 2
	case (WNOWIDTH):
		p = "superfluous width argument";
d449 2
a450 2
	case (WMISSWIDTH):
		p = "missing width argument";
d452 2
a453 2
	case (WPRINT):
		p = "invalid character";
d455 2
a456 2
	case (WESCAPE):
		p = "invalid escape sequence";
d458 1
a458 1
	case (WNOLINE):
d461 2
a462 2
	case (WLINE):
		p = "suggested line arguments";
d464 2
a465 2
	case (WMULTILINE):
		p = "suggested multi-line arguments";
d467 2
a468 2
	case (WNOMULTILINE):
		p = "suggested no multi-line arguments";
d470 2
a471 2
	case (WWRONGMSEC):
		p = "document section in wrong manual section";
d473 2
a474 11
	case (WSECOOO):
		p = "document section out of conventional order";
		break;
	case (WSECREP):
		p = "document section repeated";
		break;
	case (WBADSTAND):
		p = "unknown standard";
		break;
	case (WNAMESECINC):
		p = "NAME section contents incomplete/badly-ordered";
d479 4
d490 2
a491 3
	if (MDOC_IGN_CHARS & m->pflags)
		return(pwarn(m, ln, pos, WPRINT));
	return(perr(m, ln, pos, EPRINT));
d584 1
a584 1
	return(nwarn(mdoc, n, WARGVAL));
d608 1
a608 1
	return(nwarn(mdoc, n, WBADSEC));
d630 1
a630 1
	return(nwarn(mdoc, n, WBADMSEC));
d696 2
a697 2
			return(perr(mdoc, line, pos, EESCAPE));
		if ( ! pwarn(mdoc, line, pos, WESCAPE))
d811 1
a811 1
		if (-1 == width && ! nwarn(mdoc, n, WMISSWIDTH))
d821 1
a821 1
		if (-1 != width && ! nwarn(mdoc, n, WNOWIDTH))
d959 1
a959 1
		if ( ! nwarn(mdoc, n, WPROLOOO))
d962 1
a962 1
		if ( ! nwarn(mdoc, n, WPROLREP))
d973 1
a973 1
		if ( ! nwarn(mdoc, n, WPROLOOO))
d976 1
a976 1
		if ( ! nwarn(mdoc, n, WPROLREP))
d987 1
a987 1
		if ( ! nwarn(mdoc, n, WPROLOOO))
d990 1
a990 1
		if ( ! nwarn(mdoc, n, WPROLREP))
d1134 1
a1134 1
			if ( ! vwarn(mdoc, WLINE))
d1145 1
a1145 1
			if ( ! vwarn(mdoc, WLINE))
d1148 1
a1148 1
			if ( ! vwarn(mdoc, WMULTILINE))
d1161 1
a1161 1
			if ( ! vwarn(mdoc, WNOLINE))
d1164 1
a1164 1
			if ( ! vwarn(mdoc, WMULTILINE))
d1169 1
a1169 1
			if ( ! vwarn(mdoc, WLINE))
d1172 1
a1172 1
			if ( ! vwarn(mdoc, WNOMULTILINE))
d1283 1
a1283 1
	return(vwarn(mdoc, WBADSTAND));
d1315 1
a1315 1
		return(vwarn(mdoc, WNAMESECINC));
d1322 1
a1322 1
		if ( ! vwarn(mdoc, WNAMESECINC))
d1328 1
a1328 1
	return(vwarn(mdoc, WNAMESECINC));
d1372 1
a1372 1
		return(vwarn(mdoc, WSECREP));
d1374 1
a1374 1
		return(vwarn(mdoc, WSECOOO));
d1389 1
a1389 1
			return(vwarn(mdoc, WWRONGMSEC));
@


1.19
log
@Removed WDEPCOL (schwarze@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.18 2009/07/04 09:01:55 kristaps Exp $ */
a446 1
	enum mdoc_warn	  c;
a447 1
	c = WARN_SYNTAX;
d449 1
a452 1
		c = WARN_COMPAT;
a455 1
		c = WARN_COMPAT;
a458 1
		c = WARN_COMPAT;
a461 1
		c = WARN_COMPAT;
a464 1
		c = WARN_COMPAT;
a491 1
		c = WARN_COMPAT;
d506 1
d508 1
a508 1
	return(mdoc_pwarn(m, line, pos, c, p));
d526 2
a527 2
	return(mdoc_warn(m, WARN_SYNTAX, 
		"suggests %s %s %d (has %d)", v, k, want, has));
@


1.18
log
@Moved escape validation into libmandoc.h/mandoc.c (common between libman/libmdoc1).
libman supports MAN_IGN_ESCAPE (like MDOC_IGN_ESCAPE).
All popular escapes now handled consistently.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.17 2009/06/27 09:03:03 kristaps Exp $ */
a58 1
	WDEPCOL,
a471 4
	case (WDEPCOL):
		p = "deprecated column argument syntax";
		c = WARN_COMPAT;
		break;
@


1.17
log
@Removed escape-deprecation note (better solution in progress, schwarze@@openbsd.org).
Using EXIT_FAILURE for parse errors (nicm@@openbsd.org).
Fixed use of warn/warnx (nicm@@openbsd.org).
Fixed use of getsubopt (nicm@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.16 2009/06/18 20:46:19 kristaps Exp $ */
d26 1
d712 1
a712 1
	size_t		 c;
d714 1
a714 1
	for ( ; *p; p++) {
d726 1
a726 1
		c = mdoc_isescape(p);
d728 2
a729 1
			p += (int)c - 1;
@


1.16
log
@Added nchild decrement in libman (not used, but better in than forgotten).
Added nchild to libmdoc, deprecated count() functions in validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.15 2009/06/17 14:10:09 kristaps Exp $ */
a57 1
	WDEPESC,
a487 3
	case (WDEPESC):
		p = "deprecated special-character escape";
		break;
a726 4
			/* See if form is deprecated. */
			if ('*' == p[1]) 
				if ( ! pwarn(mdoc, line, pos, WDEPESC))
					return(0);
@


1.15
log
@Lint fixes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.14 2009/06/17 14:08:47 kristaps Exp $ */
a101 1
static	int	count_child(struct mdoc *);
a554 13
static inline int
count_child(struct mdoc *mdoc)
{
	int		  i;
	struct mdoc_node *n;

	for (i = 0, n = mdoc->last->child; n; n = n->next, i++)
		/* Do nothing */ ;

	return(i);
}


d565 1
a565 2
	int i; 							\
	if ((i = count_child(mdoc)) ineq sz) 			\
d567 1
a567 1
	return(lvl##_count(mdoc, #ineq, sz, p, i)); 		\
@


1.14
log
@`Bl -column' now correctly handles tail entries (Bl -column -more... arg0...).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.13 2009/06/17 11:02:06 kristaps Exp $ */
d805 1
a805 1
	int		 pos, col, type, width, offset;
d814 1
a814 1
	type = offset = width = col = -1;
a842 1
			col = pos;
@


1.13
log
@Cleaned up .Bf validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.12 2009/06/17 10:53:32 kristaps Exp $ */
d49 1
d142 1
d179 1
a179 1
static	v_post	posts_bl[] = { herr_eq0, bwarn_ge1, post_bl, NULL };
d430 3
a886 16
	/*
	 * General validation of fields.
	 */

	switch (type) {
	case (MDOC_Column):
		assert(col >= 0);
		if (0 == n->args->argv[col].sz)
			break;
		if ( ! nwarn(mdoc, n, WDEPCOL))
			return(0);
		break;
	default:
		break;
	}

d1249 23
d1276 2
@


1.12
log
@Section orders are more elegantly handled (MDOC_PBODY is a flag).
Cleaned up string->enum conversion for section lookup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.11 2009/06/17 09:41:00 kristaps Exp $ */
a1074 2
	/* FIXME: clean-up .*/

d1078 3
d1082 2
a1083 4
	if (NULL == mdoc->last->args) {
		if (NULL == head->child || 
				MDOC_TEXT != head->child->type)
			return(mdoc_err(mdoc, "text argument expected"));
d1085 1
a1085 9
		p = head->child->string;
		if (0 == strcmp(p, "Em"))
			return(1);
		else if (0 == strcmp(p, "Li"))
			return(1);
		else if (0 == strcmp(p, "Sm"))
			return(1);
		return(mdoc_nerr(mdoc, head->child, "invalid font"));
	}
d1087 6
a1092 2
	if (head->child)
		return(mdoc_err(mdoc, "one argument expected"));
d1094 1
a1094 1
	return(1);
@


1.11
log
@Noted deprecation of \*( and \* special-character escapes.
Minor clean-ups.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.10 2009/06/16 19:45:51 kristaps Exp $ */
d45 1
a119 1
static	int	pre_prologue(PRE_ARGS);
d158 1
a158 1
static	v_pre	pres_dd[] = { pre_prologue, pre_dd, NULL };
d160 1
a160 1
static	v_pre	pres_dt[] = { pre_prologue, pre_dt, NULL };
d166 1
a166 1
static	v_pre	pres_os[] = { pre_prologue, pre_os, NULL };
d416 3
a1024 8
pre_prologue(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_PROLOGUE, SEC_CUSTOM));
}


static int
d1075 2
d1079 2
d1315 1
a1315 1
	if (SEC_PROLOGUE == mdoc->lastnamed)
d1396 1
a1396 1
	assert(MDOC_Sh == mdoc->last->tok);
a1397 3
	/* This is just concat() inlined, which is irritating. */

	buf[0] = 0;
d1399 1
d1401 1
d1412 4
a1415 1
	/* The NAME section should always be first. */
d1417 2
a1418 2
	if (SEC_BODY == mdoc->lastnamed && SEC_NAME != sec)
		return(vwarn(mdoc, WSECOOO));
a1420 3

	/* Check for repeated or out-of-order sections. */

d1426 4
a1429 1
	/* Check particular section/manual section conventions. */
@


1.10
log
@Removed MDOC___: moved MDOC_Ap to its index (comments not passed into mdoc parser).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.9 2009/06/12 09:18:00 kristaps Exp $ */
d56 1
d482 3
a723 2
	/* FIXME: indicate deprecated escapes \*(xx and \*x. */

d738 4
@


1.9
log
@`Lk' is correctly handled as CALLABLE (note groff munges nested output).
`Mt' is now CALLABLE.
Fixed missing validate/action of zero-element, non-called inline elements.
Fixed missing validate/action of nested inline element re-calls.
Fixed bogus column argv index in validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.8 2009/06/11 10:34:31 kristaps Exp $ */
d194 1
a194 1
	{ NULL, NULL }, 			/* \" */
a300 1
	{ NULL, NULL },				/* Ap */
@


1.8
log
@Clean up validation of field widths.
Pushed field-width warn/error into warn/error routine.
Removed superfluous space at output eoln.
Fixed overzealous line break in lists.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.7 2009/06/10 20:18:43 kristaps Exp $ */
d303 1
a303 1
	{ NULL, posts_text },			/* Lk */ 
d792 1
a792 1
	int		 pos, type, width, offset;
d801 1
a801 1
	type = offset = width = -1;
d830 1
d880 2
a881 1
		if (0 == n->args->argv[pos].sz)
@


1.7
log
@Fixed license email address.
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.6 2009/04/12 19:49:35 kristaps Exp $ */
d53 2
d56 1
d466 10
d792 1
a792 1
	int		 i, type, width, offset;
d804 2
a805 2
	for (i = 0; i < (int)n->args->argc; i++)
		switch (n->args->argv[i].arg) {
d827 4
a830 5
			if (-1 == type) {
				type = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EMULTILIST));
d832 4
a835 5
			if (-1 == width) {
				width = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EARGREP));
d837 4
a840 5
			if (-1 == offset) {
				offset = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EARGREP));
d848 6
d855 4
d866 14
a879 1
		if (-1 == width)
d881 3
a883 9
		return(mdoc_nwarn(mdoc, n, WARN_SYNTAX,
				"superfluous %s argument",
				mdoc_argnames[MDOC_Width]));
	case (MDOC_Tag):
		if (-1 != width)
			break;
		return(mdoc_nwarn(mdoc, n, WARN_SYNTAX, 
				"suggest %s argument", 
				mdoc_argnames[MDOC_Width]));
@


1.6
log
@Version bumped.
`.Er' has more section restrictions (Joerg).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.5 2009/04/12 19:45:26 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
@


1.5
log
@Using proper license template (const).
@
text
@d1 1
a1 1
/*	$Id: mdoc_validate.c,v 1.4 2009/04/12 19:19:57 kristaps Exp $ */
d975 1
a975 1
	return(check_msec(mdoc, n, 2, 0));
@


1.4
log
@Manual .Dt fields CAPITALISED.
Indent set to 5 chars (nroff compat).
Half-indent set to 3 chars (nroff compat).
Default behaviour is loose-y (ignore macro/char/escape).
Added -fstrict.
Added unknown-character ignoring.
@
text
@d1 1
a1 1
/* $Id: mdoc_validate.c,v 1.3 2009/04/02 16:37:40 kristaps Exp $ */
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.3
log
@Added -p1003.1-2008 specification.
Fixed invalid memory accesses (concat()).
Made -fign-macro be the default for libman.
@
text
@d1 1
a1 1
/* $Id: mdoc_validate.c,v 1.2 2009/03/31 13:50:19 kristaps Exp $ */
d54 1
d99 1
d465 3
d505 8
d715 2
a716 1
				return(perr(mdoc, line, pos, EPRINT));
d718 2
a719 1
			return(perr(mdoc, line, pos, EPRINT));
@


1.2
log
@General clean-ups.
@
text
@d1 1
a1 1
/* $Id: mdoc_validate.c,v 1.1 2009/03/25 15:17:49 kristaps Exp $ */
a313 1
extern	size_t	strlcpy(char *, const char *, size_t);
d1354 1
@


1.1
log
@Added man validator, renamed mdoc validator.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.93 2009/03/23 14:22:11 kristaps Exp $ */
d25 1
a31 8
/*
 * Pre- and post-validate macros as they're parsed.  Pre-validation
 * occurs when the macro has been detected and its arguments parsed.
 * Post-validation occurs when all child macros have also been parsed.
 * In the ELEMENT case, this is simply the parameters of the macro; in
 * the BLOCK case, this is the HEAD, BODY, TAIL and so on.
 */

d36 1
a78 2
/* Utility checks. */

d97 2
a98 2
static	inline int count_child(struct mdoc *);
static	inline int warn_count(struct mdoc *, const char *, 
d100 1
a100 1
static	inline int err_count(struct mdoc *, const char *, 
a131 1

d145 2
a146 2
#define	mwarn(m, t) nwarn((m), (m)->last, (t))
#define	merr(m, t) nerr((m), (m)->last, (t))
d313 6
d384 3
d1042 1
a1042 1
		if (xstrcmp(p, "Em"))
d1044 1
a1044 1
		else if (xstrcmp(p, "Li"))
d1046 1
a1046 1
		else if (xstrcmp(p, "Sm"))
d1066 1
a1066 1
	return(merr(mdoc, ENAME));
d1077 1
a1077 1
		return(merr(mdoc, EATT));
d1080 1
a1080 1
	return(merr(mdoc, EATT));
d1091 1
a1091 1
		return(merr(mdoc, ELINE));
d1096 1
a1096 1
	return(merr(mdoc, ELINE));
d1106 1
a1106 1
	return(merr(mdoc, ELINE));
d1121 1
a1121 1
		return(merr(mdoc, ELISTTYPE));
d1159 1
a1159 1
		return(merr(mdoc, ELISTTYPE));
d1164 1
a1164 1
			if ( ! mwarn(mdoc, WLINE))
d1175 1
a1175 1
			if ( ! mwarn(mdoc, WLINE))
d1178 1
a1178 1
			if ( ! mwarn(mdoc, WMULTILINE))
d1191 1
a1191 1
			if ( ! mwarn(mdoc, WNOLINE))
d1194 1
a1194 1
			if ( ! mwarn(mdoc, WMULTILINE))
d1199 1
a1199 1
			if ( ! mwarn(mdoc, WLINE))
d1202 1
a1202 1
			if ( ! mwarn(mdoc, WNOMULTILINE))
d1251 1
a1251 1
		if (xstrcmp(n->string, "on"))
d1253 1
a1253 1
		if (xstrcmp(n->string, "off"))
d1269 1
a1269 1
		return(merr(mdoc, ENODATA));
d1271 1
a1271 1
		return(merr(mdoc, ENOPROLOGUE));
d1274 1
a1274 1
		return(merr(mdoc, ENODATA));
d1276 1
a1276 1
		return(merr(mdoc, ENODATA));
d1288 1
a1288 1
	return(mwarn(mdoc, WBADSTAND));
d1320 1
a1320 1
		return(mwarn(mdoc, WNAMESECINC));
d1327 1
a1327 1
		if ( ! mwarn(mdoc, WNAMESECINC))
d1333 1
a1333 1
	return(mwarn(mdoc, WNAMESECINC));
d1340 3
a1342 2
	char		  buf[64];
	enum mdoc_sec	  sec;
d1353 11
a1363 1
	(void)xstrlcpys(buf, mdoc->last->child, sizeof(buf));
d1370 1
a1370 1
		return(mwarn(mdoc, WSECOOO));
d1377 1
a1377 1
		return(mwarn(mdoc, WSECREP));
d1379 1
a1379 1
		return(mwarn(mdoc, WSECOOO));
d1391 1
a1391 1
			return(mwarn(mdoc, WWRONGMSEC));
@
